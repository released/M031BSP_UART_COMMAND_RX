; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart_command.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart_command.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart_command.crf ..\UART_Command.c]
                          THUMB

                          AREA ||i.CustomUartCmdHandler_Function01_Set||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function01_Set PROC
;;;115    // TODO: Step #2 , modify function to expect behavior , set data by TX or get data and return to TX 
;;;116    UARTCMD_RESULT_t CustomUartCmdHandler_Function01_Set(UARTCMD_BUF_t *cmd)	//customize
000000  2000              MOVS     r0,#0
                  |L1.2|
;;;117    {
;;;118    	uint8_t temp = 0;	//example , put command data into a variable
;;;119    	uint16_t i = 0;
000002  1c40              ADDS     r0,r0,#1
;;;120    
;;;121    	//for this example , use temp to store data
;;;122    	for (i=0;i<UARTCMD_DATA_LEN;i++)
000004  b280              UXTH     r0,r0
000006  2804              CMP      r0,#4
000008  d3fb              BCC      |L1.2|
;;;123    	{
;;;124    
;;;125    
;;;126    		temp = cmd->transferdata[i];
;;;127    	}
;;;128    
;;;129    	(void) temp;
;;;130    	
;;;131    	return RESULT_ACK_OK;
00000a  2000              MOVS     r0,#0
;;;132    }
00000c  4770              BX       lr
;;;133    
                          ENDP


                          AREA ||i.CustomUartCmdHandler_Function02_Get||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function02_Get PROC
;;;141    */
;;;142    UARTCMD_RESULT_t CustomUartCmdHandler_Function02_Get(UARTCMD_BUF_t *cmd)	//customize
000000  b508              PUSH     {r3,lr}
;;;143    {
;;;144    	uint8_t OutData = 0x96;		//example , set 1 byte data out
000002  2096              MOVS     r0,#0x96
000004  4669              MOV      r1,sp
000006  7008              STRB     r0,[r1,#0]
;;;145    
;;;146    	_UartCmdParser_CmdFormat(UARTCMD_1_BYTE_DATA,&OutData);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       _UartCmdParser_CmdFormat
;;;147    
;;;148    	(void) cmd;
;;;149    	
;;;150    	return RESULT_ACK_OK;
00000e  2000              MOVS     r0,#0
;;;151    }
000010  bd08              POP      {r3,pc}
;;;152    
                          ENDP


                          AREA ||i.CustomUartCmdHandler_Function03_Get||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function03_Get PROC
;;;160    */
;;;161    UARTCMD_RESULT_t CustomUartCmdHandler_Function03_Get(UARTCMD_BUF_t *cmd)	//customize
000000  b508              PUSH     {r3,lr}
;;;162    {
;;;163    	uint8_t Output[UARTCMD_2_BYTE_DATA] = {0};	//example , set 2 byte bit data out
000002  2000              MOVS     r0,#0
;;;164    
;;;165    	Output[0] = 0x12;
000004  9000              STR      r0,[sp,#0]
000006  2012              MOVS     r0,#0x12
000008  4669              MOV      r1,sp
00000a  7008              STRB     r0,[r1,#0]
;;;166    	Output[1] = 0x34;
00000c  2034              MOVS     r0,#0x34
00000e  7048              STRB     r0,[r1,#1]
;;;167    
;;;168    	_UartCmdParser_CmdFormat(UARTCMD_2_BYTE_DATA,Output);
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       _UartCmdParser_CmdFormat
;;;169    
;;;170    	(void) cmd;
;;;171    	
;;;172    	return RESULT_ACK_OK;
000016  2000              MOVS     r0,#0
;;;173    } 
000018  bd08              POP      {r3,pc}
;;;174    
                          ENDP


                          AREA ||i.CustomUartCmdHandler_Function04_Get||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function04_Get PROC
;;;182    */
;;;183    UARTCMD_RESULT_t CustomUartCmdHandler_Function04_Get(UARTCMD_BUF_t *cmd)	//customize
000000  b508              PUSH     {r3,lr}
;;;184    {
;;;185    	uint8_t Output[UARTCMD_4_BYTE_DATA] = {0};	//example , set 4 byte bit data out
000002  2000              MOVS     r0,#0
;;;186    
;;;187    	Output[0] = 0x55;
000004  9000              STR      r0,[sp,#0]
000006  2055              MOVS     r0,#0x55
000008  4669              MOV      r1,sp
00000a  7008              STRB     r0,[r1,#0]
;;;188    	Output[1] = 0x66;
00000c  2066              MOVS     r0,#0x66
00000e  7048              STRB     r0,[r1,#1]
;;;189    	Output[2] = 0x32;
000010  2032              MOVS     r0,#0x32
000012  7088              STRB     r0,[r1,#2]
;;;190    	Output[3] = 0x31;
000014  2031              MOVS     r0,#0x31
000016  70c8              STRB     r0,[r1,#3]
;;;191    	
;;;192    	_UartCmdParser_CmdFormat(UARTCMD_4_BYTE_DATA,Output);
000018  2004              MOVS     r0,#4
00001a  f7fffffe          BL       _UartCmdParser_CmdFormat
;;;193    
;;;194    	(void) cmd;
;;;195    	
;;;196    	return RESULT_ACK_OK;
00001e  2000              MOVS     r0,#0
;;;197    } 
000020  bd08              POP      {r3,pc}
;;;198    
                          ENDP


                          AREA ||i.CustomUartCmdHandler_Function05_Set||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function05_Set PROC
;;;206    */
;;;207    UARTCMD_RESULT_t CustomUartCmdHandler_Function05_Set(UARTCMD_BUF_t *cmd)	//customize
000000  2000              MOVS     r0,#0
                  |L5.2|
;;;208    {
;;;209    	uint8_t temp = 0;	//example , put command data into a your application data address
;;;210    	uint16_t i = 0;
000002  1c40              ADDS     r0,r0,#1
;;;211    
;;;212    	//for this example , use temp to store data
;;;213    	for (i=0;i<UARTCMD_3_BYTE_DATA;i++)
000004  b280              UXTH     r0,r0
000006  2803              CMP      r0,#3
000008  d3fb              BCC      |L5.2|
;;;214    	{
;;;215    
;;;216    
;;;217    		temp = cmd->transferdata[i];
;;;218    	}
;;;219    
;;;220    	(void) temp;
;;;221    	
;;;222    	return RESULT_ACK_OK;
00000a  2000              MOVS     r0,#0
;;;223    } 
00000c  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||i.CustomUartCmdHandler_Function06_Get||, CODE, READONLY, ALIGN=1

                  CustomUartCmdHandler_Function06_Get PROC
;;;233    
;;;234    UARTCMD_RESULT_t CustomUartCmdHandler_Function06_Get(UARTCMD_BUF_t *cmd)	//customize
000000  b508              PUSH     {r3,lr}
;;;235    {
;;;236    	uint8_t Output[UARTCMD_3_BYTE_DATA] = {0};	//example , set 3 byte bit data out
000002  2000              MOVS     r0,#0
;;;237    
;;;238    	Output[0]=0x13;
000004  9000              STR      r0,[sp,#0]
000006  2013              MOVS     r0,#0x13
000008  4669              MOV      r1,sp
00000a  7008              STRB     r0,[r1,#0]
;;;239    	Output[1]=0x57;
00000c  2057              MOVS     r0,#0x57
00000e  7048              STRB     r0,[r1,#1]
;;;240    	Output[2]=0x90;
000010  2090              MOVS     r0,#0x90
000012  7088              STRB     r0,[r1,#2]
;;;241    	
;;;242    	_UartCmdParser_CmdFormat(UARTCMD_3_BYTE_DATA,Output);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       _UartCmdParser_CmdFormat
;;;243    
;;;244    	(void) cmd;
;;;245    	
;;;246    	return RESULT_ACK_OK;
00001a  2000              MOVS     r0,#0
;;;247    } 
00001c  bd08              POP      {r3,pc}
;;;248    
                          ENDP


                          AREA ||i.SystemClkDelay||, CODE, READONLY, ALIGN=1

                  SystemClkDelay PROC
                  |L7.0|
;;;466    
;;;467    void SystemClkDelay(uint16_t Delay)
000000  4601              MOV      r1,r0
;;;468    {
;;;469    	while(Delay--);
000002  1e40              SUBS     r0,r0,#1
000004  b280              UXTH     r0,r0
000006  2900              CMP      r1,#0
000008  d1fa              BNE      |L7.0|
;;;470    }
00000a  4770              BX       lr
;;;471    
                          ENDP


                          AREA ||i.UART0_Process||, CODE, READONLY, ALIGN=2

                  UART0_Process PROC
;;;531    // TODO: Step #6 , add UART0_Process to while loop
;;;532    void UART0_Process(void)
000000  b510              PUSH     {r4,lr}
;;;533    {
;;;534    	if(u8SetProcessPkt)
000002  4816              LDR      r0,|L8.92|
000004  7841              LDRB     r1,[r0,#1]  ; u8SetProcessPkt
000006  2900              CMP      r1,#0
000008  d021              BEQ      |L8.78|
;;;535    	{
;;;536    		u8SetProcessPkt=0;
00000a  2100              MOVS     r1,#0
00000c  4c14              LDR      r4,|L8.96|
00000e  7041              STRB     r1,[r0,#1]
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _UartCmdParser_GetChecksum
000016  79e1              LDRB     r1,[r4,#7]
000018  4288              CMP      r0,r1
00001a  d002              BEQ      |L8.34|
00001c  4621              MOV      r1,r4
00001e  2002              MOVS     r0,#2
000020  e018              B        |L8.84|
                  |L8.34|
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       _UartCmdParser_FindHandlerIndex
000028  2800              CMP      r0,#0
00002a  da02              BGE      |L8.50|
00002c  4621              MOV      r1,r4
00002e  2003              MOVS     r0,#3
000030  e010              B        |L8.84|
                  |L8.50|
000032  490a              LDR      r1,|L8.92|
000034  00c0              LSLS     r0,r0,#3
000036  1d09              ADDS     r1,r1,#4
000038  1840              ADDS     r0,r0,r1
00003a  6840              LDR      r0,[r0,#4]
00003c  2800              CMP      r0,#0
00003e  d007              BEQ      |L8.80|
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       _UartCmdParser_Set_cmd
                  |L8.70|
;;;537    
;;;538    		_UartCmdParser_Parse_cmd();
;;;539    
;;;540    		#if 0 //debug
;;;541    		UartCmd_Send(aui1_cmd_buf,sizeof( aui1_cmd_buf));
;;;542    		#endif
;;;543    
;;;544    		//reset buffer after cmd process
;;;545    		memset( aui1_cmd_buf,0,sizeof( aui1_cmd_buf));			
000046  2109              MOVS     r1,#9
000048  4805              LDR      r0,|L8.96|
00004a  f7fffffe          BL       __aeabi_memclr
                  |L8.78|
;;;546    	}
;;;547    }
00004e  bd10              POP      {r4,pc}
                  |L8.80|
000050  4621              MOV      r1,r4
000052  2001              MOVS     r0,#1
                  |L8.84|
000054  f7fffffe          BL       _UartCmdParser_SendFeedback
000058  e7f5              B        |L8.70|
;;;548    
                          ENDP

00005a  0000              DCW      0x0000
                  |L8.92|
                          DCD      ||.data||
                  |L8.96|
                          DCD      ||.bss||

                          AREA ||i.UartCmd_Rx_Receive||, CODE, READONLY, ALIGN=2

                  UartCmd_Rx_Receive PROC
;;;473    // TODO: Step #5 , add UartCmd_Rx_Receive to UART IRQ handler
;;;474    void UartCmd_Rx_Receive(uint8_t tmp)
000000  b570              PUSH     {r4-r6,lr}
;;;475    {
;;;476    	aui1_cmd_buf[u8UartRxCnt++] = tmp;
000002  4c10              LDR      r4,|L9.68|
000004  4a0e              LDR      r2,|L9.64|
000006  7821              LDRB     r1,[r4,#0]  ; u8UartRxCnt
000008  5450              STRB     r0,[r2,r1]
00000a  1c49              ADDS     r1,r1,#1
00000c  0608              LSLS     r0,r1,#24
00000e  0e00              LSRS     r0,r0,#24
000010  7020              STRB     r0,[r4,#0]
000012  d010              BEQ      |L9.54|
;;;477    
;;;478    	//force to check buffer header/length/tail , reset counter if meet cmd format
;;;479    	if(u8UartRxCnt !=0 ||	aui1_cmd_buf[u8UartRxCnt] == UARTCMD_HEADER)		
;;;480    	{
;;;481    		if ( u8UartRxCnt == UARTCMD_LENGTH )		
000014  2809              CMP      r0,#9
000016  d10e              BNE      |L9.54|
;;;482    		{
;;;483    			if ( aui1_cmd_buf[u8UartRxCnt-1] == UARTCMD_TAILER )
000018  4610              MOV      r0,r2
00001a  7a00              LDRB     r0,[r0,#8]
00001c  2500              MOVS     r5,#0
00001e  2881              CMP      r0,#0x81
000020  d00a              BEQ      |L9.56|
;;;484    			{
;;;485    				u8UartRxCnt = 0;
;;;486    				u8SetProcessPkt = 1;
;;;487    			}
;;;488    			else
;;;489    			{
;;;490    				//bad cmd format , send not support ack			
;;;491    				_UartCmdParser_SendFeedback(RESULT_ACK_BAD_FORMAT, NULL);	
000022  2100              MOVS     r1,#0
000024  2004              MOVS     r0,#4
000026  f7fffffe          BL       _UartCmdParser_SendFeedback
;;;492    				
;;;493    				#if 0 //debug
;;;494    				UartCmd_Send(">>>\r\n",sizeof(">>>\r\n"));				
;;;495    				UART_Send_Data(UART0 , 	UARTCMD_LENGTH);
;;;496    				UartCmd_Send(">>>\r\n",sizeof(">>>\r\n"));
;;;497    				UartCmd_Send(aui1_cmd_buf,sizeof( aui1_cmd_buf));
;;;498    				UartCmd_Send("\r\n<<<\r\n",sizeof("\r\n<<<\r\n"));
;;;499    				#endif /*debug*/	
;;;500    
;;;501    				//need to manual reset the buffer data , prevent buffer overflow
;;;502    				memset( aui1_cmd_buf,0,sizeof( aui1_cmd_buf));	
00002a  2109              MOVS     r1,#9
00002c  4804              LDR      r0,|L9.64|
00002e  f7fffffe          BL       __aeabi_memclr
;;;503    				u8UartRxCnt = 0;
000032  7025              STRB     r5,[r4,#0]
;;;504    				u8SetProcessPkt = 0;	
000034  7065              STRB     r5,[r4,#1]
                  |L9.54|
;;;505    			}
;;;506    		}
;;;507    	}
;;;508    
;;;509    	//make sure clear RX flag	
;;;510    }
000036  bd70              POP      {r4-r6,pc}
                  |L9.56|
000038  7025              STRB     r5,[r4,#0]            ;485
00003a  2001              MOVS     r0,#1                 ;486
00003c  7060              STRB     r0,[r4,#1]            ;486
00003e  bd70              POP      {r4-r6,pc}
;;;511    
                          ENDP

                  |L9.64|
                          DCD      ||.bss||
                  |L9.68|
                          DCD      ||.data||

                          AREA ||i.UartCmd_Send||, CODE, READONLY, ALIGN=2

                  UartCmd_Send PROC
;;;511    
;;;512    void UartCmd_Send(uint8_t *pui1_data ,uint8_t z_len )
000000  b510              PUSH     {r4,lr}
;;;513    {
;;;514    //   	uint8_t i;
;;;515    
;;;516    	UART_DISABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000002  4c08              LDR      r4,|L10.36|
000004  4603              MOV      r3,r0                 ;513
000006  6860              LDR      r0,[r4,#4]
000008  4a07              LDR      r2,|L10.40|
00000a  4010              ANDS     r0,r0,r2
00000c  6060              STR      r0,[r4,#4]
;;;517    
;;;518    	#if 1
;;;519    	UART_Write(UART0,pui1_data,z_len);
00000e  460a              MOV      r2,r1
000010  4619              MOV      r1,r3
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       UART_Write
;;;520    	#else
;;;521    	for (i=0 ;i<z_len;i++)
;;;522    	{
;;;523    		SystemClkDelay(0x40);
;;;524    		UART_Send_Data(UART0 , (uint8_t)*(pui1_data+i));
;;;525    	}
;;;526    	#endif
;;;527    
;;;528    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
000018  6860              LDR      r0,[r4,#4]
00001a  4903              LDR      r1,|L10.40|
00001c  43c9              MVNS     r1,r1
00001e  4308              ORRS     r0,r0,r1
000020  6060              STR      r0,[r4,#4]
;;;529    }
000022  bd10              POP      {r4,pc}
;;;530    
                          ENDP

                  |L10.36|
                          DCD      0x40070000
                  |L10.40|
                          DCD      0xfffff7ee

                          AREA ||i._UartCmdParser_CmdFormat||, CODE, READONLY, ALIGN=2

                  _UartCmdParser_CmdFormat PROC
;;;294    
;;;295    static void _UartCmdParser_CmdFormat(uint8_t length,uint8_t *transferdata)
000000  b530              PUSH     {r4,r5,lr}
;;;296    {
;;;297    	//Need to manual decide the cmd output data
;;;298    	uint16_t len = 0 ;
;;;299    
;;;300    	UartCommand.datalength = length;	
000002  4b06              LDR      r3,|L11.28|
000004  2200              MOVS     r2,#0                 ;298
000006  7098              STRB     r0,[r3,#2]
000008  e004              B        |L11.20|
                  |L11.10|
;;;301    	for (len=0;len<length;len++)
;;;302    	{
;;;303    		UartCommand.transferdata[len] = *(transferdata+len);
00000a  5c8c              LDRB     r4,[r1,r2]
00000c  189d              ADDS     r5,r3,r2
00000e  1c52              ADDS     r2,r2,#1
000010  70ec              STRB     r4,[r5,#3]
000012  b292              UXTH     r2,r2                 ;301
                  |L11.20|
000014  4282              CMP      r2,r0                 ;301
000016  d3f8              BCC      |L11.10|
;;;304    	}	
;;;305    }
000018  bd30              POP      {r4,r5,pc}
;;;306    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      ||.bss||+0x9

                          AREA ||i._UartCmdParser_FindHandlerIndex||, CODE, READONLY, ALIGN=2

                  _UartCmdParser_FindHandlerIndex PROC
;;;389    
;;;390    static int _UartCmdParser_FindHandlerIndex(UARTCMD_BUF_t *cmd)
000000  b5f0              PUSH     {r4-r7,lr}
;;;391    {
;;;392        int i;
;;;393    
;;;394        for (i=0; _UartCmdParser_Array[i].cmd_code != 0xFF; i++)
000002  2200              MOVS     r2,#0
;;;395        {
;;;396            if ((cmd->header == UARTCMD_HEADER) &&
;;;397              (cmd->function == _UartCmdParser_Array[i].cmd_code) &&
000004  4d16              LDR      r5,|L12.96|
000006  e024              B        |L12.82|
                  |L12.8|
000008  7804              LDRB     r4,[r0,#0]            ;396
00000a  2c34              CMP      r4,#0x34              ;396
00000c  d120              BNE      |L12.80|
00000e  7844              LDRB     r4,[r0,#1]
000010  429c              CMP      r4,r3
000012  d11d              BNE      |L12.80|
;;;398              (cmd->tailer == UARTCMD_TAILER))
000014  7a03              LDRB     r3,[r0,#8]
000016  2b81              CMP      r3,#0x81
000018  d11a              BNE      |L12.80|
;;;399    		{
;;;400    			#if 0	//debug
;;;401    			//UART_Send_Data(UART0 ,_UartCmdParser_Array[i].datalength);
;;;402    			//UART_Send_Data(UART0 ,cmd->length);			
;;;403    			//UART_Send_Data(UART0 , _UartCmdParser_Array[i].data1);	
;;;404    			//UART_Send_Data(UART0 , cmd->data[0]);	
;;;405    			#endif
;;;406    			
;;;407    			if ( (_UartCmdParser_Array[i].data_length == UARTCMD_WILDCARD && _UartCmdParser_Array[i].data_template == UARTCMD_WILDCARD) ||
00001a  1949              ADDS     r1,r1,r5
00001c  784b              LDRB     r3,[r1,#1]
00001e  2bfd              CMP      r3,#0xfd
000020  d102              BNE      |L12.40|
000022  788c              LDRB     r4,[r1,#2]
000024  2cfd              CMP      r4,#0xfd
000026  d011              BEQ      |L12.76|
                  |L12.40|
;;;408    				(_UartCmdParser_Array[i].data_length == cmd->datalength && _UartCmdParser_Array[i].data_template == UARTCMD_WILDCARD) ||
000028  7884              LDRB     r4,[r0,#2]
00002a  42a3              CMP      r3,r4
00002c  d102              BNE      |L12.52|
00002e  788e              LDRB     r6,[r1,#2]
000030  2efd              CMP      r6,#0xfd
000032  d00b              BEQ      |L12.76|
                  |L12.52|
;;;409    				(_UartCmdParser_Array[i].data_length == UARTCMD_WILDCARD && _UartCmdParser_Array[i].data_template == cmd->transferdata[0]) ||
000034  2bfd              CMP      r3,#0xfd
000036  d103              BNE      |L12.64|
000038  788e              LDRB     r6,[r1,#2]
00003a  78c7              LDRB     r7,[r0,#3]
00003c  42be              CMP      r6,r7
00003e  d005              BEQ      |L12.76|
                  |L12.64|
;;;410    				(_UartCmdParser_Array[i].data_length == cmd->datalength && _UartCmdParser_Array[i].data_template == cmd->transferdata[0]) )
000040  42a3              CMP      r3,r4
000042  d105              BNE      |L12.80|
000044  7889              LDRB     r1,[r1,#2]
000046  78c3              LDRB     r3,[r0,#3]
000048  4299              CMP      r1,r3
00004a  d101              BNE      |L12.80|
                  |L12.76|
;;;411    			{
;;;412    				return i;
00004c  4610              MOV      r0,r2
;;;413    			}
;;;414    			else
;;;415    				continue;
;;;416            } //if 
;;;417       	}
;;;418        return -1;	//if we reached here then we never found the entry in the table
;;;419    }
00004e  bdf0              POP      {r4-r7,pc}
                  |L12.80|
000050  1c52              ADDS     r2,r2,#1
                  |L12.82|
000052  00d1              LSLS     r1,r2,#3              ;394
000054  5c6b              LDRB     r3,[r5,r1]            ;394
000056  2bff              CMP      r3,#0xff              ;394
000058  d1d6              BNE      |L12.8|
00005a  2000              MOVS     r0,#0                 ;418
00005c  43c0              MVNS     r0,r0                 ;418
00005e  bdf0              POP      {r4-r7,pc}
;;;420    
                          ENDP

                  |L12.96|
                          DCD      ||.data||+0x4

                          AREA ||i._UartCmdParser_GetChecksum||, CODE, READONLY, ALIGN=1

                  _UartCmdParser_GetChecksum PROC
;;;269    */
;;;270    static uint8_t _UartCmdParser_GetChecksum(UARTCMD_BUF_t *cmd )
000000  2200              MOVS     r2,#0
;;;271    {
;;;272        int i;
;;;273        uint8_t u8Checksum = 0;
;;;274        uint8_t* u8Ptr = (uint8_t*)cmd;
;;;275    
;;;276        for (i=1; i < UARTCMD_CHKSUM_OFFSET-1; i++)
000002  2101              MOVS     r1,#1
                  |L13.4|
;;;277            u8Checksum += *(u8Ptr+i);
000004  5c43              LDRB     r3,[r0,r1]
000006  1c49              ADDS     r1,r1,#1
000008  189a              ADDS     r2,r3,r2
00000a  b2d2              UXTB     r2,r2
00000c  2907              CMP      r1,#7                 ;276
00000e  d3f9              BCC      |L13.4|
;;;278    
;;;279        //return (0-ucChecksum);
;;;280        return (uint8_t) (0-u8Checksum);
000010  4250              RSBS     r0,r2,#0
000012  b2c0              UXTB     r0,r0
;;;281    }
000014  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i._UartCmdParser_SendFeedback||, CODE, READONLY, ALIGN=2

                  _UartCmdParser_SendFeedback PROC
;;;306    
;;;307    static void _UartCmdParser_SendFeedback(UARTCMD_RESULT_t result,UARTCMD_BUF_t *cmd)
000000  b53e              PUSH     {r1-r5,lr}
;;;308    {
;;;309    	uint8_t i = 0;
000002  2400              MOVS     r4,#0
;;;310    	UARTCMD_BUF_t rcmd;
;;;311    	(void) cmd;
;;;312    	
;;;313    	switch( result )
000004  2800              CMP      r0,#0
000006  d00b              BEQ      |L14.32|
000008  2801              CMP      r0,#1
00000a  d00b              BEQ      |L14.36|
00000c  2802              CMP      r0,#2
00000e  d02a              BEQ      |L14.102|
000010  2804              CMP      r0,#4
000012  d02e              BEQ      |L14.114|
;;;314    	{
;;;315    		case RESULT_ACK_OK:
;;;316    			//buffer will depend on each function return value
;;;317    			rcmd.function = UARTCMD_ACK;
;;;318    			break;
;;;319    
;;;320    		case RESULT_ACK_NOT_SUPPORTED:
;;;321    			_UartCmdParser_CmdFormat(strlen(UARTCMD_IND_NOT_SUPPORT),UARTCMD_IND_NOT_SUPPORT);//use NSUP to verify whats happen			
;;;322    			rcmd.function = UARTCMD_NOT_SUPPORT;						
;;;323    			break;
;;;324    			
;;;325    		case RESULT_ACK_ERROR_CHECKSUM:
;;;326    			_UartCmdParser_CmdFormat(strlen(UARTCMD_IND_ERROR_CHECKSUM),UARTCMD_IND_ERROR_CHECKSUM);//use ESUM to verify whats happen		
;;;327    			rcmd.function = UARTCMD_ERROR_CHECKSUM;
;;;328    			break;
;;;329    
;;;330    		case RESULT_ACK_BAD_FORMAT:
;;;331    			_UartCmdParser_CmdFormat(strlen(UARTCMD_IND_BAD_FORMAT),UARTCMD_IND_BAD_FORMAT);//use BADF to verify whats happen		
;;;332    			rcmd.function = UARTCMD_BAD_FORMAT;
;;;333    			break;
;;;334    			
;;;335    		default:
;;;336    			_UartCmdParser_CmdFormat(strlen(UARTCMD_IND_NACK),UARTCMD_IND_NACK);//use NACK to verify whats happen
000014  a11a              ADR      r1,|L14.128|
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       _UartCmdParser_CmdFormat
;;;337    			rcmd.function = UARTCMD_NACK;
00001c  20b3              MOVS     r0,#0xb3
;;;338    			break;
00001e  e006              B        |L14.46|
                  |L14.32|
000020  20b0              MOVS     r0,#0xb0              ;317
000022  e004              B        |L14.46|
                  |L14.36|
000024  a118              ADR      r1,|L14.136|
000026  2004              MOVS     r0,#4                 ;321
000028  f7fffffe          BL       _UartCmdParser_CmdFormat
00002c  20b1              MOVS     r0,#0xb1              ;322
                  |L14.46|
00002e  4669              MOV      r1,sp                 ;317
000030  7048              STRB     r0,[r1,#1]            ;317
;;;339    	}
;;;340    	
;;;341    	rcmd.header = UARTCMD_HEADER;
000032  2034              MOVS     r0,#0x34
000034  466a              MOV      r2,sp
;;;342    
;;;343    	//manual clear data
;;;344    	rcmd.datalength = UartCommand.datalength; 
000036  4916              LDR      r1,|L14.144|
000038  7010              STRB     r0,[r2,#0]            ;341
00003a  7888              LDRB     r0,[r1,#2]  ; UartCommand
00003c  7090              STRB     r0,[r2,#2]
00003e  4668              MOV      r0,sp                 ;310
                  |L14.64|
;;;345    	for (i=0;i<UARTCMD_DATA_LEN;i++)
;;;346    	{
;;;347    		rcmd.transferdata[i]= UartCommand.transferdata[i]; 
000040  190a              ADDS     r2,r1,r4
000042  1903              ADDS     r3,r0,r4
000044  1c64              ADDS     r4,r4,#1
000046  78d2              LDRB     r2,[r2,#3]
000048  b2e4              UXTB     r4,r4                 ;345
00004a  70da              STRB     r2,[r3,#3]
00004c  2c04              CMP      r4,#4                 ;345
00004e  d3f7              BCC      |L14.64|
;;;348    	}
;;;349    	
;;;350    	rcmd.checksum = _UartCmdParser_GetChecksum(&rcmd);
000050  f7fffffe          BL       _UartCmdParser_GetChecksum
000054  4669              MOV      r1,sp
000056  71c8              STRB     r0,[r1,#7]
;;;351    	rcmd.tailer = UARTCMD_TAILER;
000058  2081              MOVS     r0,#0x81
00005a  7208              STRB     r0,[r1,#8]
;;;352    
;;;353    	UartCmd_Send((uint8_t*)&rcmd,UARTCMD_LENGTH);
00005c  2109              MOVS     r1,#9
00005e  4668              MOV      r0,sp
000060  f7fffffe          BL       UartCmd_Send
;;;354    
;;;355    }
000064  bd3e              POP      {r1-r5,pc}
                  |L14.102|
000066  a10b              ADR      r1,|L14.148|
000068  2004              MOVS     r0,#4                 ;326
00006a  f7fffffe          BL       _UartCmdParser_CmdFormat
00006e  20b2              MOVS     r0,#0xb2              ;327
000070  e7dd              B        |L14.46|
                  |L14.114|
000072  a10a              ADR      r1,|L14.156|
000074  2004              MOVS     r0,#4                 ;331
000076  f7fffffe          BL       _UartCmdParser_CmdFormat
00007a  20b4              MOVS     r0,#0xb4              ;332
00007c  e7d7              B        |L14.46|
;;;356    
                          ENDP

00007e  0000              DCW      0x0000
                  |L14.128|
000080  4e41434b          DCB      "NACK",0
000084  00      
000085  00                DCB      0
000086  00                DCB      0
000087  00                DCB      0
                  |L14.136|
000088  4e535054          DCB      "NSPT",0
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L14.144|
                          DCD      ||.bss||+0x9
                  |L14.148|
000094  45434b4d          DCB      "ECKM",0
000098  00      
000099  00                DCB      0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L14.156|
00009c  42464d54          DCB      "BFMT",0
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i._UartCmdParser_Set_cmd||, CODE, READONLY, ALIGN=2

                  _UartCmdParser_Set_cmd PROC
;;;358    // TODO: Step #4 , add function code to set command
;;;359    static void _UartCmdParser_Set_cmd(UARTCMD_BUF_t *cmd)
000000  b5f8              PUSH     {r3-r7,lr}
;;;360    {
;;;361    	UARTCMD_RESULT_t result = RESULT_ACK_OK ;
000002  2200              MOVS     r2,#0
000004  4b1c              LDR      r3,|L15.120|
000006  4604              MOV      r4,r0                 ;360
000008  9200              STR      r2,[sp,#0]            ;360
00000a  4610              MOV      r0,r2                 ;360
00000c  709a              STRB     r2,[r3,#2]            ;360
00000e  4669              MOV      r1,sp                 ;360
                  |L15.16|
000010  5c0d              LDRB     r5,[r1,r0]            ;360
000012  181e              ADDS     r6,r3,r0              ;360
000014  1c40              ADDS     r0,r0,#1              ;360
000016  b280              UXTH     r0,r0                 ;360
000018  70f5              STRB     r5,[r6,#3]            ;360
00001a  2804              CMP      r0,#4                 ;360
00001c  d3f8              BCC      |L15.16|
;;;362    
;;;363    	_UartCmdParser_ClearDataBuffer();
;;;364    
;;;365    	switch(cmd->function)
00001e  7860              LDRB     r0,[r4,#1]
000020  280d              CMP      r0,#0xd
000022  d018              BEQ      |L15.86|
000024  dc06              BGT      |L15.52|
000026  280a              CMP      r0,#0xa
000028  d009              BEQ      |L15.62|
00002a  280b              CMP      r0,#0xb
00002c  d00b              BEQ      |L15.70|
00002e  280c              CMP      r0,#0xc
000030  d11d              BNE      |L15.110|
000032  e00c              B        |L15.78|
                  |L15.52|
000034  283e              CMP      r0,#0x3e
000036  d012              BEQ      |L15.94|
000038  283f              CMP      r0,#0x3f
00003a  d118              BNE      |L15.110|
00003c  e013              B        |L15.102|
                  |L15.62|
;;;366    	{
;;;367    		case UARTCMD_FUNCTION01_SET:
;;;368    			result = CustomUartCmdHandler_Function01_Set(cmd);
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       CustomUartCmdHandler_Function01_Set
;;;369    			break;
000044  e012              B        |L15.108|
                  |L15.70|
;;;370    		case UARTCMD_FUNCTION02_GET:
;;;371    			result = CustomUartCmdHandler_Function02_Get(cmd);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       CustomUartCmdHandler_Function02_Get
;;;372    			break;			
00004c  e00e              B        |L15.108|
                  |L15.78|
;;;373    		case UARTCMD_FUNCTION03_GET:
;;;374    			result = CustomUartCmdHandler_Function03_Get(cmd);
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       CustomUartCmdHandler_Function03_Get
;;;375    			break;
000054  e00a              B        |L15.108|
                  |L15.86|
;;;376    		case UARTCMD_FUNCTION04_GET:
;;;377    			result = CustomUartCmdHandler_Function04_Get(cmd);
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       CustomUartCmdHandler_Function04_Get
;;;378    			break;
00005c  e006              B        |L15.108|
                  |L15.94|
;;;379    		case UARTCMD_FUNCTION05_SET:
;;;380    			result = CustomUartCmdHandler_Function05_Set(cmd);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       CustomUartCmdHandler_Function05_Set
;;;381    			break;
000064  e002              B        |L15.108|
                  |L15.102|
;;;382    		case UARTCMD_FUNCTION06_GET:
;;;383    			result = CustomUartCmdHandler_Function06_Get(cmd);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       CustomUartCmdHandler_Function06_Get
                  |L15.108|
00006c  4602              MOV      r2,r0
                  |L15.110|
;;;384    			break;			
;;;385    	}		
;;;386    
;;;387    	_UartCmdParser_SendFeedback(result ,cmd);	
00006e  4621              MOV      r1,r4
000070  4610              MOV      r0,r2
000072  f7fffffe          BL       _UartCmdParser_SendFeedback
;;;388    }
000076  bdf8              POP      {r3-r7,pc}
;;;389    
                          ENDP

                  |L15.120|
                          DCD      ||.bss||+0x9

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  aui1_cmd_buf
                          %        9
                  UartCommand
                          %        9

                          AREA ||.data||, DATA, ALIGN=2

                  u8UartRxCnt
000000  00                DCB      0x00
                  u8SetProcessPkt
000001  000000            DCB      0x00,0x00,0x00
                  _UartCmdParser_Array
000004  0a04fd00          DCB      0x0a,0x04,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function01_Set
00000c  0b01fd00          DCB      0x0b,0x01,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function02_Get
000014  0c02fd00          DCB      0x0c,0x02,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function03_Get
00001c  0d04fd00          DCB      0x0d,0x04,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function04_Get
000024  3e03fd00          DCB      0x3e,0x03,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function05_Set
00002c  3f03fd00          DCB      0x3f,0x03,0xfd,0x00
                          DCD      CustomUartCmdHandler_Function06_Get
000034  4000fd00          DCB      0x40,0x00,0xfd,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\UART_Command.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_UART_Command_c_62847315____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___14_UART_Command_c_62847315____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_UART_Command_c_62847315____REVSH|
#line 402
|__asm___14_UART_Command_c_62847315____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
