; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\uart.crf ..\..\..\Library\StdDriver\src\uart.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;357      */
;;;358    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;359    {
;;;360        uint32_t u32PllFreq;
;;;361        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;362        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;363        uint32_t u32Reg;
;;;364    
;;;365        u32PllFreq = 0;
;;;366        u32Reg = CLK->PLLCTL;
000006  4911              LDR      r1,|L1.76|
000008  9000              STR      r0,[sp,#0]            ;365
00000a  6809              LDR      r1,[r1,#0]
00000c  2000              MOVS     r0,#0                 ;365
;;;367    
;;;368        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
00000e  2205              MOVS     r2,#5
000010  0412              LSLS     r2,r2,#16
000012  4211              TST      r1,r2
000014  d116              BNE      |L1.68|
;;;369        {
;;;370            /* PLL is enabled and output enabled */
;;;371            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
000016  0308              LSLS     r0,r1,#12
000018  d501              BPL      |L1.30|
;;;372            {
;;;373                u32FIN = (__HIRC >> 2);
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
;;;374            } else
;;;375                u32FIN = __HXT;
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
;;;376    
;;;377            if (u32Reg & CLK_PLLCTL_BP_Msk)
000020  038a              LSLS     r2,r1,#14
000022  d40f              BMI      |L1.68|
;;;378            {
;;;379                /* PLL is in bypass mode */
;;;380                u32PllFreq = u32FIN;
;;;381            }
;;;382            else
;;;383            {
;;;384                /* PLL is in normal work mode */
;;;385                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000024  040a              LSLS     r2,r1,#16
000026  0f92              LSRS     r2,r2,#30
000028  466b              MOV      r3,sp
00002a  5c9b              LDRB     r3,[r3,r2]
;;;386                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
00002c  05ca              LSLS     r2,r1,#23
;;;387                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00002e  0489              LSLS     r1,r1,#18
000030  0dd2              LSRS     r2,r2,#23             ;386
000032  0ec9              LSRS     r1,r1,#27
000034  1c89              ADDS     r1,r1,#2
;;;388                /* u32FIN is shifted 2 bits to avoid overflow */
;;;389                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000036  0880              LSRS     r0,r0,#2
000038  1c92              ADDS     r2,r2,#2
00003a  4359              MULS     r1,r3,r1
00003c  4350              MULS     r0,r2,r0
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2
                  |L1.68|
;;;390            }
;;;391        }
;;;392    
;;;393        return u32PllFreq;
;;;394    }
000044  bd08              POP      {r3,pc}
;;;395    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x40000240
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x01e84800

                          AREA ||i.UART_ClearIntFlag||, CODE, READONLY, ALIGN=2

                  UART_ClearIntFlag PROC
;;;39     
;;;40     void UART_ClearIntFlag(UART_T *uart , uint32_t u32InterruptFlag)
000000  01ca              LSLS     r2,r1,#7
;;;41     {
000002  d502              BPL      |L2.10|
;;;42     
;;;43     
;;;44         if (u32InterruptFlag & UART_INTSTS_SWBEINT_Msk)   /* Clear Bit Error Detection Interrupt */
;;;45         {
;;;46             uart->INTSTS = UART_INTSTS_SWBEIF_Msk;
000004  2201              MOVS     r2,#1
000006  0412              LSLS     r2,r2,#16
000008  61c2              STR      r2,[r0,#0x1c]
                  |L2.10|
;;;47         }
;;;48     
;;;49         if (u32InterruptFlag & UART_INTSTS_RLSINT_Msk)   /* Clear Receive Line Status Interrupt */
00000a  054a              LSLS     r2,r1,#21
00000c  d503              BPL      |L2.22|
;;;50         {
;;;51             uart->FIFOSTS = UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk;
00000e  2270              MOVS     r2,#0x70
000010  6182              STR      r2,[r0,#0x18]
;;;52             uart->FIFOSTS = UART_FIFOSTS_ADDRDETF_Msk;
000012  2208              MOVS     r2,#8
000014  6182              STR      r2,[r0,#0x18]
                  |L2.22|
;;;53         }
;;;54     
;;;55         if (u32InterruptFlag & UART_INTSTS_MODEMINT_Msk)   /* Clear Modem Status Interrupt */
000016  050a              LSLS     r2,r1,#20
000018  d503              BPL      |L2.34|
;;;56         {
;;;57             uart->MODEMSTS |= UART_MODEMSTS_CTSDETF_Msk;
00001a  6942              LDR      r2,[r0,#0x14]
00001c  2301              MOVS     r3,#1
00001e  431a              ORRS     r2,r2,r3
000020  6142              STR      r2,[r0,#0x14]
                  |L2.34|
;;;58         }
;;;59     
;;;60         if (u32InterruptFlag & UART_INTSTS_BUFERRINT_Msk)   /* Clear Buffer Error Interrupt */
000022  048a              LSLS     r2,r1,#18
000024  d501              BPL      |L2.42|
;;;61         {
;;;62             uart->FIFOSTS = UART_FIFOSTS_RXOVIF_Msk | UART_FIFOSTS_TXOVIF_Msk;
000026  4a03              LDR      r2,|L2.52|
000028  6182              STR      r2,[r0,#0x18]
                  |L2.42|
;;;63         }
;;;64     
;;;65         if (u32InterruptFlag & UART_INTSTS_WKINT_Msk)   /* Clear Wake-up Interrupt */
00002a  0449              LSLS     r1,r1,#17
00002c  d501              BPL      |L2.50|
;;;66         {
;;;67             uart->WKSTS = UART_WKSTS_CTSWKF_Msk  | UART_WKSTS_DATWKF_Msk  |
00002e  211f              MOVS     r1,#0x1f
000030  6441              STR      r1,[r0,#0x44]
                  |L2.50|
;;;68                           UART_WKSTS_RFRTWKF_Msk | UART_WKSTS_RS485WKF_Msk |
;;;69                           UART_WKSTS_TOUTWKF_Msk;
;;;70         }
;;;71     
;;;72     }
000032  4770              BX       lr
;;;73     
                          ENDP

                  |L2.52|
                          DCD      0x01000001

                          AREA ||i.UART_Close||, CODE, READONLY, ALIGN=1

                  UART_Close PROC
;;;83      */
;;;84     void UART_Close(UART_T *uart)
000000  2100              MOVS     r1,#0
;;;85     {
;;;86         uart->INTEN = 0ul;
000002  6041              STR      r1,[r0,#4]
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.UART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_DisableFlowCtrl PROC
;;;98      */
;;;99     void UART_DisableFlowCtrl(UART_T *uart)
000000  6841              LDR      r1,[r0,#4]
;;;100    {
;;;101        uart->INTEN &= ~(UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk);
000002  2203              MOVS     r2,#3
000004  0312              LSLS     r2,r2,#12
000006  4391              BICS     r1,r1,r2
000008  6041              STR      r1,[r0,#4]
;;;102    }
00000a  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.UART_DisableInt||, CODE, READONLY, ALIGN=2

                  UART_DisableInt PROC
;;;122     */
;;;123    void UART_DisableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;124    {
;;;125        /* Disable UART specified interrupt */
;;;126        UART_DISABLE_INT(uart, u32InterruptFlag);
000002  438a              BICS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;127    
;;;128        /* Disable NVIC UART IRQ */
;;;129        if(uart == UART0)
000006  4b07              LDR      r3,|L5.36|
000008  2201              MOVS     r2,#1
00000a  0312              LSLS     r2,r2,#12
00000c  4906              LDR      r1,|L5.40|
00000e  4298              CMP      r0,r3
000010  d101              BNE      |L5.22|
                  |L5.18|
000012  600a              STR      r2,[r1,#0]            ;124
;;;130            NVIC_DisableIRQ(UART02_IRQn);
;;;131        else if(uart == UART1)
;;;132            NVIC_DisableIRQ(UART1_IRQn);
;;;133        else
;;;134            NVIC_DisableIRQ(UART02_IRQn);
;;;135    }
000014  4770              BX       lr
                  |L5.22|
000016  4b05              LDR      r3,|L5.44|
000018  4298              CMP      r0,r3                 ;131
00001a  d1fa              BNE      |L5.18|
00001c  2001              MOVS     r0,#1                 ;131
00001e  0340              LSLS     r0,r0,#13             ;131
000020  6008              STR      r0,[r1,#0]            ;131
000022  4770              BX       lr
;;;136    
                          ENDP

                  |L5.36|
                          DCD      0x40070000
                  |L5.40|
                          DCD      0xe000e180
                  |L5.44|
                          DCD      0x40071000

                          AREA ||i.UART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UART_EnableFlowCtrl PROC
;;;146     */
;;;147    void UART_EnableFlowCtrl(UART_T *uart)
000000  6901              LDR      r1,[r0,#0x10]
;;;148    {
;;;149        /* Set RTS pin output is low level active */
;;;150        uart->MODEM |= UART_MODEM_RTSACTLV_Msk;
000002  2201              MOVS     r2,#1
000004  0252              LSLS     r2,r2,#9
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;151    
;;;152        /* Set CTS pin input is low level active */
;;;153        uart->MODEMSTS |= UART_MODEMSTS_CTSACTLV_Msk;
00000a  6941              LDR      r1,[r0,#0x14]
00000c  1052              ASRS     r2,r2,#1
00000e  4311              ORRS     r1,r1,r2
000010  6141              STR      r1,[r0,#0x14]
;;;154    
;;;155        /* Set RTS and CTS auto flow control enable */
;;;156        uart->INTEN |= UART_INTEN_ATORTSEN_Msk | UART_INTEN_ATOCTSEN_Msk;
000012  6841              LDR      r1,[r0,#4]
000014  2203              MOVS     r2,#3
000016  0312              LSLS     r2,r2,#12
000018  4311              ORRS     r1,r1,r2
00001a  6041              STR      r1,[r0,#4]
;;;157    }
00001c  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.UART_EnableInt||, CODE, READONLY, ALIGN=2

                  UART_EnableInt PROC
;;;177     */
;;;178    void UART_EnableInt(UART_T  *uart, uint32_t u32InterruptFlag)
000000  6842              LDR      r2,[r0,#4]
;;;179    {
;;;180        /* Enable UART specified interrupt */
;;;181        UART_ENABLE_INT(uart, u32InterruptFlag);
000002  430a              ORRS     r2,r2,r1
000004  6042              STR      r2,[r0,#4]
;;;182    
;;;183        /* Enable NVIC UART IRQ */
;;;184        if(uart == UART0)
000006  4b07              LDR      r3,|L7.36|
000008  2201              MOVS     r2,#1
00000a  0312              LSLS     r2,r2,#12
00000c  4906              LDR      r1,|L7.40|
00000e  4298              CMP      r0,r3
000010  d101              BNE      |L7.22|
                  |L7.18|
000012  600a              STR      r2,[r1,#0]            ;179
;;;185            NVIC_EnableIRQ(UART02_IRQn);
;;;186        else if(uart == UART1)
;;;187            NVIC_EnableIRQ(UART1_IRQn);
;;;188        else
;;;189            NVIC_EnableIRQ(UART02_IRQn);
;;;190    }
000014  4770              BX       lr
                  |L7.22|
000016  4b05              LDR      r3,|L7.44|
000018  4298              CMP      r0,r3                 ;186
00001a  d1fa              BNE      |L7.18|
00001c  2001              MOVS     r0,#1                 ;186
00001e  0340              LSLS     r0,r0,#13             ;186
000020  6008              STR      r0,[r1,#0]            ;186
000022  4770              BX       lr
;;;191    
                          ENDP

                  |L7.36|
                          DCD      0x40070000
                  |L7.40|
                          DCD      0xe000e100
                  |L7.44|
                          DCD      0x40071000

                          AREA ||i.UART_Open||, CODE, READONLY, ALIGN=2

                  UART_Open PROC
;;;202     */
;;;203    void UART_Open(UART_T *uart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;204    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;205        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;206        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  492e              LDR      r1,|L8.200|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;207        uint32_t u32Baud_Div = 0ul;
;;;208    
;;;209    
;;;210        if (uart == (UART_T *)UART0)
000016  492d              LDR      r1,|L8.204|
;;;211        {
;;;212            /* Get UART clock source selection */
;;;213            u32UartClkSrcSel = ((uint32_t)(CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk)) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  482d              LDR      r0,|L8.208|
;;;214            /* Get UART clock divider number */
;;;215            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;216        }
;;;217        else if (uart == (UART_T *)UART1)
;;;218        {
;;;219            /* Get UART clock source selection */
;;;220            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;221            /* Get UART clock divider number */
;;;222            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;223        }
;;;224        else if (uart == (UART_T *)UART2)
00001a  4a2e              LDR      r2,|L8.212|
00001c  428c              CMP      r4,r1                 ;210
00001e  d105              BNE      |L8.44|
000020  6943              LDR      r3,[r0,#0x14]         ;213
000022  6a00              LDR      r0,[r0,#0x20]         ;215
;;;225        {
;;;226            /* Get UART clock source selection */
;;;227            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;228            /* Get UART clock divider number */
;;;229            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;230        }
;;;231    
;;;232        /* Select UART function */
;;;233        uart->FUNCSEL = UART_FUNCSEL_UART;
;;;234    
;;;235        /* Set UART line configuration */
;;;236        uart->LINE = UART_WORD_LEN_8 | UART_PARITY_NONE | UART_STOP_BIT_1;
;;;237    
;;;238        /* Set UART Rx and RTS trigger level */
;;;239        uart->FIFO &= ~(UART_FIFO_RFITL_Msk | UART_FIFO_RTSTRGLV_Msk);
;;;240    
;;;241        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;242        if (u32UartClkSrcSel == 1ul)
;;;243        {
;;;244            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;245        }
;;;246    
;;;247        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;248        if (u32UartClkSrcSel == 4ul)
;;;249        {
;;;250            /* UART Port as UART0 or UART1 */
;;;251            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;252            {
;;;253                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;254            }
;;;255            else     /* UART Port as UART1*/
;;;256            {
;;;257                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;258            }
;;;259    
;;;260        }
;;;261    
;;;262        /* Set UART baud rate */
;;;263        if (u32baudrate != 0ul)
;;;264        {
;;;265            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;266    
;;;267            if (u32Baud_Div > 0xFFFFul)
;;;268            {
;;;269                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;270            }
;;;271            else
;;;272            {
;;;273                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;274            }
;;;275        }
;;;276    }
000024  015b              LSLS     r3,r3,#5
000026  0f5d              LSRS     r5,r3,#29
000028  0a00              LSRS     r0,r0,#8
00002a  e00f              B        |L8.76|
                  |L8.44|
00002c  4b2a              LDR      r3,|L8.216|
00002e  429c              CMP      r4,r3                 ;217
000030  d106              BNE      |L8.64|
000032  6943              LDR      r3,[r0,#0x14]         ;220
000034  6a00              LDR      r0,[r0,#0x20]         ;222
000036  005b              LSLS     r3,r3,#1
000038  0f5d              LSRS     r5,r3,#29
00003a  0400              LSLS     r0,r0,#16             ;222
00003c  0f06              LSRS     r6,r0,#28             ;222
00003e  e007              B        |L8.80|
                  |L8.64|
000040  4294              CMP      r4,r2                 ;224
000042  d105              BNE      |L8.80|
000044  69c3              LDR      r3,[r0,#0x1c]         ;227
000046  6b00              LDR      r0,[r0,#0x30]         ;229
000048  015b              LSLS     r3,r3,#5
00004a  0f5d              LSRS     r5,r3,#29
                  |L8.76|
00004c  0706              LSLS     r6,r0,#28             ;229
00004e  0f36              LSRS     r6,r6,#28             ;229
                  |L8.80|
000050  2000              MOVS     r0,#0                 ;233
000052  6320              STR      r0,[r4,#0x30]         ;233
000054  2003              MOVS     r0,#3                 ;236
000056  60e0              STR      r0,[r4,#0xc]          ;236
000058  68a0              LDR      r0,[r4,#8]            ;239
00005a  4b20              LDR      r3,|L8.220|
00005c  4018              ANDS     r0,r0,r3              ;239
00005e  60a0              STR      r0,[r4,#8]            ;239
000060  2d01              CMP      r5,#1                 ;242
000062  d002              BEQ      |L8.106|
000064  2d04              CMP      r5,#4                 ;248
000066  d004              BEQ      |L8.114|
000068  e00d              B        |L8.134|
                  |L8.106|
00006a  f7fffffe          BL       CLK_GetPLLClockFreq
00006e  9001              STR      r0,[sp,#4]            ;244
000070  e009              B        |L8.134|
                  |L8.114|
000072  428c              CMP      r4,r1                 ;251
000074  d001              BEQ      |L8.122|
000076  4294              CMP      r4,r2                 ;251
000078  d102              BNE      |L8.128|
                  |L8.122|
00007a  f7fffffe          BL       CLK_GetPCLK0Freq
00007e  e001              B        |L8.132|
                  |L8.128|
000080  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L8.132|
000084  9004              STR      r0,[sp,#0x10]         ;253
                  |L8.134|
000086  2f00              CMP      r7,#0                 ;263
000088  d01b              BEQ      |L8.194|
00008a  00a9              LSLS     r1,r5,#2              ;265
00008c  4668              MOV      r0,sp                 ;265
00008e  5840              LDR      r0,[r0,r1]            ;265
000090  1c71              ADDS     r1,r6,#1              ;265
000092  f7fffffe          BL       __aeabi_uidivmod
000096  4605              MOV      r5,r0                 ;265
000098  0879              LSRS     r1,r7,#1              ;265
00009a  1840              ADDS     r0,r0,r1              ;265
00009c  4639              MOV      r1,r7                 ;265
00009e  f7fffffe          BL       __aeabi_uidivmod
0000a2  490f              LDR      r1,|L8.224|
0000a4  1e80              SUBS     r0,r0,#2              ;267
0000a6  4288              CMP      r0,r1                 ;267
0000a8  d907              BLS      |L8.186|
0000aa  00f9              LSLS     r1,r7,#3              ;269
0000ac  1868              ADDS     r0,r5,r1              ;269
0000ae  4639              MOV      r1,r7                 ;269
0000b0  f7fffffe          BL       __aeabi_uidivmod
0000b4  0900              LSRS     r0,r0,#4              ;269
0000b6  1e80              SUBS     r0,r0,#2              ;269
0000b8  e002              B        |L8.192|
                  |L8.186|
0000ba  2103              MOVS     r1,#3                 ;273
0000bc  0709              LSLS     r1,r1,#28             ;273
0000be  4308              ORRS     r0,r0,r1              ;273
                  |L8.192|
0000c0  6260              STR      r0,[r4,#0x24]         ;273
                  |L8.194|
0000c2  b007              ADD      sp,sp,#0x1c
0000c4  bdf0              POP      {r4-r7,pc}
;;;277    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L8.200|
                          DCD      ||.constdata||
                  |L8.204|
                          DCD      0x40070000
                  |L8.208|
                          DCD      0x40000200
                  |L8.212|
                          DCD      0x40072000
                  |L8.216|
                          DCD      0x40071000
                  |L8.220|
                          DCD      0xfff0ff0f
                  |L8.224|
                          DCD      0x0000ffff

                          AREA ||i.UART_Read||, CODE, READONLY, ALIGN=1

                  UART_Read PROC
;;;289     */
;;;290    uint32_t UART_Read(UART_T *uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;291    {
;;;292        uint32_t  u32Count, u32delayno;
;;;293        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;291
;;;294    
;;;295        for (u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
;;;296        {
;;;297            u32delayno = 0ul;
;;;298    
;;;299            while (uart->FIFOSTS & UART_FIFOSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;300            {
;;;301                u32delayno++;
;;;302    
;;;303                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;295
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L9.40|
                  |L9.14|
00000e  2300              MOVS     r3,#0                 ;297
000010  e002              B        |L9.24|
                  |L9.18|
000012  1c5b              ADDS     r3,r3,#1              ;299
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L9.44|
                  |L9.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;299
00001a  0464              LSLS     r4,r4,#17             ;299
00001c  d4f9              BMI      |L9.18|
;;;304                {
;;;305                    u32Exit = 1ul;
;;;306                    break;
;;;307                }
;;;308            }
;;;309    
;;;310            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L9.44|
;;;311            {
;;;312                break;
;;;313            }
;;;314            else
;;;315            {
;;;316                pu8RxBuf[u32Count] = (uint8_t)uart->DAT; /* Get Data from UART RX  */
000022  682b              LDR      r3,[r5,#0]
000024  540b              STRB     r3,[r1,r0]
000026  1c40              ADDS     r0,r0,#1
                  |L9.40|
000028  4290              CMP      r0,r2                 ;295
00002a  d3f0              BCC      |L9.14|
                  |L9.44|
;;;317            }
;;;318        }
;;;319    
;;;320        return u32Count;
;;;321    
;;;322    }
00002c  bdf0              POP      {r4-r7,pc}
;;;323    
                          ENDP


                          AREA ||i.UART_SelectIrDAMode||, CODE, READONLY, ALIGN=2

                  UART_SelectIrDAMode PROC
;;;452     */
;;;453    void UART_SelectIrDAMode(UART_T *uart, uint32_t u32Buadrate, uint32_t u32Direction)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;454    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
;;;455        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000006  2500              MOVS     r5,#0
000008  462e              MOV      r6,r5
;;;456        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0ul, __LIRC};
00000a  2218              MOVS     r2,#0x18
00000c  492e              LDR      r1,|L10.200|
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       __aeabi_memcpy4
;;;457        uint32_t u32Baud_Div;
;;;458    
;;;459        /* Select IrDA function mode */
;;;460        uart->FUNCSEL = UART_FUNCSEL_IrDA;
000014  2702              MOVS     r7,#2
000016  6327              STR      r7,[r4,#0x30]
;;;461    
;;;462    
;;;463        if (uart == UART0)
000018  492c              LDR      r1,|L10.204|
;;;464        {
;;;465            /* Get UART clock source selection */
;;;466            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
00001a  482d              LDR      r0,|L10.208|
;;;467            /* Get UART clock divider number */
;;;468            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;469        }
;;;470        else if (uart == UART1)
;;;471        {
;;;472            /* Get UART clock source selection */
;;;473            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;474            /* Get UART clock divider number */
;;;475            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;476        }
;;;477        else if (uart == UART2)
00001c  4a2d              LDR      r2,|L10.212|
00001e  428c              CMP      r4,r1                 ;463
000020  d105              BNE      |L10.46|
000022  6943              LDR      r3,[r0,#0x14]         ;466
000024  6a00              LDR      r0,[r0,#0x20]         ;468
;;;478        {
;;;479            /* Get UART clock source selection */
;;;480            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;481            /* Get UART clock divider number */
;;;482            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;483        }
;;;484    
;;;485    
;;;486        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;487        if (u32UartClkSrcSel == 1ul)
;;;488        {
;;;489            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;490        }
;;;491    
;;;492        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;493        if (u32UartClkSrcSel == 4ul)
;;;494        {
;;;495            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;496            {
;;;497                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;498            }
;;;499            else     /* UART Port as UART1*/
;;;500            {
;;;501                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;502            }
;;;503        }
;;;504    
;;;505    
;;;506        /* Set UART IrDA baud rate in mode 0 */
;;;507        if (u32Buadrate != 0ul)
;;;508        {
;;;509            u32Baud_Div = UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32Buadrate);
;;;510    
;;;511            if (u32Baud_Div < 0xFFFFul)
;;;512            {
;;;513                uart->BAUD = (UART_BAUD_MODE0 | u32Baud_Div);
;;;514            }
;;;515            else
;;;516            {
;;;517            }
;;;518        }
;;;519    
;;;520        /* Configure IrDA relative settings */
;;;521        if (u32Direction == UART_IRDA_RXEN)
;;;522        {
;;;523            uart->IRDA |= UART_IRDA_RXINV_Msk;     /*Rx signal is inverse*/
;;;524            uart->IRDA &= ~UART_IRDA_TXEN_Msk;
;;;525        }
;;;526        else
;;;527        {
;;;528            uart->IRDA &= ~UART_IRDA_TXINV_Msk;    /*Tx signal is not inverse*/
;;;529            uart->IRDA |= UART_IRDA_TXEN_Msk;
;;;530        }
;;;531    
;;;532    }
000026  015b              LSLS     r3,r3,#5
000028  0f5d              LSRS     r5,r3,#29
00002a  0a00              LSRS     r0,r0,#8
00002c  e00f              B        |L10.78|
                  |L10.46|
00002e  4b2a              LDR      r3,|L10.216|
000030  429c              CMP      r4,r3                 ;470
000032  d106              BNE      |L10.66|
000034  6943              LDR      r3,[r0,#0x14]         ;473
000036  6a00              LDR      r0,[r0,#0x20]         ;475
000038  005b              LSLS     r3,r3,#1
00003a  0f5d              LSRS     r5,r3,#29
00003c  0400              LSLS     r0,r0,#16             ;475
00003e  0f06              LSRS     r6,r0,#28             ;475
000040  e007              B        |L10.82|
                  |L10.66|
000042  4294              CMP      r4,r2                 ;477
000044  d118              BNE      |L10.120|
000046  69c3              LDR      r3,[r0,#0x1c]         ;480
000048  6b00              LDR      r0,[r0,#0x30]         ;482
00004a  015b              LSLS     r3,r3,#5
00004c  0f5d              LSRS     r5,r3,#29
                  |L10.78|
00004e  0706              LSLS     r6,r0,#28             ;482
000050  0f36              LSRS     r6,r6,#28             ;482
                  |L10.82|
000052  2d01              CMP      r5,#1                 ;487
000054  d002              BEQ      |L10.92|
000056  2d04              CMP      r5,#4                 ;493
000058  d004              BEQ      |L10.100|
00005a  e00d              B        |L10.120|
                  |L10.92|
00005c  f7fffffe          BL       CLK_GetPLLClockFreq
000060  9001              STR      r0,[sp,#4]            ;489
000062  e009              B        |L10.120|
                  |L10.100|
000064  428c              CMP      r4,r1                 ;495
000066  d001              BEQ      |L10.108|
000068  4294              CMP      r4,r2                 ;495
00006a  d102              BNE      |L10.114|
                  |L10.108|
00006c  f7fffffe          BL       CLK_GetPCLK0Freq
000070  e001              B        |L10.118|
                  |L10.114|
000072  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.118|
000076  9004              STR      r0,[sp,#0x10]         ;497
                  |L10.120|
000078  9807              LDR      r0,[sp,#0x1c]         ;507
00007a  2800              CMP      r0,#0                 ;507
00007c  d011              BEQ      |L10.162|
00007e  00a9              LSLS     r1,r5,#2              ;509
000080  4668              MOV      r0,sp                 ;509
000082  5840              LDR      r0,[r0,r1]            ;509
000084  1c71              ADDS     r1,r6,#1              ;509
000086  f7fffffe          BL       __aeabi_uidivmod
00008a  9907              LDR      r1,[sp,#0x1c]         ;509
00008c  00c9              LSLS     r1,r1,#3              ;509
00008e  1840              ADDS     r0,r0,r1              ;509
000090  9907              LDR      r1,[sp,#0x1c]         ;509
000092  f7fffffe          BL       __aeabi_uidivmod
000096  0900              LSRS     r0,r0,#4              ;509
000098  4910              LDR      r1,|L10.220|
00009a  1e80              SUBS     r0,r0,#2              ;511
00009c  4288              CMP      r0,r1                 ;511
00009e  d200              BCS      |L10.162|
0000a0  6260              STR      r0,[r4,#0x24]         ;513
                  |L10.162|
0000a2  9808              LDR      r0,[sp,#0x20]         ;521
0000a4  2800              CMP      r0,#0                 ;521
0000a6  6aa0              LDR      r0,[r4,#0x28]         ;528
0000a8  d007              BEQ      |L10.186|
0000aa  2120              MOVS     r1,#0x20              ;528
0000ac  4388              BICS     r0,r0,r1              ;528
0000ae  62a0              STR      r0,[r4,#0x28]         ;528
0000b0  6aa0              LDR      r0,[r4,#0x28]         ;529
0000b2  4338              ORRS     r0,r0,r7              ;529
                  |L10.180|
0000b4  62a0              STR      r0,[r4,#0x28]         ;524
0000b6  b009              ADD      sp,sp,#0x24
0000b8  bdf0              POP      {r4-r7,pc}
                  |L10.186|
0000ba  2140              MOVS     r1,#0x40              ;523
0000bc  4308              ORRS     r0,r0,r1              ;523
0000be  62a0              STR      r0,[r4,#0x28]         ;523
0000c0  6aa0              LDR      r0,[r4,#0x28]         ;524
0000c2  43b8              BICS     r0,r0,r7              ;524
0000c4  e7f6              B        |L10.180|
;;;533    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L10.200|
                          DCD      ||.constdata||+0x30
                  |L10.204|
                          DCD      0x40070000
                  |L10.208|
                          DCD      0x40000200
                  |L10.212|
                          DCD      0x40072000
                  |L10.216|
                          DCD      0x40071000
                  |L10.220|
                          DCD      0x0000ffff

                          AREA ||i.UART_SelectRS485Mode||, CODE, READONLY, ALIGN=2

                  UART_SelectRS485Mode PROC
;;;548     */
;;;549    void UART_SelectRS485Mode(UART_T *uart, uint32_t u32Mode, uint32_t u32Addr)
000000  b510              PUSH     {r4,lr}
;;;550    {
;;;551        /* Select UART RS485 function mode */
;;;552        uart->FUNCSEL = UART_FUNCSEL_RS485;
000002  2303              MOVS     r3,#3
000004  6303              STR      r3,[r0,#0x30]
;;;553    
;;;554        /* Set RS585 configuration */
;;;555        uart->ALTCTL &= ~(UART_ALTCTL_RS485NMM_Msk | UART_ALTCTL_RS485AUD_Msk | UART_ALTCTL_RS485AAD_Msk | UART_ALTCTL_ADDRMV_Msk);
000006  6ac3              LDR      r3,[r0,#0x2c]
000008  4c04              LDR      r4,|L11.28|
00000a  4023              ANDS     r3,r3,r4
00000c  62c3              STR      r3,[r0,#0x2c]
;;;556        uart->ALTCTL |= (u32Mode | (u32Addr << UART_ALTCTL_ADDRMV_Pos));
00000e  6ac3              LDR      r3,[r0,#0x2c]
000010  0612              LSLS     r2,r2,#24
000012  430a              ORRS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  62c3              STR      r3,[r0,#0x2c]
;;;557    }
000018  bd10              POP      {r4,pc}
;;;558    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x00fff8ff

                          AREA ||i.UART_SelectSingleWireMode||, CODE, READONLY, ALIGN=1

                  UART_SelectSingleWireMode PROC
;;;612     */
;;;613    void UART_SelectSingleWireMode(UART_T *uart)
000000  6b01              LDR      r1,[r0,#0x30]
;;;614    {
;;;615    
;;;616        /* Select UART SingleWire function mode */
;;;617        uart->FUNCSEL = ((uart->FUNCSEL & (~UART_FUNCSEL_FUNCSEL_Msk)) | UART_FUNCSEL_SINGLE_WIRE);
000002  08c9              LSRS     r1,r1,#3
000004  00c9              LSLS     r1,r1,#3
000006  1d09              ADDS     r1,r1,#4
000008  6301              STR      r1,[r0,#0x30]
;;;618    
;;;619    }
00000a  4770              BX       lr
;;;620    
                          ENDP


                          AREA ||i.UART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UART_SetLine_Config PROC
;;;350     */
;;;351    void UART_SetLine_Config(UART_T *uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;352    {
000002  b087              SUB      sp,sp,#0x1c
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;353        uint32_t u32UartClkSrcSel = 0ul, u32UartClkDivNum = 0ul;
000008  2500              MOVS     r5,#0
00000a  462e              MOV      r6,r5
;;;354        uint32_t u32ClkTbl[6ul] = {__HXT, 0ul, __LXT, __HIRC, 0, __LIRC};
00000c  2218              MOVS     r2,#0x18
00000e  492d              LDR      r1,|L13.196|
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       __aeabi_memcpy4
;;;355        uint32_t u32Baud_Div = 0ul;
;;;356    
;;;357    
;;;358        if (uart == (UART_T *)UART0)
000016  492c              LDR      r1,|L13.200|
;;;359        {
;;;360            /* Get UART clock source selection */
;;;361            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART0SEL_Msk) >> CLK_CLKSEL1_UART0SEL_Pos;
000018  482c              LDR      r0,|L13.204|
;;;362            /* Get UART clock divider number */
;;;363            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART0DIV_Msk) >> CLK_CLKDIV0_UART0DIV_Pos;
;;;364        }
;;;365        else if (uart == (UART_T *)UART1)
;;;366        {
;;;367            /* Get UART clock source selection */
;;;368            u32UartClkSrcSel = (CLK->CLKSEL1 & CLK_CLKSEL1_UART1SEL_Msk) >> CLK_CLKSEL1_UART1SEL_Pos;
;;;369            /* Get UART clock divider number */
;;;370            u32UartClkDivNum = (CLK->CLKDIV0 & CLK_CLKDIV0_UART1DIV_Msk) >> CLK_CLKDIV0_UART1DIV_Pos;
;;;371        }
;;;372        else if (uart == (UART_T *)UART2)
00001a  4a2d              LDR      r2,|L13.208|
00001c  428c              CMP      r4,r1                 ;358
00001e  d105              BNE      |L13.44|
000020  6943              LDR      r3,[r0,#0x14]         ;361
000022  6a00              LDR      r0,[r0,#0x20]         ;363
;;;373        {
;;;374            /* Get UART clock source selection */
;;;375            u32UartClkSrcSel = (CLK->CLKSEL3 & CLK_CLKSEL3_UART2SEL_Msk) >> CLK_CLKSEL3_UART2SEL_Pos;
;;;376            /* Get UART clock divider number */
;;;377            u32UartClkDivNum = (CLK->CLKDIV4 & CLK_CLKDIV4_UART2DIV_Msk) >> CLK_CLKDIV4_UART2DIV_Pos;
;;;378        }
;;;379    
;;;380        /* Get PLL clock frequency if UART clock source selection is PLL */
;;;381        if (u32UartClkSrcSel == 1ul)
;;;382        {
;;;383            u32ClkTbl[u32UartClkSrcSel] = CLK_GetPLLClockFreq();
;;;384        }
;;;385    
;;;386        /* Get PCLK clock frequency if UART clock source selection is PCLK */
;;;387        if (u32UartClkSrcSel == 4ul)
;;;388        {
;;;389            if ((uart == (UART_T *)UART0) || (uart == (UART_T *)UART2))
;;;390            {
;;;391                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK0Freq();
;;;392            }
;;;393            else     /* UART Port as UART1*/
;;;394            {
;;;395                u32ClkTbl[u32UartClkSrcSel] =  CLK_GetPCLK1Freq();
;;;396            }
;;;397        }
;;;398    
;;;399    
;;;400        /* Set UART baud rate */
;;;401        if (u32baudrate != 0ul)
;;;402        {
;;;403            u32Baud_Div = UART_BAUD_MODE2_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate);
;;;404    
;;;405            if (u32Baud_Div > 0xFFFFul)
;;;406            {
;;;407                uart->BAUD = (UART_BAUD_MODE0 | UART_BAUD_MODE0_DIVIDER((u32ClkTbl[u32UartClkSrcSel]) / (u32UartClkDivNum + 1ul), u32baudrate));
;;;408            }
;;;409            else
;;;410            {
;;;411                uart->BAUD = (UART_BAUD_MODE2 | u32Baud_Div);
;;;412            }
;;;413        }
;;;414    
;;;415        /* Set UART line configuration */
;;;416        uart->LINE = u32data_width | u32parity | u32stop_bits;
;;;417    }
000024  015b              LSLS     r3,r3,#5
000026  0f5d              LSRS     r5,r3,#29
000028  0a00              LSRS     r0,r0,#8
00002a  e00f              B        |L13.76|
                  |L13.44|
00002c  4b29              LDR      r3,|L13.212|
00002e  429c              CMP      r4,r3                 ;365
000030  d106              BNE      |L13.64|
000032  6943              LDR      r3,[r0,#0x14]         ;368
000034  6a00              LDR      r0,[r0,#0x20]         ;370
000036  005b              LSLS     r3,r3,#1
000038  0f5d              LSRS     r5,r3,#29
00003a  0400              LSLS     r0,r0,#16             ;370
00003c  0f06              LSRS     r6,r0,#28             ;370
00003e  e007              B        |L13.80|
                  |L13.64|
000040  4294              CMP      r4,r2                 ;372
000042  d118              BNE      |L13.118|
000044  69c3              LDR      r3,[r0,#0x1c]         ;375
000046  6b00              LDR      r0,[r0,#0x30]         ;377
000048  015b              LSLS     r3,r3,#5
00004a  0f5d              LSRS     r5,r3,#29
                  |L13.76|
00004c  0706              LSLS     r6,r0,#28             ;377
00004e  0f36              LSRS     r6,r6,#28             ;377
                  |L13.80|
000050  2d01              CMP      r5,#1                 ;381
000052  d002              BEQ      |L13.90|
000054  2d04              CMP      r5,#4                 ;387
000056  d004              BEQ      |L13.98|
000058  e00d              B        |L13.118|
                  |L13.90|
00005a  f7fffffe          BL       CLK_GetPLLClockFreq
00005e  9001              STR      r0,[sp,#4]            ;383
000060  e009              B        |L13.118|
                  |L13.98|
000062  428c              CMP      r4,r1                 ;389
000064  d001              BEQ      |L13.106|
000066  4294              CMP      r4,r2                 ;389
000068  d102              BNE      |L13.112|
                  |L13.106|
00006a  f7fffffe          BL       CLK_GetPCLK0Freq
00006e  e001              B        |L13.116|
                  |L13.112|
000070  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L13.116|
000074  9004              STR      r0,[sp,#0x10]         ;391
                  |L13.118|
000076  2f00              CMP      r7,#0                 ;401
000078  d01b              BEQ      |L13.178|
00007a  00a9              LSLS     r1,r5,#2              ;403
00007c  4668              MOV      r0,sp                 ;403
00007e  5840              LDR      r0,[r0,r1]            ;403
000080  1c71              ADDS     r1,r6,#1              ;403
000082  f7fffffe          BL       __aeabi_uidivmod
000086  4605              MOV      r5,r0                 ;403
000088  0879              LSRS     r1,r7,#1              ;403
00008a  1840              ADDS     r0,r0,r1              ;403
00008c  4639              MOV      r1,r7                 ;403
00008e  f7fffffe          BL       __aeabi_uidivmod
000092  4911              LDR      r1,|L13.216|
000094  1e80              SUBS     r0,r0,#2              ;405
000096  4288              CMP      r0,r1                 ;405
000098  d907              BLS      |L13.170|
00009a  00f9              LSLS     r1,r7,#3              ;407
00009c  1868              ADDS     r0,r5,r1              ;407
00009e  4639              MOV      r1,r7                 ;407
0000a0  f7fffffe          BL       __aeabi_uidivmod
0000a4  0900              LSRS     r0,r0,#4              ;407
0000a6  1e80              SUBS     r0,r0,#2              ;407
0000a8  e002              B        |L13.176|
                  |L13.170|
0000aa  2103              MOVS     r1,#3                 ;411
0000ac  0709              LSLS     r1,r1,#28             ;411
0000ae  4308              ORRS     r0,r0,r1              ;411
                  |L13.176|
0000b0  6260              STR      r0,[r4,#0x24]         ;407
                  |L13.178|
0000b2  990a              LDR      r1,[sp,#0x28]         ;416
0000b4  9809              LDR      r0,[sp,#0x24]         ;416
0000b6  4308              ORRS     r0,r0,r1              ;416
0000b8  9910              LDR      r1,[sp,#0x40]         ;416
0000ba  4308              ORRS     r0,r0,r1              ;416
0000bc  60e0              STR      r0,[r4,#0xc]          ;416
0000be  b00b              ADD      sp,sp,#0x2c
0000c0  bdf0              POP      {r4-r7,pc}
;;;418    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L13.196|
                          DCD      ||.constdata||+0x18
                  |L13.200|
                          DCD      0x40070000
                  |L13.204|
                          DCD      0x40000200
                  |L13.208|
                          DCD      0x40072000
                  |L13.212|
                          DCD      0x40071000
                  |L13.216|
                          DCD      0x0000ffff

                          AREA ||i.UART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  UART_SetTimeoutCnt PROC
;;;429     */
;;;430    void UART_SetTimeoutCnt(UART_T *uart, uint32_t u32TOC)
000000  6a02              LDR      r2,[r0,#0x20]
;;;431    {
;;;432        /* Set time-out interrupt comparator */
;;;433        uart->TOUT = (uart->TOUT & ~UART_TOUT_TOIC_Msk) | (u32TOC);
000002  0a12              LSRS     r2,r2,#8
000004  0212              LSLS     r2,r2,#8
000006  430a              ORRS     r2,r2,r1
000008  6202              STR      r2,[r0,#0x20]
;;;434    
;;;435        /* Set time-out counter enable */
;;;436        uart->INTEN |= UART_INTEN_TOCNTEN_Msk;
00000a  6841              LDR      r1,[r0,#4]
00000c  2201              MOVS     r2,#1
00000e  02d2              LSLS     r2,r2,#11
000010  4311              ORRS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;437    }
000014  4770              BX       lr
;;;438    
                          ENDP


                          AREA ||i.UART_Write||, CODE, READONLY, ALIGN=1

                  UART_Write PROC
;;;570     */
;;;571    uint32_t UART_Write(UART_T *uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;572    {
;;;573        uint32_t  u32Count, u32delayno;
;;;574        uint32_t  u32Exit = 0ul;
000002  2700              MOVS     r7,#0
000004  4605              MOV      r5,r0                 ;572
;;;575    
;;;576        for (u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
;;;577        {
;;;578            u32delayno = 0ul;
;;;579    
;;;580            while ((uart->FIFOSTS & UART_FIFOSTS_TXEMPTYF_Msk) == 0ul)   /* Wait Tx empty and Time-out manner */
;;;581            {
;;;582                u32delayno++;
;;;583    
;;;584                if (u32delayno >= 0x40000000ul)
000006  2601              MOVS     r6,#1
000008  4638              MOV      r0,r7                 ;576
00000a  07b6              LSLS     r6,r6,#30
00000c  e00c              B        |L15.40|
                  |L15.14|
00000e  2300              MOVS     r3,#0                 ;578
000010  e002              B        |L15.24|
                  |L15.18|
000012  1c5b              ADDS     r3,r3,#1              ;580
000014  42b3              CMP      r3,r6
000016  d209              BCS      |L15.44|
                  |L15.24|
000018  69ac              LDR      r4,[r5,#0x18]         ;580
00001a  00e4              LSLS     r4,r4,#3              ;580
00001c  d5f9              BPL      |L15.18|
;;;585                {
;;;586                    u32Exit = 1ul;
;;;587                    break;
;;;588                }
;;;589            }
;;;590    
;;;591            if (u32Exit == 1ul)
00001e  2f00              CMP      r7,#0
000020  d104              BNE      |L15.44|
;;;592            {
;;;593                break;
;;;594            }
;;;595            else
;;;596            {
;;;597                uart->DAT = pu8TxBuf[u32Count];    /* Send UART Data from buffer */
000022  5c0b              LDRB     r3,[r1,r0]
000024  602b              STR      r3,[r5,#0]
000026  1c40              ADDS     r0,r0,#1
                  |L15.40|
000028  4290              CMP      r0,r2                 ;576
00002a  d1f0              BNE      |L15.14|
                  |L15.44|
;;;598            }
;;;599        }
;;;600    
;;;601        return u32Count;
;;;602    
;;;603    }
00002c  bdf0              POP      {r4-r7,pc}
;;;604    /**
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600
                          DCD      0x01e84800
                          DCD      0x00000000
                          DCD      0x00008000
                          DCD      0x02dc6c00
                          DCD      0x00000000
                          DCD      0x00009600

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_uart_c_f12f5b44____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_uart_c_f12f5b44____REVSH|
#line 402
|__asm___6_uart_c_f12f5b44____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
