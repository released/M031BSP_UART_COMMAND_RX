; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.GPIO_Init||, CODE, READONLY, ALIGN=2

                  GPIO_Init PROC
;;;13     
;;;14     void GPIO_Init (void)
000000  b510              PUSH     {r4,lr}
;;;15     {
;;;16         GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000002  2201              MOVS     r2,#1
000004  0391              LSLS     r1,r2,#14
000006  4802              LDR      r0,|L1.16|
000008  f7fffffe          BL       GPIO_SetMode
;;;17     }
00000c  bd10              POP      {r4,pc}
;;;18     
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40004040

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;86     
;;;87     void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c1a              LDR      r4,|L2.112|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L2.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L2.10|
;;;88     {
;;;89         /* Unlock protected registers */
;;;90         SYS_UnlockReg();
;;;91     
;;;92         /* Enable HIRC clock (Internal RC 48MHz) */
;;;93         CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;94     //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;95     	
;;;96         /* Wait for HIRC clock ready */
;;;97         CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;98     //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;99     	
;;;100        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;101        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
000022  2100              MOVS     r1,#0
000024  2007              MOVS     r0,#7
000026  f7fffffe          BL       CLK_SetHCLK
;;;102    
;;;103        /* Enable UART0 clock */
;;;104        CLK_EnableModuleClock(UART0_MODULE);
00002a  4d12              LDR      r5,|L2.116|
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       CLK_EnableModuleClock
;;;105        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
000032  2101              MOVS     r1,#1
000034  2200              MOVS     r2,#0
000036  0689              LSLS     r1,r1,#26
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_SetModuleClock
;;;106    	
;;;107        CLK_EnableModuleClock(TMR3_MODULE);
00003e  4d0e              LDR      r5,|L2.120|
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       CLK_EnableModuleClock
;;;108        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000046  2101              MOVS     r1,#1
000048  2200              MOVS     r2,#0
00004a  0549              LSLS     r1,r1,#21
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_SetModuleClock
;;;109    	
;;;110    
;;;111        /* Update System Core Clock */
;;;112        SystemCoreClockUpdate();
000052  f7fffffe          BL       SystemCoreClockUpdate
;;;113    
;;;114        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;115        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
000056  07a8              LSLS     r0,r5,#30
000058  6bc1              LDR      r1,[r0,#0x3c]
00005a  22ff              MOVS     r2,#0xff
00005c  0412              LSLS     r2,r2,#16
00005e  4391              BICS     r1,r1,r2
000060  2233              MOVS     r2,#0x33
000062  0452              LSLS     r2,r2,#17
000064  1889              ADDS     r1,r1,r2
000066  63c1              STR      r1,[r0,#0x3c]
000068  2000              MOVS     r0,#0
00006a  6020              STR      r0,[r4,#0]
;;;116                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;117    
;;;118        /* Lock protected registers */
;;;119        SYS_LockReg();
;;;120    }
00006c  bd70              POP      {r4-r6,pc}
;;;121    
                          ENDP

00006e  0000              DCW      0x0000
                  |L2.112|
                          DCD      0x40000100
                  |L2.116|
                          DCD      0x5f803d10
                  |L2.120|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;36     
;;;37     void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;38     {
;;;39         TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L3.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L3.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;40         TIMER_EnableInt(TIMER3);
;;;41         NVIC_EnableIRQ(TMR3_IRQn);	
;;;42         TIMER_Start(TIMER3);
;;;43     }
000028  bd10              POP      {r4,pc}
;;;44     
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40051020
                  |L3.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;18     
;;;19     void TMR3_IRQHandler(void)
000000  480a              LDR      r0,|L4.44|
000002  6881              LDR      r1,[r0,#8]
000004  07c9              LSLS     r1,r1,#31
000006  0fc9              LSRS     r1,r1,#31
;;;20     {
000008  d00f              BEQ      |L4.42|
00000a  2301              MOVS     r3,#1
00000c  6083              STR      r3,[r0,#8]
;;;21     //	static uint32_t LOG = 0;
;;;22     	static uint16_t CNT = 0;
;;;23     	
;;;24         if(TIMER_GetIntFlag(TIMER3) == 1)
;;;25         {
;;;26             TIMER_ClearIntFlag(TIMER3);
;;;27     
;;;28     		if (CNT++ >= 1000)
00000e  4908              LDR      r1,|L4.48|
000010  8808              LDRH     r0,[r1,#0]  ; CNT
000012  1c42              ADDS     r2,r0,#1
000014  800a              STRH     r2,[r1,#0]
000016  227d              MOVS     r2,#0x7d
000018  00d2              LSLS     r2,r2,#3
00001a  4290              CMP      r0,r2
00001c  d305              BCC      |L4.42|
;;;29     		{		
;;;30     			CNT = 0;
00001e  2000              MOVS     r0,#0
000020  8008              STRH     r0,[r1,#0]
;;;31     //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;32     			PB14 ^= 1;
000022  4804              LDR      r0,|L4.52|
000024  6b81              LDR      r1,[r0,#0x38]
000026  4059              EORS     r1,r1,r3
000028  6381              STR      r1,[r0,#0x38]
                  |L4.42|
;;;33     		}		
;;;34         }
;;;35     }
00002a  4770              BX       lr
;;;36     
                          ENDP

                  |L4.44|
                          DCD      0x40051020
                  |L4.48|
                          DCD      ||.data||
                  |L4.52|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;44     
;;;45     void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;46     {
;;;47     	if ((UART_GET_INT_FLAG(UART0,UART_INTSTS_RDAINT_Msk))||
000002  4c08              LDR      r4,|L5.36|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  05c0              LSLS     r0,r0,#23
000008  d407              BMI      |L5.26|
;;;48     		(UART_GET_INT_FLAG(UART0,UART_INTSTS_RXTOIF_Msk)))
00000a  69e0              LDR      r0,[r4,#0x1c]
00000c  06c0              LSLS     r0,r0,#27
00000e  d404              BMI      |L5.26|
;;;49     	{
;;;50     		while(!UART_GET_RX_EMPTY(UART0))
;;;51     		{
;;;52     			UartCmd_Rx_Receive(UART_READ(UART0));
;;;53     		}
;;;54     	}
;;;55     }
000010  bd10              POP      {r4,pc}
                  |L5.18|
000012  6820              LDR      r0,[r4,#0]            ;52
000014  b2c0              UXTB     r0,r0                 ;52
000016  f7fffffe          BL       UartCmd_Rx_Receive
                  |L5.26|
00001a  69a0              LDR      r0,[r4,#0x18]         ;50
00001c  0440              LSLS     r0,r0,#17             ;50
00001e  d5f8              BPL      |L5.18|
000020  bd10              POP      {r4,pc}
;;;56     
                          ENDP

000022  0000              DCW      0x0000
                  |L5.36|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;56     
;;;57     void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;58     {
;;;59         SYS_ResetModule(UART0_RST);
000002  4820              LDR      r0,|L6.132|
000004  f7fffffe          BL       SYS_ResetModule
;;;60     
;;;61         /* Configure UART0 and set UART0 baud rate */
;;;62         UART_Open(UART0, 115200);
000008  4c1f              LDR      r4,|L6.136|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;63     
;;;64     	/* Set UART receive time-out */
;;;65     	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;66     
;;;67     	/* Set UART FIFO RX interrupt trigger level to 4-bytes*/
;;;68     	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  2110              MOVS     r1,#0x10
000020  4388              BICS     r0,r0,r1
000022  60a0              STR      r0,[r4,#8]
;;;69     	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  2120              MOVS     r1,#0x20
000028  4308              ORRS     r0,r0,r1
00002a  60a0              STR      r0,[r4,#8]
;;;70     
;;;71     	/* Enable UART Interrupt - */
;;;72     	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  4917              LDR      r1,|L6.140|
000030  4308              ORRS     r0,r0,r1
000032  6060              STR      r0,[r4,#4]
000034  2001              MOVS     r0,#1
000036  4916              LDR      r1,|L6.144|
000038  0300              LSLS     r0,r0,#12
00003a  6008              STR      r0,[r1,#0]
;;;73     	
;;;74     	NVIC_EnableIRQ(UART02_IRQn);	
;;;75     
;;;76     	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a014              ADR      r0,|L6.148|
000044  f7fffffe          BL       __2printf
;;;77     	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a018              ADR      r0,|L6.176|
000050  f7fffffe          BL       __2printf
;;;78     	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a01b              ADR      r0,|L6.200|
00005c  f7fffffe          BL       __2printf
;;;79     	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01e              ADR      r0,|L6.224|
000068  f7fffffe          BL       __2printf
;;;80     	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  a022              ADR      r0,|L6.252|
000074  f7fffffe          BL       __2printf
;;;81     
;;;82     	u8UartRxCnt=0;
000078  4927              LDR      r1,|L6.280|
00007a  2000              MOVS     r0,#0
00007c  7008              STRB     r0,[r1,#0]
;;;83     	u8SetProcessPkt=0;
00007e  4927              LDR      r1,|L6.284|
000080  7008              STRB     r0,[r1,#0]
;;;84     	
;;;85     }
000082  bd10              POP      {r4,pc}
;;;86     
                          ENDP

                  |L6.132|
                          DCD      0x04000010
                  |L6.136|
                          DCD      0x40070000
                  |L6.140|
                          DCD      0x00000811
                  |L6.144|
                          DCD      0xe000e100
                  |L6.148|
000094  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000098  4b5f4765
00009c  74435055
0000a0  46726571
0000a4  203a2025
0000a8  38640d0a
0000ac  00      
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L6.176|
0000b0  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000b4  47657448
0000b8  58544672
0000bc  6571203a
0000c0  20253864
0000c4  0d0a00  
0000c7  00                DCB      0
                  |L6.200|
0000c8  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000cc  4765744c
0000d0  58544672
0000d4  6571203a
0000d8  20253864
0000dc  0d0a00  
0000df  00                DCB      0
                  |L6.224|
0000e0  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000e4  47657450
0000e8  434c4b30
0000ec  46726571
0000f0  203a2025
0000f4  38640d0a
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L6.252|
0000fc  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
000100  47657450
000104  434c4b31
000108  46726571
00010c  203a2025
000110  38640d0a
000114  00      
000115  00                DCB      0
000116  00                DCB      0
000117  00                DCB      0
                  |L6.280|
                          DCD      u8UartRxCnt
                  |L6.284|
                          DCD      u8SetProcessPkt

                          AREA ||i.main||, CODE, READONLY, ALIGN=1

                  main PROC
;;;129    
;;;130    int main()
000000  f7fffffe          BL       SYS_Init
;;;131    {
;;;132        SYS_Init();
;;;133    
;;;134        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;135    
;;;136    	GPIO_Init();
000008  f7fffffe          BL       GPIO_Init
;;;137    
;;;138    	TIMER3_Init();
00000c  f7fffffe          BL       TIMER3_Init
                  |L7.16|
;;;139    	
;;;140        /* Got no where to go, just loop forever */
;;;141        while(1)
;;;142        {
;;;143    		UART0_Process();
000010  f7fffffe          BL       UART0_Process
000014  e7fc              B        |L7.16|
;;;144        }
;;;145    }
;;;146    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  ||CNT||
000000  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_db00cdf9____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_db00cdf9____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_db00cdf9____REVSH|
#line 402
|__asm___6_main_c_db00cdf9____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
