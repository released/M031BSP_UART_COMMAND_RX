; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\pwm.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\pwm.crf ..\..\..\Library\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;357      */
;;;358    static __INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;359    {
;;;360        uint32_t u32PllFreq;
;;;361        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;362        uint8_t au8NoTbl[4] = {1, 2, 2, 4}; /* OUTDIV :DEF: {1, 2, 2, 4} */
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;363        uint32_t u32Reg;
;;;364    
;;;365        u32PllFreq = 0;
;;;366        u32Reg = CLK->PLLCTL;
000006  4911              LDR      r1,|L1.76|
000008  9000              STR      r0,[sp,#0]            ;365
00000a  6809              LDR      r1,[r1,#0]
00000c  2000              MOVS     r0,#0                 ;365
;;;367    
;;;368        if ((u32Reg & (CLK_PLLCTL_PD_Msk | CLK_PLLCTL_OE_Msk)) == 0)
00000e  2205              MOVS     r2,#5
000010  0412              LSLS     r2,r2,#16
000012  4211              TST      r1,r2
000014  d116              BNE      |L1.68|
;;;369        {
;;;370            /* PLL is enabled and output enabled */
;;;371            if (u32Reg & CLK_PLLCTL_PLLSRC_Msk)
000016  0308              LSLS     r0,r1,#12
000018  d501              BPL      |L1.30|
;;;372            {
;;;373                u32FIN = (__HIRC >> 2);
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
;;;374            } else
;;;375                u32FIN = __HXT;
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
;;;376    
;;;377            if (u32Reg & CLK_PLLCTL_BP_Msk)
000020  038a              LSLS     r2,r1,#14
000022  d40f              BMI      |L1.68|
;;;378            {
;;;379                /* PLL is in bypass mode */
;;;380                u32PllFreq = u32FIN;
;;;381            }
;;;382            else
;;;383            {
;;;384                /* PLL is in normal work mode */
;;;385                u32NO = au8NoTbl[((u32Reg & CLK_PLLCTL_OUTDIV_Msk) >> CLK_PLLCTL_OUTDIV_Pos)];
000024  040a              LSLS     r2,r1,#16
000026  0f92              LSRS     r2,r2,#30
000028  466b              MOV      r3,sp
00002a  5c9b              LDRB     r3,[r3,r2]
;;;386                u32NF  = ((u32Reg & CLK_PLLCTL_FBDIV_Msk) >> CLK_PLLCTL_FBDIV_Pos) + 2;
00002c  05ca              LSLS     r2,r1,#23
;;;387                u32NR  = ((u32Reg & CLK_PLLCTL_INDIV_Msk) >> CLK_PLLCTL_INDIV_Pos) + 2;
00002e  0489              LSLS     r1,r1,#18
000030  0dd2              LSRS     r2,r2,#23             ;386
000032  0ec9              LSRS     r1,r1,#27
000034  1c89              ADDS     r1,r1,#2
;;;388                /* u32FIN is shifted 2 bits to avoid overflow */
;;;389                u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
000036  0880              LSRS     r0,r0,#2
000038  1c92              ADDS     r2,r2,#2
00003a  4359              MULS     r1,r3,r1
00003c  4350              MULS     r0,r2,r0
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2
                  |L1.68|
;;;390            }
;;;391        }
;;;392    
;;;393        return u32PllFreq;
;;;394    }
000044  bd08              POP      {r3,pc}
;;;395    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x40000240
                  |L1.80|
                          DCD      0x00b71b00
                  |L1.84|
                          DCD      0x01e84800

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearADCTriggerFlag PROC
;;;339     */
;;;340    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  2201              MOVS     r2,#1
;;;341    {
;;;342        (pwm)->STATUS = (PWM_STATUS_ADCTRG0_Msk << u32ChannelNum);
000002  0412              LSLS     r2,r2,#16
000004  408a              LSLS     r2,r2,r1
000006  30ff              ADDS     r0,r0,#0xff
000008  3001              ADDS     r0,#1
00000a  6202              STR      r2,[r0,#0x20]
;;;343    }
00000c  4770              BX       lr
;;;344    
                          ENDP


                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearCaptureIntFlag PROC
;;;585     */
;;;586    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  408a              LSLS     r2,r2,r1
;;;587    {
;;;588        (pwm)->CAPIF = (u32Edge << u32ChannelNum);
000002  30ff              ADDS     r0,r0,#0xff
000004  30ff              ADDS     r0,r0,#0xff
000006  3002              ADDS     r0,#2
000008  6542              STR      r2,[r0,#0x54]
;;;589    }
00000a  4770              BX       lr
;;;590    
                          ENDP


                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearDutyIntFlag PROC
;;;649     */
;;;650    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  4a02              LDR      r2,|L4.12|
;;;651    {
;;;652        (pwm)->INTSTS0 = (PWM_INTSTS0_CMPUIF0_Msk | PWM_INTSTS0_CMPDIF0_Msk) << u32ChannelNum;
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  6682              STR      r2,[r0,#0x68]
;;;653    }
000008  4770              BX       lr
;;;654    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      0x01010000

                          AREA ||i.PWM_ClearFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearFaultBrakeIntFlag PROC
;;;746     */
;;;747    void PWM_ClearFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  223f              MOVS     r2,#0x3f
;;;748    {
;;;749        (pwm)->INTSTS1 = (0x3fUL << u32BrakeSource);
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  66c2              STR      r2,[r0,#0x6c]
;;;750    }
000008  4770              BX       lr
;;;751    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;805     */
;;;806    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;807    {
;;;808        (pwm)->INTSTS0 = (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  0052              LSLS     r2,r2,#1
000004  21ff              MOVS     r1,#0xff
000006  3101              ADDS     r1,#1
000008  4091              LSLS     r1,r1,r2
00000a  3080              ADDS     r0,r0,#0x80
00000c  6681              STR      r1,[r0,#0x68]
;;;809    }
00000e  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.PWM_ClearWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearWrapAroundFlag PROC
;;;1013    */
;;;1014   void PWM_ClearWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;1015   {
;;;1016       (pwm)->STATUS = (PWM_STATUS_CNTMAX0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  30ff              ADDS     r0,r0,#0xff
00000a  3001              ADDS     r0,#1
00000c  6201              STR      r1,[r0,#0x20]
;;;1017   }
00000e  4770              BX       lr
;;;1018   
                          ENDP


                          AREA ||i.PWM_ClearZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearZeroIntFlag PROC
;;;863     */
;;;864    void PWM_ClearZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  084a              LSRS     r2,r1,#1
;;;865    {
;;;866        (pwm)->INTSTS0 = (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  0052              LSLS     r2,r2,#1
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  3080              ADDS     r0,r0,#0x80
00000a  6681              STR      r1,[r0,#0x68]
;;;867    }
00000c  4770              BX       lr
;;;868    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;36      */
;;;37     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge)
000000  b5ff              PUSH     {r0-r7,lr}
;;;38     {
000002  4605              MOV      r5,r0
000004  b083              SUB      sp,sp,#0xc
;;;39         uint32_t u32Src;
;;;40         uint32_t u32PWMClockSrc;
;;;41         uint32_t u32NearestUnitTimeNsec;
;;;42         uint16_t u16Prescale = 1UL, u16CNR = 0xFFFFUL;
000006  4827              LDR      r0,|L9.164|
;;;43         uint8_t u8BreakLoop = 0UL;
;;;44     
;;;45         if (pwm == PWM0)
;;;46             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM0SEL_Msk;
000008  9001              STR      r0,[sp,#4]
00000a  4828              LDR      r0,|L9.172|
00000c  4f26              LDR      r7,|L9.168|
00000e  2401              MOVS     r4,#1                 ;42
000010  2600              MOVS     r6,#0                 ;43
;;;47         else//(pwm == PWM1)
;;;48             u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM1SEL_Msk;
000012  6980              LDR      r0,[r0,#0x18]
000014  42bd              CMP      r5,r7                 ;45
000016  d101              BNE      |L9.28|
000018  4020              ANDS     r0,r0,r4              ;46
00001a  e001              B        |L9.32|
                  |L9.28|
00001c  2102              MOVS     r1,#2
00001e  4008              ANDS     r0,r0,r1
                  |L9.32|
;;;49     
;;;50         if (u32Src == 0UL)
000020  2800              CMP      r0,#0
000022  d006              BEQ      |L9.50|
;;;51         {
;;;52             //clock source is from PLL clock
;;;53             u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;54         }
;;;55         else
;;;56         {
;;;57             //clock source is from PCLK
;;;58             SystemCoreClockUpdate();
000024  f7fffffe          BL       SystemCoreClockUpdate
;;;59     
;;;60             if (pwm == PWM0)
000028  42bd              CMP      r5,r7
00002a  d105              BNE      |L9.56|
;;;61             {
;;;62                 u32PWMClockSrc = CLK_GetPCLK0Freq();
00002c  f7fffffe          BL       CLK_GetPCLK0Freq
000030  e004              B        |L9.60|
                  |L9.50|
000032  f7fffffe          BL       CLK_GetPLLClockFreq
000036  e001              B        |L9.60|
                  |L9.56|
;;;63             }
;;;64             else     /* (pwm == PWM1) */
;;;65             {
;;;66                 u32PWMClockSrc = CLK_GetPCLK1Freq();
000038  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L9.60|
;;;67             }
;;;68         }
;;;69     
;;;70         u32PWMClockSrc /= 1000UL;
00003c  217d              MOVS     r1,#0x7d
00003e  00c9              LSLS     r1,r1,#3
000040  f7fffffe          BL       __aeabi_uidivmod
000044  9000              STR      r0,[sp,#0]
                  |L9.70|
;;;71     
;;;72         for (u16Prescale = 1UL; u16Prescale <= 0x1000UL; u16Prescale++)
;;;73         {
;;;74             u32NearestUnitTimeNsec = (1000000UL * u16Prescale) / u32PWMClockSrc;
000046  491a              LDR      r1,|L9.176|
000048  4620              MOV      r0,r4
00004a  4348              MULS     r0,r1,r0
00004c  9900              LDR      r1,[sp,#0]
00004e  f7fffffe          BL       __aeabi_uidivmod
;;;75     
;;;76             if (u32NearestUnitTimeNsec < u32UnitTimeNsec)
000052  9905              LDR      r1,[sp,#0x14]
000054  4288              CMP      r0,r1
000056  d210              BCS      |L9.122|
;;;77             {
;;;78                 if (u16Prescale == 0x1000UL)
000058  2301              MOVS     r3,#1
00005a  031b              LSLS     r3,r3,#12
00005c  429c              CMP      r4,r3
00005e  d100              BNE      |L9.98|
;;;79                 {
;;;80                     /* limit to the maximum unit time(nano second) */
;;;81                     u8BreakLoop = 1UL;
000060  2601              MOVS     r6,#1
                  |L9.98|
;;;82                 }
;;;83     
;;;84                 if (!((1000000UL * (u16Prescale + 1UL) > (u32NearestUnitTimeNsec * u32PWMClockSrc))))
000062  4a13              LDR      r2,|L9.176|
000064  9f00              LDR      r7,[sp,#0]
000066  1c61              ADDS     r1,r4,#1
000068  434a              MULS     r2,r1,r2
00006a  4347              MULS     r7,r0,r7
00006c  42ba              CMP      r2,r7
00006e  d904              BLS      |L9.122|
;;;85                 {
;;;86                     u8BreakLoop = 1UL;
;;;87                 }
;;;88             }
;;;89             else
;;;90             {
;;;91                 u8BreakLoop = 1UL;
;;;92             }
;;;93     
;;;94             if (u8BreakLoop)
000070  2e00              CMP      r6,#0
000072  d102              BNE      |L9.122|
000074  b28c              UXTH     r4,r1                 ;72
000076  429c              CMP      r4,r3                 ;72
000078  d9e5              BLS      |L9.70|
                  |L9.122|
;;;95             {
;;;96                 break;
;;;97             }
;;;98         }
;;;99     
;;;100        // convert to real register value
;;;101        u16Prescale = u16Prescale - 1UL;
;;;102        // every two channels share a prescaler
;;;103        PWM_SET_PRESCALER(pwm, u32ChannelNum, (uint32_t)u16Prescale);
00007a  9904              LDR      r1,[sp,#0x10]
00007c  1e64              SUBS     r4,r4,#1              ;72
00007e  084a              LSRS     r2,r1,#1
000080  b2a3              UXTH     r3,r4                 ;101
000082  0091              LSLS     r1,r2,#2
000084  194c              ADDS     r4,r1,r5
000086  6163              STR      r3,[r4,#0x14]
;;;104    
;;;105        // set PWM to down count type(edge aligned)
;;;106        (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1UL) << 2UL))) | (1UL << ((u32ChannelNum >> 1UL) << 2UL));
000088  686b              LDR      r3,[r5,#4]
00008a  2403              MOVS     r4,#3
00008c  408c              LSLS     r4,r4,r1
00008e  43a3              BICS     r3,r3,r4
000090  2401              MOVS     r4,#1
000092  408c              LSLS     r4,r4,r1
000094  4323              ORRS     r3,r3,r4
000096  606b              STR      r3,[r5,#4]
;;;107    
;;;108        PWM_SET_CNR(pwm, u32ChannelNum, u16CNR);
000098  00d2              LSLS     r2,r2,#3
00009a  1952              ADDS     r2,r2,r5
00009c  9901              LDR      r1,[sp,#4]
00009e  6311              STR      r1,[r2,#0x30]
;;;109    
;;;110        return (u32NearestUnitTimeNsec);
;;;111    }
0000a0  b007              ADD      sp,sp,#0x1c
0000a2  bdf0              POP      {r4-r7,pc}
;;;112    
                          ENDP

                  |L9.164|
                          DCD      0x0000ffff
                  |L9.168|
                          DCD      0x40058000
                  |L9.172|
                          DCD      0x40000200
                  |L9.176|
                          DCD      0x000f4240

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;124     */
;;;125    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle)
000000  b5ff              PUSH     {r0-r7,lr}
;;;126    {
000002  4604              MOV      r4,r0
;;;127        uint32_t u32Src;
;;;128        uint32_t u32PWMClockSrc;
;;;129        uint32_t i;
;;;130        uint16_t u16Prescale = 1UL, u16CNR = 0xFFFFUL;
;;;131    
;;;132        if (pwm == PWM0)
;;;133            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM0SEL_Msk;
000004  4842              LDR      r0,|L10.272|
000006  4e41              LDR      r6,|L10.268|
000008  2501              MOVS     r5,#1                 ;130
00000a  4f3f              LDR      r7,|L10.264|
;;;134        else//(pwm == PWM1)
;;;135            u32Src = CLK->CLKSEL2 & CLK_CLKSEL2_PWM1SEL_Msk;
00000c  2102              MOVS     r1,#2
00000e  6980              LDR      r0,[r0,#0x18]
000010  b083              SUB      sp,sp,#0xc            ;126
000012  42b4              CMP      r4,r6                 ;132
000014  d101              BNE      |L10.26|
000016  4028              ANDS     r0,r0,r5              ;133
000018  e000              B        |L10.28|
                  |L10.26|
00001a  4008              ANDS     r0,r0,r1
                  |L10.28|
;;;136    
;;;137        if (u32Src == 0UL)
00001c  2800              CMP      r0,#0
00001e  d006              BEQ      |L10.46|
;;;138        {
;;;139            //clock source is from PLL clock
;;;140            u32PWMClockSrc = CLK_GetPLLClockFreq();
;;;141        }
;;;142        else
;;;143        {
;;;144            //clock source is from PCLK
;;;145            SystemCoreClockUpdate();
000020  f7fffffe          BL       SystemCoreClockUpdate
;;;146    
;;;147            if (pwm == PWM0)
000024  42b4              CMP      r4,r6
000026  d105              BNE      |L10.52|
;;;148            {
;;;149                u32PWMClockSrc = CLK_GetPCLK0Freq();
000028  f7fffffe          BL       CLK_GetPCLK0Freq
00002c  e004              B        |L10.56|
                  |L10.46|
00002e  f7fffffe          BL       CLK_GetPLLClockFreq
000032  e001              B        |L10.56|
                  |L10.52|
;;;150            }
;;;151            else     /* (pwm == PWM1) */
;;;152            {
;;;153                u32PWMClockSrc = CLK_GetPCLK1Freq();
000034  f7fffffe          BL       CLK_GetPCLK1Freq
                  |L10.56|
000038  4606              MOV      r6,r0                 ;149
;;;154            }
;;;155        }
;;;156    
;;;157        for (u16Prescale = 1UL; u16Prescale < 0xFFFUL; u16Prescale++)   //prescale could be 0~0xFFF
;;;158        {
;;;159            i = (u32PWMClockSrc / u32Frequency) / u16Prescale;
00003a  9905              LDR      r1,[sp,#0x14]
00003c  f7fffffe          BL       __aeabi_uidivmod
000040  9000              STR      r0,[sp,#0]
                  |L10.66|
000042  4629              MOV      r1,r5
000044  f7fffffe          BL       __aeabi_uidivmod
;;;160    
;;;161            // If target value is larger than CNR, need to use a larger prescaler
;;;162            if (i <= (0x10000UL))
000048  2101              MOVS     r1,#1
00004a  0409              LSLS     r1,r1,#16
00004c  4288              CMP      r0,r1
00004e  d801              BHI      |L10.84|
;;;163            {
;;;164                u16CNR = (uint16_t)i;
000050  b287              UXTH     r7,r0
;;;165                break;
000052  e006              B        |L10.98|
                  |L10.84|
000054  1c6d              ADDS     r5,r5,#1
000056  482f              LDR      r0,|L10.276|
000058  b2ad              UXTH     r5,r5                 ;157
00005a  4285              CMP      r5,r0                 ;157
00005c  d201              BCS      |L10.98|
00005e  9800              LDR      r0,[sp,#0]            ;157
000060  e7ef              B        |L10.66|
                  |L10.98|
;;;166            }
;;;167        }
;;;168    
;;;169        // Store return value here 'cos we're gonna change u16Prescale & u16CNR to the real value to fill into register
;;;170        i = u32PWMClockSrc / ((uint32_t)u16Prescale * (uint32_t)u16CNR);
000062  4629              MOV      r1,r5
000064  4379              MULS     r1,r7,r1
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       __aeabi_uidivmod
;;;171    
;;;172        // convert to real register value
;;;173        u16Prescale = u16Prescale - 1UL;
;;;174        // every two channels share a prescaler
;;;175        PWM_SET_PRESCALER(pwm, u32ChannelNum, (uint32_t)u16Prescale);
00006c  9001              STR      r0,[sp,#4]
00006e  9804              LDR      r0,[sp,#0x10]
000070  1e6d              SUBS     r5,r5,#1              ;170
000072  0842              LSRS     r2,r0,#1
000074  0090              LSLS     r0,r2,#2
000076  b2a9              UXTH     r1,r5                 ;173
000078  1903              ADDS     r3,r0,r4
00007a  6159              STR      r1,[r3,#0x14]
;;;176        // set PWM to down count type(edge aligned)
;;;177        (pwm)->CTL1 = ((pwm)->CTL1 & ~(PWM_CTL1_CNTTYPE0_Msk << ((u32ChannelNum >> 1UL) << 2UL))) | (1UL << ((u32ChannelNum >> 1UL) << 2UL));
00007c  6861              LDR      r1,[r4,#4]
00007e  2303              MOVS     r3,#3
000080  4083              LSLS     r3,r3,r0
000082  4399              BICS     r1,r1,r3
000084  2301              MOVS     r3,#1
000086  4083              LSLS     r3,r3,r0
000088  4319              ORRS     r1,r1,r3
00008a  6061              STR      r1,[r4,#4]
00008c  1e7f              SUBS     r7,r7,#1
;;;178    
;;;179        u16CNR -= 1UL;
;;;180        PWM_SET_CNR(pwm, u32ChannelNum, u16CNR);
00008e  00d0              LSLS     r0,r2,#3
000090  b2b9              UXTH     r1,r7                 ;179
000092  1900              ADDS     r0,r0,r4
000094  6301              STR      r1,[r0,#0x30]
;;;181    
;;;182        if (u32DutyCycle)
;;;183        {
;;;184            if (u32DutyCycle >= 100UL)
;;;185                PWM_SET_CMR(pwm, u32ChannelNum, u16CNR);
000096  9804              LDR      r0,[sp,#0x10]
;;;186            else
;;;187                PWM_SET_CMR(pwm, u32ChannelNum, u32DutyCycle * (u16CNR + 1UL) / 100UL);
;;;188    
;;;189            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum << 1UL));
000098  4d1f              LDR      r5,|L10.280|
00009a  0080              LSLS     r0,r0,#2              ;185
00009c  1906              ADDS     r6,r0,r4              ;185
00009e  9804              LDR      r0,[sp,#0x10]
0000a0  2702              MOVS     r7,#2                 ;135
0000a2  0040              LSLS     r0,r0,#1
;;;190            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << ((u32ChannelNum << 1UL) + PWM_WGCTL0_PRDPCTL0_Pos));
0000a4  4603              MOV      r3,r0
0000a6  3310              ADDS     r3,r3,#0x10
;;;191            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum << 1UL));
;;;192            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << ((u32ChannelNum << 1UL) + PWM_WGCTL1_CMPDCTL0_Pos));
0000a8  409f              LSLS     r7,r7,r3
0000aa  9a06              LDR      r2,[sp,#0x18]         ;190
0000ac  4085              LSLS     r5,r5,r0              ;189
0000ae  3480              ADDS     r4,r4,#0x80           ;189
0000b0  9300              STR      r3,[sp,#0]            ;182
0000b2  2a00              CMP      r2,#0                 ;182
0000b4  d01c              BEQ      |L10.240|
0000b6  4610              MOV      r0,r2                 ;184
0000b8  2a64              CMP      r2,#0x64              ;184
0000ba  d301              BCC      |L10.192|
0000bc  6531              STR      r1,[r6,#0x50]         ;185
0000be  e005              B        |L10.204|
                  |L10.192|
0000c0  1c49              ADDS     r1,r1,#1              ;185
0000c2  4348              MULS     r0,r1,r0              ;187
0000c4  2164              MOVS     r1,#0x64              ;187
0000c6  f7fffffe          BL       __aeabi_uidivmod
0000ca  6530              STR      r0,[r6,#0x50]         ;187
                  |L10.204|
0000cc  6b20              LDR      r0,[r4,#0x30]         ;189
0000ce  43a8              BICS     r0,r0,r5              ;189
0000d0  6320              STR      r0,[r4,#0x30]         ;189
0000d2  6b21              LDR      r1,[r4,#0x30]         ;190
0000d4  9a00              LDR      r2,[sp,#0]            ;190
0000d6  2001              MOVS     r0,#1                 ;190
0000d8  4090              LSLS     r0,r0,r2              ;190
0000da  4301              ORRS     r1,r1,r0              ;190
0000dc  6321              STR      r1,[r4,#0x30]         ;190
                  |L10.222|
;;;193        }
;;;194        else
;;;195        {
;;;196            PWM_SET_CMR(pwm, u32ChannelNum, 0UL);
;;;197            (pwm)->WGCTL0 &= ~((PWM_WGCTL0_PRDPCTL0_Msk | PWM_WGCTL0_ZPCTL0_Msk) << (u32ChannelNum << 1UL));
;;;198            (pwm)->WGCTL0 |= (PWM_OUTPUT_LOW << ((u32ChannelNum << 1UL) + PWM_WGCTL0_ZPCTL0_Pos));
;;;199            (pwm)->WGCTL1 &= ~((PWM_WGCTL1_CMPDCTL0_Msk | PWM_WGCTL1_CMPUCTL0_Msk) << (u32ChannelNum << 1UL));
0000de  6b60              LDR      r0,[r4,#0x34]
0000e0  43a8              BICS     r0,r0,r5
0000e2  6360              STR      r0,[r4,#0x34]
;;;200            (pwm)->WGCTL1 |= (PWM_OUTPUT_HIGH << ((u32ChannelNum << 1UL) + PWM_WGCTL1_CMPDCTL0_Pos));
0000e4  6b60              LDR      r0,[r4,#0x34]
0000e6  4338              ORRS     r0,r0,r7
0000e8  6360              STR      r0,[r4,#0x34]
;;;201        }
;;;202    
;;;203        return (i);
0000ea  9801              LDR      r0,[sp,#4]
;;;204    }
0000ec  b007              ADD      sp,sp,#0x1c
0000ee  bdf0              POP      {r4-r7,pc}
                  |L10.240|
0000f0  2100              MOVS     r1,#0                 ;196
0000f2  6531              STR      r1,[r6,#0x50]         ;196
0000f4  6b21              LDR      r1,[r4,#0x30]         ;197
0000f6  43a9              BICS     r1,r1,r5              ;197
0000f8  6321              STR      r1,[r4,#0x30]         ;197
0000fa  6b22              LDR      r2,[r4,#0x30]         ;198
0000fc  2101              MOVS     r1,#1                 ;198
0000fe  4081              LSLS     r1,r1,r0              ;198
000100  430a              ORRS     r2,r2,r1              ;198
000102  6322              STR      r2,[r4,#0x30]         ;198
000104  e7eb              B        |L10.222|
;;;205    
                          ENDP

000106  0000              DCW      0x0000
                  |L10.264|
                          DCD      0x0000ffff
                  |L10.268|
                          DCD      0x40058000
                  |L10.272|
                          DCD      0x40000200
                  |L10.276|
                          DCD      0x00000fff
                  |L10.280|
                          DCD      0x00030003

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_DisableADCTrigger PROC
;;;317     */
;;;318    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000000  00ca              LSLS     r2,r1,#3
;;;319    {
;;;320        if (u32ChannelNum < 4UL)
;;;321        {
;;;322            (pwm)->ADCTS0 &= ~(PWM_ADCTS0_TRGEN0_Msk << (u32ChannelNum << 3UL));
000002  2380              MOVS     r3,#0x80
000004  3080              ADDS     r0,r0,#0x80
000006  2904              CMP      r1,#4                 ;320
000008  d204              BCS      |L11.20|
00000a  6f81              LDR      r1,[r0,#0x78]
00000c  4093              LSLS     r3,r3,r2
00000e  4399              BICS     r1,r1,r3
000010  6781              STR      r1,[r0,#0x78]
;;;323        }
;;;324        else
;;;325        {
;;;326            (pwm)->ADCTS1 &= ~(PWM_ADCTS1_TRGEN4_Msk << ((u32ChannelNum - 4UL) << 3UL));
;;;327        }
;;;328    }
000012  4770              BX       lr
                  |L11.20|
000014  3a20              SUBS     r2,r2,#0x20
000016  6fc1              LDR      r1,[r0,#0x7c]         ;326
000018  4093              LSLS     r3,r3,r2              ;326
00001a  4399              BICS     r1,r1,r3              ;326
00001c  67c1              STR      r1,[r0,#0x7c]         ;326
00001e  4770              BX       lr
;;;329    
                          ENDP


                          AREA ||i.PWM_DisableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakeNoiseFilter PROC
;;;940     */
;;;941    void PWM_DisableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;942    {
;;;943        (pwm)->BNF &= ~(PWM_BNF_BRK0NFEN_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2101              MOVS     r1,#1
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;944    }
00000e  4770              BX       lr
;;;945    
                          ENDP


                          AREA ||i.PWM_DisableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_DisableBrakePinInverse PROC
;;;968     */
;;;969    void PWM_DisableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;970    {
;;;971        (pwm)->BNF &= ~(PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  438a              BICS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;972    }
00000e  4770              BX       lr
;;;973    
                          ENDP


                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;468     */
;;;469    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;470    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;471        (pwm)->CAPINEN &= ~u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  438a              BICS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;472        (pwm)->CAPCTL &= ~u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  438a              BICS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;473    }
000012  4770              BX       lr
;;;474    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;568     */
;;;569    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;570    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;571        (pwm)->CAPIEN &= ~(u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4393              BICS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;572    }
00000e  4770              BX       lr
;;;573    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;533     */
;;;534    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  0849              LSRS     r1,r1,#1
;;;535    {
;;;536        // every two channels shares the same setting
;;;537        (pwm)->DTCTL[(u32ChannelNum) >> 1UL] &= ~PWM_DTCTL0_1_DTEN_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  2201              MOVS     r2,#1
00000a  0412              LSLS     r2,r2,#16
00000c  4391              BICS     r1,r1,r2
00000e  6701              STR      r1,[r0,#0x70]
;;;538    }
000010  4770              BX       lr
;;;539    
                          ENDP


                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=2

                  PWM_DisableDutyInt PROC
;;;635     */
;;;636    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;637    {
;;;638        (pwm)->INTEN0 &= ~((PWM_DUTY_INT_DOWN_COUNT_MATCH_CMP | PWM_DUTY_INT_UP_COUNT_MATCH_CMP) << u32ChannelNum);
000002  6e02              LDR      r2,[r0,#0x60]
000004  4b02              LDR      r3,|L17.16|
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6602              STR      r2,[r0,#0x60]
;;;639    }
00000c  4770              BX       lr
;;;640    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x01010000

                          AREA ||i.PWM_DisableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableFaultBrakeInt PROC
;;;731     */
;;;732    void PWM_DisableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;733    {
;;;734        (pwm)->INTEN1 &= ~(0x7UL << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;735    }
00000c  4770              BX       lr
;;;736    
                          ENDP


                          AREA ||i.PWM_DisableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_DisableLoadMode PROC
;;;699     */
;;;700    void PWM_DisableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;701    {
;;;702        (pwm)->CTL0 &= ~(u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4393              BICS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;703    }
000008  4770              BX       lr
;;;704    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;499     */
;;;500    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;501    {
;;;502        (pwm)->POEN &= ~u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  438a              BICS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;503    }
000008  4770              BX       lr
;;;504    
                          ENDP


                          AREA ||i.PWM_DisablePDMA||, CODE, READONLY, ALIGN=1

                  PWM_DisablePDMA PROC
;;;1051    */
;;;1052   void PWM_DisablePDMA(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;1053   {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;1054       (pwm)->PDMACTL &= ~(PWM_PDMACTL_CHEN0_1_Msk << ((u32ChannelNum >> 1UL) << 3UL));
000006  6bc2              LDR      r2,[r0,#0x3c]
000008  0849              LSRS     r1,r1,#1
00000a  00cb              LSLS     r3,r1,#3
00000c  2101              MOVS     r1,#1
00000e  4099              LSLS     r1,r1,r3
000010  438a              BICS     r2,r2,r1
000012  63c2              STR      r2,[r0,#0x3c]
;;;1055   }
000014  4770              BX       lr
;;;1056   
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;791     */
;;;792    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;793    {
;;;794        (pwm)->INTEN0 &= ~(PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  438a              BICS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;795    }
000012  4770              BX       lr
;;;796    
                          ENDP


                          AREA ||i.PWM_DisableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableZeroInt PROC
;;;849     */
;;;850    void PWM_DisableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;851    {
;;;852        (pwm)->INTEN0 &= ~(PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  438a              BICS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;853    }
000010  4770              BX       lr
;;;854    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_EnableADCTrigger PROC
;;;294     */
;;;295    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  b510              PUSH     {r4,lr}
;;;296    {
;;;297        if (u32ChannelNum < 4UL)
;;;298        {
;;;299            (pwm)->ADCTS0 &= ~((PWM_ADCTS0_TRGSEL0_Msk) << (u32ChannelNum << 3UL));
;;;300            (pwm)->ADCTS0 |= ((PWM_ADCTS0_TRGEN0_Msk | u32Condition) << (u32ChannelNum << 3UL));
000002  2380              MOVS     r3,#0x80
000004  431a              ORRS     r2,r2,r3
000006  240f              MOVS     r4,#0xf               ;299
000008  00cb              LSLS     r3,r1,#3              ;299
00000a  3080              ADDS     r0,r0,#0x80           ;299
00000c  2904              CMP      r1,#4                 ;297
00000e  d208              BCS      |L24.34|
000010  6f81              LDR      r1,[r0,#0x78]         ;299
000012  409c              LSLS     r4,r4,r3              ;299
000014  43a1              BICS     r1,r1,r4              ;299
000016  6781              STR      r1,[r0,#0x78]         ;299
000018  6f81              LDR      r1,[r0,#0x78]
00001a  409a              LSLS     r2,r2,r3
00001c  430a              ORRS     r2,r2,r1
00001e  6782              STR      r2,[r0,#0x78]
;;;301        }
;;;302        else
;;;303        {
;;;304            (pwm)->ADCTS1 &= ~((PWM_ADCTS1_TRGSEL4_Msk) << ((u32ChannelNum - 4UL) << 3UL));
;;;305            (pwm)->ADCTS1 |= ((PWM_ADCTS1_TRGEN4_Msk | u32Condition) << ((u32ChannelNum - 4UL) << 3UL));
;;;306        }
;;;307    }
000020  bd10              POP      {r4,pc}
                  |L24.34|
000022  3b20              SUBS     r3,r3,#0x20
000024  6fc1              LDR      r1,[r0,#0x7c]         ;304
000026  409c              LSLS     r4,r4,r3              ;304
000028  43a1              BICS     r1,r1,r4              ;304
00002a  67c1              STR      r1,[r0,#0x7c]         ;304
00002c  6fc1              LDR      r1,[r0,#0x7c]         ;305
00002e  409a              LSLS     r2,r2,r3              ;305
000030  430a              ORRS     r2,r2,r1              ;305
000032  67c2              STR      r2,[r0,#0x7c]         ;305
000034  bd10              POP      {r4,pc}
;;;308    
                          ENDP


                          AREA ||i.PWM_EnableBrakeNoiseFilter||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakeNoiseFilter PROC
;;;925     */
;;;926    void PWM_EnableBrakeNoiseFilter(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel)
000000  b530              PUSH     {r4,r5,lr}
;;;927    {
000002  3080              ADDS     r0,r0,#0x80
;;;928        (pwm)->BNF = ((pwm)->BNF & ~((PWM_BNF_BRK0FCNT_Msk | PWM_BNF_BRK0NFSEL_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos))) | \
000004  6c04              LDR      r4,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  257e              MOVS     r5,#0x7e
00000a  408d              LSLS     r5,r5,r1
00000c  0112              LSLS     r2,r2,#4
00000e  005b              LSLS     r3,r3,#1
000010  431a              ORRS     r2,r2,r3
000012  1c52              ADDS     r2,r2,#1
000014  43ac              BICS     r4,r4,r5
000016  408a              LSLS     r2,r2,r1
000018  4314              ORRS     r4,r4,r2
00001a  6404              STR      r4,[r0,#0x40]
;;;929                     (((u32ClkCnt << PWM_BNF_BRK0FCNT_Pos) | (u32ClkDivSel << PWM_BNF_BRK0NFSEL_Pos) | PWM_BNF_BRK0NFEN_Msk) << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
;;;930    }
00001c  bd30              POP      {r4,r5,pc}
;;;931    
                          ENDP


                          AREA ||i.PWM_EnableBrakePinInverse||, CODE, READONLY, ALIGN=1

                  PWM_EnableBrakePinInverse PROC
;;;954     */
;;;955    void PWM_EnableBrakePinInverse(PWM_T *pwm, uint32_t u32BrakePinNum)
000000  3080              ADDS     r0,r0,#0x80
;;;956    {
;;;957        (pwm)->BNF |= (PWM_BNF_BRK0PINV_Msk << (u32BrakePinNum * PWM_BNF_BRK1NFEN_Pos));
000002  6c02              LDR      r2,[r0,#0x40]
000004  00cb              LSLS     r3,r1,#3
000006  2180              MOVS     r1,#0x80
000008  4099              LSLS     r1,r1,r3
00000a  430a              ORRS     r2,r2,r1
00000c  6402              STR      r2,[r0,#0x40]
;;;958    }
00000e  4770              BX       lr
;;;959    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;452     */
;;;453    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  30ff              ADDS     r0,r0,#0xff
;;;454    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;455        (pwm)->CAPINEN |= u32ChannelMask;
000006  6802              LDR      r2,[r0,#0]
000008  430a              ORRS     r2,r2,r1
00000a  6002              STR      r2,[r0,#0]
;;;456        (pwm)->CAPCTL |= u32ChannelMask;
00000c  6842              LDR      r2,[r0,#4]
00000e  430a              ORRS     r2,r2,r1
000010  6042              STR      r2,[r0,#4]
;;;457    }
000012  4770              BX       lr
;;;458    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;551     */
;;;552    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  30ff              ADDS     r0,r0,#0xff
;;;553    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;554        (pwm)->CAPIEN |= (u32Edge << u32ChannelNum);
000006  6d03              LDR      r3,[r0,#0x50]
000008  408a              LSLS     r2,r2,r1
00000a  4313              ORRS     r3,r3,r2
00000c  6503              STR      r3,[r0,#0x50]
;;;555    }
00000e  4770              BX       lr
;;;556    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;516     */
;;;517    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  0849              LSRS     r1,r1,#1
;;;518    {
;;;519        // every two channels share the same setting
;;;520        (pwm)->DTCTL[(u32ChannelNum) >> 1UL] &= ~PWM_DTCTL0_1_DTCNT_Msk;
000002  0089              LSLS     r1,r1,#2
000004  1808              ADDS     r0,r1,r0
000006  6f01              LDR      r1,[r0,#0x70]
000008  0b09              LSRS     r1,r1,#12
00000a  0309              LSLS     r1,r1,#12
00000c  6701              STR      r1,[r0,#0x70]
;;;521        (pwm)->DTCTL[(u32ChannelNum) >> 1UL] |= PWM_DTCTL0_1_DTEN_Msk | u32Duration;
00000e  6f01              LDR      r1,[r0,#0x70]
000010  2301              MOVS     r3,#1
000012  041b              LSLS     r3,r3,#16
000014  431a              ORRS     r2,r2,r3
000016  4311              ORRS     r1,r1,r2
000018  6701              STR      r1,[r0,#0x70]
;;;522    }
00001a  4770              BX       lr
;;;523    
                          ENDP


                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;621     */
;;;622    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  3080              ADDS     r0,r0,#0x80
;;;623    {
;;;624        (pwm)->INTEN0 |= (u32IntDutyType << u32ChannelNum);
000002  6e03              LDR      r3,[r0,#0x60]
000004  408a              LSLS     r2,r2,r1
000006  4313              ORRS     r3,r3,r2
000008  6603              STR      r3,[r0,#0x60]
;;;625    }
00000a  4770              BX       lr
;;;626    
                          ENDP


                          AREA ||i.PWM_EnableFaultBrake||, CODE, READONLY, ALIGN=2

                  PWM_EnableFaultBrake PROC
;;;386     */
;;;387    void PWM_EnableFaultBrake(PWM_T *pwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource)
000000  b5f0              PUSH     {r4-r7,lr}
;;;388    {
000002  4696              MOV      lr,r2
;;;389        uint32_t i;
;;;390    
;;;391        for (i = 0UL; i < PWM_CHANNEL_NUM; i ++)
000004  2400              MOVS     r4,#0
;;;392        {
;;;393            if (u32ChannelMask & (1UL << i))
;;;394            {
;;;395                if ((u32BrakeSource == PWM_FB_EDGE_SYS_CSS) || (u32BrakeSource == PWM_FB_EDGE_SYS_BOD) || \
;;;396                        (u32BrakeSource == PWM_FB_EDGE_SYS_COR) || \
;;;397                        (u32BrakeSource == PWM_FB_LEVEL_SYS_CSS) || (u32BrakeSource == PWM_FB_LEVEL_SYS_BOD) || \
;;;398                        (u32BrakeSource == PWM_FB_LEVEL_SYS_COR))
;;;399                {
;;;400                    (pwm)->BRKCTL[i >> 1UL] |= (u32BrakeSource & (PWM_BRKCTL_SYSEBEN_Msk | PWM_BRKCTL_SYSLBEN_Msk));
;;;401                    (pwm)->FAILBRK |= (u32BrakeSource & 0xBUL);
;;;402                }
;;;403                else
;;;404                {
;;;405                    (pwm)->BRKCTL[i >> 1UL] |= u32BrakeSource;
;;;406                }
;;;407            }
;;;408    
;;;409            if (u32LevelMask & (1UL << i))
;;;410            {
;;;411                if ((i & 0x1UL) == 0UL)
;;;412                {
;;;413                    //set brake action as high level for even channel
;;;414                    (pwm)->BRKCTL[i >> 1UL] &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
000006  2203              MOVS     r2,#3
000008  468c              MOV      r12,r1                ;388
00000a  0412              LSLS     r2,r2,#16
                  |L31.12|
00000c  2501              MOVS     r5,#1                 ;393
00000e  40a5              LSLS     r5,r5,r4              ;393
000010  4661              MOV      r1,r12                ;393
000012  420d              TST      r5,r1                 ;393
000014  d027              BEQ      |L31.102|
000016  2b81              CMP      r3,#0x81              ;395
000018  d00c              BEQ      |L31.52|
00001a  2b82              CMP      r3,#0x82              ;395
00001c  d00a              BEQ      |L31.52|
00001e  2b88              CMP      r3,#0x88              ;396
000020  d008              BEQ      |L31.52|
000022  492e              LDR      r1,|L31.220|
000024  428b              CMP      r3,r1                 ;397
000026  d005              BEQ      |L31.52|
000028  1c49              ADDS     r1,r1,#1              ;397
00002a  428b              CMP      r3,r1                 ;397
00002c  d002              BEQ      |L31.52|
00002e  1d89              ADDS     r1,r1,#6              ;398
000030  428b              CMP      r3,r1                 ;398
000032  d111              BNE      |L31.88|
                  |L31.52|
000034  0861              LSRS     r1,r4,#1              ;400
000036  0089              LSLS     r1,r1,#2              ;400
000038  180e              ADDS     r6,r1,r0              ;400
00003a  3680              ADDS     r6,r6,#0x80           ;400
00003c  6cb7              LDR      r7,[r6,#0x48]         ;400
00003e  4927              LDR      r1,|L31.220|
000040  317f              ADDS     r1,r1,#0x7f           ;400
000042  4019              ANDS     r1,r1,r3              ;400
000044  430f              ORRS     r7,r7,r1              ;400
000046  64b7              STR      r7,[r6,#0x48]         ;400
000048  4606              MOV      r6,r0                 ;401
00004a  3680              ADDS     r6,r6,#0x80           ;401
00004c  6c77              LDR      r7,[r6,#0x44]         ;401
00004e  210b              MOVS     r1,#0xb               ;401
000050  4019              ANDS     r1,r1,r3              ;401
000052  430f              ORRS     r7,r7,r1              ;401
000054  6477              STR      r7,[r6,#0x44]         ;401
000056  e006              B        |L31.102|
                  |L31.88|
000058  0861              LSRS     r1,r4,#1              ;405
00005a  0089              LSLS     r1,r1,#2              ;405
00005c  1809              ADDS     r1,r1,r0              ;405
00005e  3180              ADDS     r1,r1,#0x80           ;405
000060  6c8e              LDR      r6,[r1,#0x48]         ;405
000062  431e              ORRS     r6,r6,r3              ;405
000064  648e              STR      r6,[r1,#0x48]         ;405
                  |L31.102|
000066  4671              MOV      r1,lr                 ;409
000068  420d              TST      r5,r1                 ;409
00006a  d018              BEQ      |L31.158|
00006c  07e1              LSLS     r1,r4,#31             ;411
00006e  d00c              BEQ      |L31.138|
;;;415                    (pwm)->BRKCTL[i >> 1UL] |= ((3UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;416                }
;;;417                else
;;;418                {
;;;419                    //set brake action as high level for odd channel
;;;420                    (pwm)->BRKCTL[i >> 1UL] &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
000070  0861              LSRS     r1,r4,#1
000072  0089              LSLS     r1,r1,#2
000074  180d              ADDS     r5,r1,r0
000076  3580              ADDS     r5,r5,#0x80
000078  6caf              LDR      r7,[r5,#0x48]
00007a  2603              MOVS     r6,#3
00007c  04b6              LSLS     r6,r6,#18
00007e  43b7              BICS     r7,r7,r6
000080  64af              STR      r7,[r5,#0x48]
;;;421                    (pwm)->BRKCTL[i >> 1UL] |= ((3UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
000082  6ca9              LDR      r1,[r5,#0x48]
000084  4331              ORRS     r1,r1,r6
000086  64a9              STR      r1,[r5,#0x48]
000088  e019              B        |L31.190|
                  |L31.138|
00008a  0861              LSRS     r1,r4,#1              ;414
00008c  0089              LSLS     r1,r1,#2              ;414
00008e  1809              ADDS     r1,r1,r0              ;414
000090  3180              ADDS     r1,r1,#0x80           ;414
000092  6c8d              LDR      r5,[r1,#0x48]         ;414
000094  4395              BICS     r5,r5,r2              ;414
000096  648d              STR      r5,[r1,#0x48]         ;414
000098  6c8d              LDR      r5,[r1,#0x48]         ;415
00009a  4315              ORRS     r5,r5,r2              ;415
00009c  e00e              B        |L31.188|
                  |L31.158|
;;;422                }
;;;423            }
;;;424            else
;;;425            {
;;;426                if ((i & 0x1UL) == 0UL)
00009e  07e1              LSLS     r1,r4,#31
0000a0  d011              BEQ      |L31.198|
;;;427                {
;;;428                    //set brake action as low level for even channel
;;;429                    (pwm)->BRKCTL[i >> 1UL] &= ~PWM_BRKCTL0_1_BRKAEVEN_Msk;
;;;430                    (pwm)->BRKCTL[i >> 1UL] |= ((2UL) << PWM_BRKCTL0_1_BRKAEVEN_Pos);
;;;431                }
;;;432                else
;;;433                {
;;;434                    //set brake action as low level for odd channel
;;;435                    (pwm)->BRKCTL[i >> 1UL] &= ~PWM_BRKCTL0_1_BRKAODD_Msk;
0000a2  0861              LSRS     r1,r4,#1
0000a4  0089              LSLS     r1,r1,#2
0000a6  1809              ADDS     r1,r1,r0
0000a8  3180              ADDS     r1,r1,#0x80
0000aa  6c8d              LDR      r5,[r1,#0x48]
0000ac  2603              MOVS     r6,#3
0000ae  04b6              LSLS     r6,r6,#18
0000b0  43b5              BICS     r5,r5,r6
0000b2  648d              STR      r5,[r1,#0x48]
;;;436                    (pwm)->BRKCTL[i >> 1UL] |= ((2UL) << PWM_BRKCTL0_1_BRKAODD_Pos);
0000b4  6c8d              LDR      r5,[r1,#0x48]
0000b6  2601              MOVS     r6,#1
0000b8  04f6              LSLS     r6,r6,#19
                  |L31.186|
0000ba  4335              ORRS     r5,r5,r6              ;430
                  |L31.188|
0000bc  648d              STR      r5,[r1,#0x48]         ;430
                  |L31.190|
0000be  1c64              ADDS     r4,r4,#1              ;430
0000c0  2c06              CMP      r4,#6                 ;391
0000c2  d3a3              BCC      |L31.12|
;;;437                }
;;;438            }
;;;439        }
;;;440    
;;;441    }
0000c4  bdf0              POP      {r4-r7,pc}
                  |L31.198|
0000c6  0861              LSRS     r1,r4,#1              ;429
0000c8  0089              LSLS     r1,r1,#2              ;429
0000ca  1809              ADDS     r1,r1,r0              ;429
0000cc  3180              ADDS     r1,r1,#0x80           ;429
0000ce  6c8d              LDR      r5,[r1,#0x48]         ;429
0000d0  4395              BICS     r5,r5,r2              ;429
0000d2  648d              STR      r5,[r1,#0x48]         ;429
0000d4  6c8d              LDR      r5,[r1,#0x48]         ;430
0000d6  2601              MOVS     r6,#1                 ;430
0000d8  0476              LSLS     r6,r6,#17             ;430
0000da  e7ee              B        |L31.186|
;;;442    
                          ENDP

                  |L31.220|
                          DCD      0x00008001

                          AREA ||i.PWM_EnableFaultBrakeInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableFaultBrakeInt PROC
;;;715     */
;;;716    void PWM_EnableFaultBrakeInt(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;717    {
;;;718        (pwm)->INTEN1 |= (0x7UL << u32BrakeSource);
000002  6e42              LDR      r2,[r0,#0x64]
000004  2307              MOVS     r3,#7
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6642              STR      r2,[r0,#0x64]
;;;719    }
00000c  4770              BX       lr
;;;720    
                          ENDP


                          AREA ||i.PWM_EnableLoadMode||, CODE, READONLY, ALIGN=1

                  PWM_EnableLoadMode PROC
;;;682     */
;;;683    void PWM_EnableLoadMode(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32LoadMode)
000000  6803              LDR      r3,[r0,#0]
;;;684    {
;;;685        (pwm)->CTL0 |= (u32LoadMode << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  4313              ORRS     r3,r3,r2
000006  6003              STR      r3,[r0,#0]
;;;686    }
000008  4770              BX       lr
;;;687    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;484     */
;;;485    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  3080              ADDS     r0,r0,#0x80
;;;486    {
;;;487        (pwm)->POEN |= u32ChannelMask;
000002  6d82              LDR      r2,[r0,#0x58]
000004  430a              ORRS     r2,r2,r1
000006  6582              STR      r2,[r0,#0x58]
;;;488    }
000008  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.PWM_EnablePDMA||, CODE, READONLY, ALIGN=1

                  PWM_EnablePDMA PROC
;;;1033    */
;;;1034   void PWM_EnablePDMA(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;1035   {
;;;1036       uint32_t u32IsOddCh;
;;;1037       u32IsOddCh = u32ChannelNum % 2UL;
000002  30ff              ADDS     r0,r0,#0xff
000004  07cc              LSLS     r4,r1,#31
000006  30ff              ADDS     r0,r0,#0xff
000008  3002              ADDS     r0,#2
;;;1038       (pwm)->PDMACTL = ((pwm)->PDMACTL & ~((PWM_PDMACTL_CHSEL0_1_Msk | PWM_PDMACTL_CAPORD0_1_Msk | PWM_PDMACTL_CAPMOD0_1_Msk) << ((u32ChannelNum >> 1UL) << 3UL))) | \
00000a  6bc5              LDR      r5,[r0,#0x3c]
00000c  0849              LSRS     r1,r1,#1
00000e  00c9              LSLS     r1,r1,#3
000010  261e              MOVS     r6,#0x1e
000012  408e              LSLS     r6,r6,r1
000014  0ee4              LSRS     r4,r4,#27
000016  00d2              LSLS     r2,r2,#3
000018  4314              ORRS     r4,r4,r2
00001a  431c              ORRS     r4,r4,r3
00001c  2201              MOVS     r2,#1
00001e  4314              ORRS     r4,r4,r2
000020  43b5              BICS     r5,r5,r6
000022  408c              LSLS     r4,r4,r1
000024  4325              ORRS     r5,r5,r4
000026  63c5              STR      r5,[r0,#0x3c]
;;;1039                        (((u32IsOddCh << PWM_PDMACTL_CHSEL0_1_Pos) | (u32RisingFirst << PWM_PDMACTL_CAPORD0_1_Pos) | \
;;;1040                          u32Mode | PWM_PDMACTL_CHEN0_1_Msk) << ((u32ChannelNum >> 1UL) << 3UL));
;;;1041   }
000028  bd70              POP      {r4-r6,pc}
;;;1042   
                          ENDP


                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;777     */
;;;778    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  3080              ADDS     r0,r0,#0x80
;;;779    {
;;;780        (pwm)->INTEN0 |= (PWM_INTEN0_PIEN0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4099              LSLS     r1,r1,r3
00000e  430a              ORRS     r2,r2,r1
000010  6602              STR      r2,[r0,#0x60]
;;;781    }
000012  4770              BX       lr
;;;782    
                          ENDP


                          AREA ||i.PWM_EnableZeroInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableZeroInt PROC
;;;835     */
;;;836    void PWM_EnableZeroInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;837    {
;;;838        (pwm)->INTEN0 |= (PWM_INTEN0_ZIEN0_Msk << ((u32ChannelNum >> 1UL) << 1UL));
000002  6e02              LDR      r2,[r0,#0x60]
000004  084b              LSRS     r3,r1,#1
000006  005b              LSLS     r3,r3,#1
000008  2101              MOVS     r1,#1
00000a  4099              LSLS     r1,r1,r3
00000c  430a              ORRS     r2,r2,r1
00000e  6602              STR      r2,[r0,#0x60]
;;;839    }
000010  4770              BX       lr
;;;840    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;264     */
;;;265    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267        uint32_t i;
;;;268    
;;;269        for (i = 0UL; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;270        {
;;;271            if (u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
                  |L38.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L38.28|
;;;272            {
;;;273                (pwm)->CNTEN &= ~(1UL << ((i >> 1UL) << 1UL));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  439c              BICS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L38.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;269
000020  d3f1              BCC      |L38.6|
;;;274            }
;;;275        }
;;;276    }
000022  bd70              POP      {r4-r6,pc}
;;;277    
                          ENDP


                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetADCTriggerFlag PROC
;;;354     */
;;;355    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;356    {
000002  3001              ADDS     r0,#1
;;;357        return (((pwm)->STATUS & (PWM_STATUS_ADCTRG0_Msk << u32ChannelNum)) ? 1UL : 0UL);
000004  6a00              LDR      r0,[r0,#0x20]
000006  2201              MOVS     r2,#1
000008  0412              LSLS     r2,r2,#16
00000a  408a              LSLS     r2,r2,r1
00000c  4010              ANDS     r0,r0,r2
00000e  d000              BEQ      |L39.18|
000010  2001              MOVS     r0,#1
                  |L39.18|
;;;358    }
000012  4770              BX       lr
;;;359    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;602     */
;;;603    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;604    {
000002  30ff              ADDS     r0,r0,#0xff
000004  3002              ADDS     r0,#2
;;;605        uint32_t u32CapFFlag, u32CapRFlag ;
;;;606        u32CapFFlag = (((pwm)->CAPIF & (PWM_CAPIF_CFLIF0_Msk << u32ChannelNum)) ? 1UL : 0UL) ;
000006  6d42              LDR      r2,[r0,#0x54]
000008  23ff              MOVS     r3,#0xff
00000a  3301              ADDS     r3,#1
00000c  408b              LSLS     r3,r3,r1
00000e  401a              ANDS     r2,r2,r3
000010  d000              BEQ      |L40.20|
000012  2201              MOVS     r2,#1
                  |L40.20|
;;;607        u32CapRFlag = (((pwm)->CAPIF & (PWM_CAPIF_CRLIF0_Msk << u32ChannelNum)) ? 1UL : 0UL) ;
000014  6d40              LDR      r0,[r0,#0x54]
000016  2301              MOVS     r3,#1
000018  408b              LSLS     r3,r3,r1
00001a  4218              TST      r0,r3
00001c  d001              BEQ      |L40.34|
00001e  2101              MOVS     r1,#1
000020  e000              B        |L40.36|
                  |L40.34|
000022  2100              MOVS     r1,#0
                  |L40.36|
;;;608        return ((u32CapFFlag << 1UL) | u32CapRFlag);
000024  0050              LSLS     r0,r2,#1
000026  4308              ORRS     r0,r0,r1
;;;609    }
000028  4770              BX       lr
;;;610    /**
                          ENDP


                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_GetDutyIntFlag PROC
;;;665     */
;;;666    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;667    {
;;;668        return ((((pwm)->INTSTS0 & ((PWM_INTSTS0_CMPDIF0_Msk | PWM_INTSTS0_CMPUIF0_Msk) << u32ChannelNum))) ? 1 : 0);
000002  6e80              LDR      r0,[r0,#0x68]
000004  4a02              LDR      r2,|L41.16|
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L41.14|
00000c  2001              MOVS     r0,#1
                  |L41.14|
;;;669    }
00000e  4770              BX       lr
;;;670    
                          ENDP

                  |L41.16|
                          DCD      0x01010000

                          AREA ||i.PWM_GetFaultBrakeIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetFaultBrakeIntFlag PROC
;;;762     */
;;;763    uint32_t PWM_GetFaultBrakeIntFlag(PWM_T *pwm, uint32_t u32BrakeSource)
000000  3080              ADDS     r0,r0,#0x80
;;;764    {
;;;765        return (((pwm)->INTSTS1 & (0x3fUL << u32BrakeSource)) ? 1UL : 0UL);
000002  6ec0              LDR      r0,[r0,#0x6c]
000004  223f              MOVS     r2,#0x3f
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L42.14|
00000c  2001              MOVS     r0,#1
                  |L42.14|
;;;766    }
00000e  4770              BX       lr
;;;767    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;821     */
;;;822    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;823    {
;;;824        return (((pwm)->INTSTS0 & (PWM_INTSTS0_PIF0_Msk << ((u32ChannelNum >> 1UL) << 1UL))) ? 1UL : 0UL);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  21ff              MOVS     r1,#0xff
00000a  3101              ADDS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L43.20|
000012  2001              MOVS     r0,#1
                  |L43.20|
;;;825    }
000014  4770              BX       lr
;;;826    
                          ENDP


                          AREA ||i.PWM_GetWrapAroundFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetWrapAroundFlag PROC
;;;999     */
;;;1000   uint32_t PWM_GetWrapAroundFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  30ff              ADDS     r0,r0,#0xff
;;;1001   {
000002  3001              ADDS     r0,#1
;;;1002       return (((pwm)->STATUS & (PWM_STATUS_CNTMAX0_Msk << ((u32ChannelNum >> 1UL) << 1UL))) ? 1UL : 0UL);
000004  6a00              LDR      r0,[r0,#0x20]
000006  084a              LSRS     r2,r1,#1
000008  0052              LSLS     r2,r2,#1
00000a  2101              MOVS     r1,#1
00000c  4091              LSLS     r1,r1,r2
00000e  4008              ANDS     r0,r0,r1
000010  d000              BEQ      |L44.20|
000012  2001              MOVS     r0,#1
                  |L44.20|
;;;1003   }
000014  4770              BX       lr
;;;1004   
                          ENDP


                          AREA ||i.PWM_GetZeroIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetZeroIntFlag PROC
;;;879     */
;;;880    uint32_t PWM_GetZeroIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;881    {
;;;882        return (((pwm)->INTSTS0 & (PWM_INTSTS0_ZIF0_Msk << ((u32ChannelNum >> 1UL) << 1UL))) ? 1UL : 0UL);
000002  6e80              LDR      r0,[r0,#0x68]
000004  084a              LSRS     r2,r1,#1
000006  0052              LSLS     r2,r2,#1
000008  2101              MOVS     r1,#1
00000a  4091              LSLS     r1,r1,r2
00000c  4008              ANDS     r0,r0,r1
00000e  d000              BEQ      |L45.18|
000010  2001              MOVS     r0,#1
                  |L45.18|
;;;883    }
000012  4770              BX       lr
;;;884    
                          ENDP


                          AREA ||i.PWM_SetBrakePinSource||, CODE, READONLY, ALIGN=1

                  PWM_SetBrakePinSource PROC
;;;983     */
;;;984    void PWM_SetBrakePinSource(PWM_T *pwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule)
000000  b510              PUSH     {r4,lr}
;;;985    {
000002  3080              ADDS     r0,r0,#0x80
;;;986        (pwm)->BNF = ((pwm)->BNF & ~(PWM_BNF_BK0SRC_Msk << (u32BrakePinNum << 3UL))) | (u32SelAnotherModule << (PWM_BNF_BK0SRC_Pos + (u32BrakePinNum << 3UL)));
000004  6c03              LDR      r3,[r0,#0x40]
000006  00c9              LSLS     r1,r1,#3
000008  2401              MOVS     r4,#1
00000a  0424              LSLS     r4,r4,#16
00000c  408c              LSLS     r4,r4,r1
00000e  3110              ADDS     r1,r1,#0x10
000010  43a3              BICS     r3,r3,r4
000012  408a              LSLS     r2,r2,r1
000014  4313              ORRS     r3,r3,r2
000016  6403              STR      r3,[r0,#0x40]
;;;987    }
000018  bd10              POP      {r4,pc}
;;;988    
                          ENDP


                          AREA ||i.PWM_SetClockSource||, CODE, READONLY, ALIGN=1

                  PWM_SetClockSource PROC
;;;900     */
;;;901    void PWM_SetClockSource(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel)
000000  b510              PUSH     {r4,lr}
;;;902    {
;;;903        (pwm)->CLKSRC = ((pwm)->CLKSRC & ~(PWM_CLKSRC_ECLKSRC0_Msk << ((u32ChannelNum >> 1UL) * PWM_CLKSRC_ECLKSRC2_Pos))) | \
000002  6903              LDR      r3,[r0,#0x10]
000004  0849              LSRS     r1,r1,#1
000006  00c9              LSLS     r1,r1,#3
000008  2407              MOVS     r4,#7
00000a  408c              LSLS     r4,r4,r1
00000c  43a3              BICS     r3,r3,r4
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  6103              STR      r3,[r0,#0x10]
;;;904                        (u32ClkSrcSel << ((u32ChannelNum >> 1UL) * PWM_CLKSRC_ECLKSRC2_Pos));
;;;905    }
000014  bd10              POP      {r4,pc}
;;;906    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;216     */
;;;217    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
;;;219        uint32_t i;
;;;220    
;;;221        for (i = 0UL; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;222        {
;;;223            if (u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
                  |L48.6|
000006  462b              MOV      r3,r5
000008  4093              LSLS     r3,r3,r2
00000a  420b              TST      r3,r1
00000c  d006              BEQ      |L48.28|
;;;224            {
;;;225                (pwm)->CNTEN |= (1UL << ((i >> 1UL) << 1UL));
00000e  6a04              LDR      r4,[r0,#0x20]
000010  0856              LSRS     r6,r2,#1
000012  0076              LSLS     r6,r6,#1
000014  462b              MOV      r3,r5
000016  40b3              LSLS     r3,r3,r6
000018  431c              ORRS     r4,r4,r3
00001a  6204              STR      r4,[r0,#0x20]
                  |L48.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  2a06              CMP      r2,#6                 ;221
000020  d3f1              BCC      |L48.6|
;;;226            }
;;;227        }
;;;228    }
000022  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;240     */
;;;241    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;242    {
;;;243        uint32_t i;
;;;244    
;;;245        for (i = 0UL; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;246        {
;;;247            if (u32ChannelMask & (1UL << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L49.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L49.24|
;;;248            {
;;;249                (pwm)->PERIOD[((i >> 1UL) << 1UL)] = 0UL;
000010  0853              LSRS     r3,r2,#1
000012  00db              LSLS     r3,r3,#3
000014  181b              ADDS     r3,r3,r0
000016  631c              STR      r4,[r3,#0x30]
                  |L49.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a06              CMP      r2,#6                 ;245
00001c  d3f4              BCC      |L49.8|
;;;250            }
;;;251        }
;;;252    }
00001e  bd30              POP      {r4,r5,pc}
;;;253    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 402
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
