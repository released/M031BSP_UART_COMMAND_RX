; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\i2c.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\i2c.crf ..\..\..\Library\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;97       */
;;;98     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;99     {
;;;100        i2c->TOCTL |= I2C_TOCTL_TOIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;101    }
000008  4770              BX       lr
;;;102    
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;69     
;;;70     void I2C_Close(I2C_T *i2c)
000000  4a0a              LDR      r2,|L2.44|
;;;71     {
;;;72         /* Reset I2C Controller */
;;;73         if (i2c == I2C0)
;;;74         {
;;;75             SYS->IPRST1 |= SYS_IPRST1_I2C0RST_Msk;
000002  02d1              LSLS     r1,r2,#11
000004  4290              CMP      r0,r2                 ;73
000006  d102              BNE      |L2.14|
000008  68cb              LDR      r3,[r1,#0xc]
00000a  1582              ASRS     r2,r0,#22
;;;76             SYS->IPRST1 &= ~SYS_IPRST1_I2C0RST_Msk;
00000c  e004              B        |L2.24|
                  |L2.14|
;;;77         }
;;;78         else if (i2c == I2C1)
00000e  4a08              LDR      r2,|L2.48|
000010  4290              CMP      r0,r2
000012  d106              BNE      |L2.34|
;;;79         {
;;;80             SYS->IPRST1 |= SYS_IPRST1_I2C1RST_Msk;
000014  68cb              LDR      r3,[r1,#0xc]
000016  1542              ASRS     r2,r0,#21
                  |L2.24|
000018  4313              ORRS     r3,r3,r2
00001a  60cb              STR      r3,[r1,#0xc]
;;;81             SYS->IPRST1 &= ~SYS_IPRST1_I2C1RST_Msk;
00001c  68cb              LDR      r3,[r1,#0xc]
00001e  4393              BICS     r3,r3,r2
000020  60cb              STR      r3,[r1,#0xc]
                  |L2.34|
;;;82         }
;;;83     
;;;84         /* Disable I2C */
;;;85         i2c->CTL0 &= ~I2C_CTL0_I2CEN_Msk;
000022  6801              LDR      r1,[r0,#0]
000024  2240              MOVS     r2,#0x40
000026  4391              BICS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;86     }
00002a  4770              BX       lr
;;;87     
                          ENDP

                  |L2.44|
                          DCD      0x40080000
                  |L2.48|
                          DCD      0x40081000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;153      */
;;;154    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;155    {
;;;156        i2c->CTL0 &= ~I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;157    }
000008  4770              BX       lr
;;;158    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;394     */
;;;395    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;396    {
;;;397        i2c->TOCTL &= ~I2C_TOCTL_TOCEN_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;398    }
000008  4770              BX       lr
;;;399    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;424     */
;;;425    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;426    {
;;;427        i2c->WKCTL &= ~I2C_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;428    }
000008  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;168      */
;;;169    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171        i2c->CTL0 |= I2C_CTL0_INTEN_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;172    }
000008  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;370     */
;;;371    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;372    {
;;;373        if (u8LongTimeout)
000002  2900              CMP      r1,#0
;;;374        {
;;;375            i2c->TOCTL |= I2C_TOCTL_TOCDIV4_Msk;
;;;376        }
;;;377        else
;;;378        {
;;;379            i2c->TOCTL &= ~I2C_TOCTL_TOCDIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;375
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;380        }
;;;381    
;;;382        i2c->TOCTL |= I2C_TOCTL_TOCEN_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;383    }
000018  4770              BX       lr
;;;384    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;409     */
;;;410    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;411    {
;;;412        i2c->WKCTL |= I2C_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;413    }
000008  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;182     */
;;;183    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        uint32_t u32Divider = i2c->CLKDIV;
000002  6904              LDR      r4,[r0,#0x10]
;;;186        uint32_t u32Pclk;
;;;187    
;;;188        if (i2c == I2C1)
000004  4906              LDR      r1,|L9.32|
000006  4288              CMP      r0,r1
000008  d102              BNE      |L9.16|
;;;189        {
;;;190            u32Pclk = CLK_GetPCLK1Freq();
00000a  f7fffffe          BL       CLK_GetPCLK1Freq
00000e  e001              B        |L9.20|
                  |L9.16|
;;;191        }
;;;192        else
;;;193        {
;;;194            u32Pclk = CLK_GetPCLK0Freq();
000010  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L9.20|
;;;195        }
;;;196    
;;;197        return (u32Pclk / ((u32Divider + 1U) << 2U));
000014  00a1              LSLS     r1,r4,#2
000016  1d09              ADDS     r1,r1,#4
000018  f7fffffe          BL       __aeabi_uidivmod
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40081000

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;266     */
;;;267    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;268    {
;;;269        return (uint8_t)(i2c->DAT);
000002  b2c0              UXTB     r0,r0
;;;270    }
000004  4770              BX       lr
;;;271    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;238     */
;;;239    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;240    {
;;;241        return ((i2c->CTL0 & I2C_CTL0_SI_Msk) == I2C_CTL0_SI_Msk ? 1U : 0U);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;242    }
000006  4770              BX       lr
;;;243    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;252     */
;;;253    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;254    {
;;;255        return (i2c->STATUS0);
;;;256    }
000002  4770              BX       lr
;;;257    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;35       */
;;;36     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;37     {
000002  4605              MOV      r5,r0
;;;38         uint32_t u32Div;
;;;39         uint32_t u32Pclk;
;;;40     
;;;41         if (i2c == I2C1)
000004  480f              LDR      r0,|L13.68|
000006  460e              MOV      r6,r1                 ;37
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L13.18|
;;;42         {
;;;43             u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L13.22|
                  |L13.18|
;;;44         }
;;;45         else
;;;46         {
;;;47             u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L13.22|
000016  4604              MOV      r4,r0
;;;48         }
;;;49     
;;;50         u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;51         i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;52     
;;;53         /* Enable I2C */
;;;54         i2c->CTL0 |= I2C_CTL0_I2CEN_Msk;
00002e  6829              LDR      r1,[r5,#0]
000030  2240              MOVS     r2,#0x40
000032  4311              ORRS     r1,r1,r2
000034  6029              STR      r1,[r5,#0]
;;;55     
;;;56         return (u32Pclk / ((u32Div + 1U) << 2U));
000036  0081              LSLS     r1,r0,#2
000038  4620              MOV      r0,r4
00003a  1d09              ADDS     r1,r1,#4
00003c  f7fffffe          BL       __aeabi_uidivmod
;;;57     }
000040  bd70              POP      {r4-r6,pc}
;;;58     
                          ENDP

000042  0000              DCW      0x0000
                  |L13.68|
                          DCD      0x40081000

                          AREA ||i.I2C_ReadByte||, CODE, READONLY, ALIGN=1

                  I2C_ReadByte PROC
;;;854      */
;;;855    uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;856    {
;;;857        uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2300              MOVS     r3,#0
;;;858    
;;;859        I2C_START(i2c);                                          /* Send START */
000006  6802              LDR      r2,[r0,#0]
000008  461c              MOV      r4,r3                 ;857
00000a  2628              MOVS     r6,#0x28
00000c  4332              ORRS     r2,r2,r6
00000e  6002              STR      r2,[r0,#0]
;;;860    
;;;861        while (u8Xfering && (u8Err == 0U))
;;;862        {
;;;863            I2C_WAIT_READY(i2c) {}
;;;864    
;;;865            switch (I2C_GET_STATUS(i2c))
;;;866            {
;;;867            case 0x08:
;;;868                I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;869                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;870                break;
;;;871    
;;;872            case 0x40:                                           /* Slave Address ACK */
;;;873                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;874                break;
;;;875    
;;;876            case 0x48:                                           /* Slave Address NACK */
;;;877                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;878                u8Err = 1U;
;;;879                break;
;;;880    
;;;881            case 0x58:
;;;882                rdata = (uint8_t) I2C_GET_DATA(i2c);       /* Receive Data */
;;;883                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;884                u8Xfering = 0U;
;;;885                break;
;;;886    
;;;887            case 0x38:                                           /* Arbitration Lost */
;;;888            default:                                             /* Unknow status */
;;;889                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L14.18|
000012  6802              LDR      r2,[r0,#0]            ;863
000014  0712              LSLS     r2,r2,#28             ;863
000016  d5fc              BPL      |L14.18|
000018  68c2              LDR      r2,[r0,#0xc]          ;865
00001a  2a08              CMP      r2,#8                 ;865
00001c  d00b              BEQ      |L14.54|
00001e  2a40              CMP      r2,#0x40              ;865
000020  d00d              BEQ      |L14.62|
000022  2a48              CMP      r2,#0x48              ;865
000024  d00d              BEQ      |L14.66|
000026  2a58              CMP      r2,#0x58              ;865
000028  d00e              BEQ      |L14.72|
00002a  6802              LDR      r2,[r0,#0]
00002c  43b2              BICS     r2,r2,r6
00002e  3218              ADDS     r2,r2,#0x18
000030  6002              STR      r2,[r0,#0]
;;;890                u8Ctrl = I2C_CTL_SI;
000032  2208              MOVS     r2,#8
;;;891                u8Err = 1U;
;;;892                break;
000034  e006              B        |L14.68|
                  |L14.54|
000036  004a              LSLS     r2,r1,#1              ;868
000038  1c52              ADDS     r2,r2,#1              ;868
00003a  b2d2              UXTB     r2,r2                 ;868
00003c  6082              STR      r2,[r0,#8]            ;868
                  |L14.62|
00003e  2208              MOVS     r2,#8                 ;873
000040  e006              B        |L14.80|
                  |L14.66|
000042  2218              MOVS     r2,#0x18              ;877
                  |L14.68|
000044  2301              MOVS     r3,#1                 ;878
000046  e003              B        |L14.80|
                  |L14.72|
000048  6882              LDR      r2,[r0,#8]            ;882
00004a  b2d4              UXTB     r4,r2                 ;882
00004c  2218              MOVS     r2,#0x18              ;883
00004e  2500              MOVS     r5,#0                 ;884
                  |L14.80|
;;;893            }
;;;894    
;;;895            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000050  6807              LDR      r7,[r0,#0]
000052  43b7              BICS     r7,r7,r6
000054  4317              ORRS     r7,r7,r2
000056  6007              STR      r7,[r0,#0]
000058  2d00              CMP      r5,#0                 ;861
00005a  d002              BEQ      |L14.98|
00005c  2b00              CMP      r3,#0                 ;861
00005e  d0d8              BEQ      |L14.18|
000060  e001              B        |L14.102|
                  |L14.98|
;;;896        }
;;;897    
;;;898        if (u8Err)
000062  2b00              CMP      r3,#0
000064  d000              BEQ      |L14.104|
                  |L14.102|
;;;899            rdata = 0U;                                           /* If occurs error, return 0 */
000066  2400              MOVS     r4,#0
                  |L14.104|
;;;900    
;;;901        return rdata;                                            /* Return read data */
000068  4620              MOV      r0,r4
;;;902    }
00006a  bdf0              POP      {r4-r7,pc}
;;;903    /**
                          ENDP


                          AREA ||i.I2C_ReadByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteOneReg PROC
;;;991      */
;;;992    uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;993    {
;;;994        uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2400              MOVS     r4,#0
;;;995    
;;;996        I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  4625              MOV      r5,r4                 ;994
00000a  4622              MOV      r2,r4                 ;994
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;997    
;;;998        while (u8Xfering && (u8Err == 0U))
;;;999        {
;;;1000           I2C_WAIT_READY(i2c) {}
;;;1001   
;;;1002           switch (I2C_GET_STATUS(i2c))
;;;1003           {
;;;1004           case 0x08:
;;;1005               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L15.20|
000014  6801              LDR      r1,[r0,#0]            ;1000
000016  0709              LSLS     r1,r1,#28             ;1000
000018  d5fc              BPL      |L15.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1002
00001c  074b              LSLS     r3,r1,#29             ;1002
00001e  0f5b              LSRS     r3,r3,#29             ;1002
000020  d127              BNE      |L15.114|
000022  10c9              ASRS     r1,r1,#3              ;1002
000024  000b              MOVS     r3,r1                 ;1002
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c24              DCB      0x0c,0x24
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c2414          DCB      0x0f,0x0c,0x24,0x14
000034  0c241624          DCB      0x0c,0x24,0x16,0x24
000038  b2f9              UXTB     r1,r7
;;;1006               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1007               break;
00003a  e009              B        |L15.80|
;;;1008   
;;;1009           case 0x18:                                           /* Slave Address ACK */
;;;1010               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1011               break;
000040  e00d              B        |L15.94|
;;;1012   
;;;1013           case 0x20:                                           /* Slave Address NACK */
;;;1014           case 0x30:                                           /* Master transmit data NACK */
;;;1015               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L15.68|
;;;1016               u8Err = 1U;
000044  2401              MOVS     r4,#1
000046  e00a              B        |L15.94|
;;;1017               break;
;;;1018   
;;;1019           case 0x28:
;;;1020               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1021               break;
00004a  e008              B        |L15.94|
;;;1022   
;;;1023           case 0x10:
;;;1024               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L15.80|
000050  6081              STR      r1,[r0,#8]            ;1005
;;;1025               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1026               break;
;;;1027   
;;;1028           case 0x40:                                           /* Slave Address ACK */
;;;1029               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
000052  2208              MOVS     r2,#8
;;;1030               break;
000054  e003              B        |L15.94|
;;;1031   
;;;1032           case 0x48:                                           /* Slave Address NACK */
;;;1033               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1034               u8Err = 1U;
;;;1035               break;
;;;1036   
;;;1037           case 0x58:
;;;1038               rdata = (uint8_t) I2C_GET_DATA(i2c);             /* Receive Data */
000056  6881              LDR      r1,[r0,#8]
;;;1039               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000058  2218              MOVS     r2,#0x18
00005a  b2cd              UXTB     r5,r1                 ;1038
;;;1040               u8Xfering = 0U;
00005c  2600              MOVS     r6,#0
                  |L15.94|
;;;1041               break;
;;;1042   
;;;1043           case 0x38:                                           /* Arbitration Lost */
;;;1044           default:                                             /* Unknow status */
;;;1045               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1046               u8Ctrl = I2C_CTL_SI;
;;;1047               u8Err = 1U;
;;;1048               break;
;;;1049           }
;;;1050   
;;;1051           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
00005e  6801              LDR      r1,[r0,#0]
000060  233c              MOVS     r3,#0x3c
000062  4399              BICS     r1,r1,r3
000064  4311              ORRS     r1,r1,r2
000066  6001              STR      r1,[r0,#0]
000068  2e00              CMP      r6,#0                 ;998
00006a  d009              BEQ      |L15.128|
00006c  2c00              CMP      r4,#0                 ;998
00006e  d0d1              BEQ      |L15.20|
000070  e008              B        |L15.132|
                  |L15.114|
000072  6801              LDR      r1,[r0,#0]            ;1045
000074  223c              MOVS     r2,#0x3c              ;1045
000076  4391              BICS     r1,r1,r2              ;1045
000078  3118              ADDS     r1,r1,#0x18           ;1045
00007a  6001              STR      r1,[r0,#0]            ;1045
00007c  2208              MOVS     r2,#8                 ;1046
00007e  e7e1              B        |L15.68|
                  |L15.128|
;;;1052       }
;;;1053   
;;;1054       if (u8Err)
000080  2c00              CMP      r4,#0
000082  d000              BEQ      |L15.134|
                  |L15.132|
;;;1055           rdata = 0U;                                           /* If occurs error, return 0 */
000084  2500              MOVS     r5,#0
                  |L15.134|
;;;1056   
;;;1057       return rdata;                                            /* Return read data */
000086  4628              MOV      r0,r5
;;;1058   }
000088  bdfe              POP      {r1-r7,pc}
;;;1059   
                          ENDP


                          AREA ||i.I2C_ReadByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadByteTwoRegs PROC
;;;1163     */
;;;1164   uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1165   {
;;;1166       uint8_t u8Xfering = 1U, u8Err = 0U, rdata = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1165
000006  2400              MOVS     r4,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1167   
;;;1168       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  4625              MOV      r5,r4                 ;1166
000010  4622              MOV      r2,r4                 ;1166
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1169   
;;;1170       while (u8Xfering && (u8Err == 0U))
;;;1171       {
;;;1172           I2C_WAIT_READY(i2c) {}
;;;1173   
;;;1174           switch (I2C_GET_STATUS(i2c))
;;;1175           {
;;;1176           case 0x08:
;;;1177               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L16.26|
00001a  6801              LDR      r1,[r0,#0]            ;1172
00001c  0709              LSLS     r1,r1,#28             ;1172
00001e  d5fc              BPL      |L16.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1174
000022  074b              LSLS     r3,r1,#29             ;1174
000024  0f5b              LSRS     r3,r3,#29             ;1174
000026  d131              BNE      |L16.140|
000028  10c9              ASRS     r1,r1,#3              ;1174
00002a  000b              MOVS     r3,r1                 ;1174
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c2e0719          DCB      0x0c,0x2e,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  2e1c0d2e          DCB      0x2e,0x1c,0x0d,0x2e
00003c  1e2e              DCB      0x1e,0x2e
00003e  b2f9              UXTB     r1,r7
;;;1178               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1179               break;
000040  e011              B        |L16.102|
;;;1180   
;;;1181           case 0x18:                                                    /* Slave Address ACK */
;;;1182               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1183               break;
000048  e015              B        |L16.118|
;;;1184   
;;;1185           case 0x20:                                                    /* Slave Address NACK */
;;;1186           case 0x30:                                                    /* Master transmit data NACK */
;;;1187               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L16.76|
;;;1188               u8Err = 1U;
00004c  2401              MOVS     r4,#1
00004e  e012              B        |L16.118|
;;;1189               break;
;;;1190   
;;;1191           case 0x28:
;;;1192               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L16.94|
;;;1193               {
;;;1194                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1195                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e00b              B        |L16.118|
                  |L16.94|
;;;1196               }
;;;1197               else
;;;1198                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e009              B        |L16.118|
;;;1199   
;;;1200               break;
;;;1201   
;;;1202           case 0x10:
;;;1203               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L16.102|
000066  6081              STR      r1,[r0,#8]            ;1177
;;;1204               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1205               break;
;;;1206   
;;;1207           case 0x40:                                                    /* Slave Address ACK */
;;;1208               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
000068  2208              MOVS     r2,#8
;;;1209               break;
00006a  e004              B        |L16.118|
;;;1210   
;;;1211           case 0x48:                                                    /* Slave Address NACK */
;;;1212               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1213               u8Err = 1U;
;;;1214               break;
;;;1215   
;;;1216           case 0x58:
;;;1217               rdata = (uint8_t) I2C_GET_DATA(i2c);                /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
;;;1218               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00006e  2218              MOVS     r2,#0x18
000070  b2cd              UXTB     r5,r1                 ;1217
;;;1219               u8Xfering = 0U;
000072  2100              MOVS     r1,#0
000074  9100              STR      r1,[sp,#0]
                  |L16.118|
;;;1220               break;
;;;1221   
;;;1222           case 0x38:                                                    /* Arbitration Lost */
;;;1223           default:                                                      /* Unknow status */
;;;1224               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1225               u8Ctrl = I2C_CTL_SI;
;;;1226               u8Err = 1U;
;;;1227               break;
;;;1228           }
;;;1229   
;;;1230           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000076  6801              LDR      r1,[r0,#0]
000078  233c              MOVS     r3,#0x3c
00007a  4399              BICS     r1,r1,r3
00007c  4311              ORRS     r1,r1,r2
00007e  6001              STR      r1,[r0,#0]
000080  9900              LDR      r1,[sp,#0]            ;1170
000082  2900              CMP      r1,#0                 ;1170
000084  d009              BEQ      |L16.154|
000086  2c00              CMP      r4,#0                 ;1170
000088  d0c7              BEQ      |L16.26|
00008a  e008              B        |L16.158|
                  |L16.140|
00008c  6801              LDR      r1,[r0,#0]            ;1224
00008e  223c              MOVS     r2,#0x3c              ;1224
000090  4391              BICS     r1,r1,r2              ;1224
000092  3118              ADDS     r1,r1,#0x18           ;1224
000094  6001              STR      r1,[r0,#0]            ;1224
000096  2208              MOVS     r2,#8                 ;1225
000098  e7d8              B        |L16.76|
                  |L16.154|
;;;1231       }
;;;1232   
;;;1233       if (u8Err)
00009a  2c00              CMP      r4,#0
00009c  d000              BEQ      |L16.160|
                  |L16.158|
;;;1234           rdata = 0U;                                                    /* If occurs error, return 0 */
00009e  2500              MOVS     r5,#0
                  |L16.160|
;;;1235   
;;;1236       return rdata;                                                     /* Return read data */
0000a0  4628              MOV      r0,r5
;;;1237   }
0000a2  b004              ADD      sp,sp,#0x10
0000a4  bdf0              POP      {r4-r7,pc}
;;;1238   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytes PROC
;;;916      */
;;;917    uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;918    {
000002  468c              MOV      r12,r1
;;;919        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  2600              MOVS     r6,#0
;;;920        uint32_t u32rxLen = 0U;
;;;921    
;;;922        I2C_START(i2c);                                          /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  469e              MOV      lr,r3                 ;918
00000c  4634              MOV      r4,r6                 ;920
00000e  2528              MOVS     r5,#0x28
000010  4329              ORRS     r1,r1,r5
000012  6001              STR      r1,[r0,#0]
;;;923    
;;;924        while (u8Xfering && (u8Err == 0U))
;;;925        {
;;;926            I2C_WAIT_READY(i2c) {}
;;;927    
;;;928            switch (I2C_GET_STATUS(i2c))
;;;929            {
;;;930            case 0x08:
;;;931                I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
;;;932                u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;933                break;
;;;934    
;;;935            case 0x40:                                           /* Slave Address ACK */
;;;936                u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;937                break;
;;;938    
;;;939            case 0x48:                                           /* Slave Address NACK */
;;;940                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;941                u8Err = 1;
;;;942                break;
;;;943    
;;;944            case 0x50:
;;;945                rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;946    
;;;947                if (u32rxLen < (u32rLen - 1))
;;;948                {
;;;949                    u8Ctrl = I2C_CTL_SI_AA;                             /* Clear SI and set ACK */
;;;950                }
;;;951                else
;;;952                {
;;;953                    u8Ctrl = I2C_CTL_SI;                                /* Clear SI */
;;;954                }
;;;955    
;;;956                break;
;;;957    
;;;958            case 0x58:
;;;959                rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);  /* Receive Data */
;;;960                u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;961                u8Xfering = 0U;
;;;962                break;
;;;963    
;;;964            case 0x38:                                                  /* Arbitration Lost */
;;;965            default:                                                    /* Unknow status */
;;;966                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);               /* Clear SI and send STOP */
000014  213c              MOVS     r1,#0x3c
                  |L17.22|
000016  6805              LDR      r5,[r0,#0]            ;926
000018  072d              LSLS     r5,r5,#28             ;926
00001a  d5fc              BPL      |L17.22|
00001c  68c5              LDR      r5,[r0,#0xc]          ;928
00001e  2d48              CMP      r5,#0x48              ;928
000020  d015              BEQ      |L17.78|
000022  dc04              BGT      |L17.46|
000024  2d08              CMP      r5,#8                 ;928
000026  d00c              BEQ      |L17.66|
000028  2d40              CMP      r5,#0x40              ;928
00002a  d104              BNE      |L17.54|
00002c  e019              B        |L17.98|
                  |L17.46|
00002e  2d50              CMP      r5,#0x50              ;928
000030  d010              BEQ      |L17.84|
000032  2d58              CMP      r5,#0x58              ;928
000034  d019              BEQ      |L17.106|
                  |L17.54|
000036  6805              LDR      r5,[r0,#0]
000038  438d              BICS     r5,r5,r1
00003a  3518              ADDS     r5,r5,#0x18
00003c  6005              STR      r5,[r0,#0]
;;;967                u8Ctrl = I2C_CTL_SI;
00003e  2508              MOVS     r5,#8
;;;968                u8Err = 1U;
;;;969                break;
000040  e006              B        |L17.80|
                  |L17.66|
000042  4663              MOV      r3,r12                ;931
000044  005d              LSLS     r5,r3,#1              ;931
000046  1c6d              ADDS     r5,r5,#1              ;931
000048  b2ed              UXTB     r5,r5                 ;931
00004a  6085              STR      r5,[r0,#8]            ;931
00004c  e00b              B        |L17.102|
                  |L17.78|
00004e  2518              MOVS     r5,#0x18              ;940
                  |L17.80|
000050  2601              MOVS     r6,#1                 ;941
000052  e00f              B        |L17.116|
                  |L17.84|
000054  6885              LDR      r5,[r0,#8]            ;945
000056  5515              STRB     r5,[r2,r4]            ;945
000058  4673              MOV      r3,lr                 ;947
00005a  1e5b              SUBS     r3,r3,#1              ;947
00005c  1c64              ADDS     r4,r4,#1              ;947
00005e  429c              CMP      r4,r3                 ;947
000060  d201              BCS      |L17.102|
                  |L17.98|
000062  250c              MOVS     r5,#0xc               ;949
000064  e006              B        |L17.116|
                  |L17.102|
000066  2508              MOVS     r5,#8                 ;953
000068  e004              B        |L17.116|
                  |L17.106|
00006a  6885              LDR      r5,[r0,#8]            ;959
00006c  5515              STRB     r5,[r2,r4]            ;959
00006e  2518              MOVS     r5,#0x18              ;960
000070  2700              MOVS     r7,#0                 ;961
000072  1c64              ADDS     r4,r4,#1              ;961
                  |L17.116|
;;;970            }
;;;971    
;;;972            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                           /* Write controlbit to I2C_CTL register */
000074  6803              LDR      r3,[r0,#0]
000076  438b              BICS     r3,r3,r1
000078  431d              ORRS     r5,r5,r3
00007a  6005              STR      r5,[r0,#0]
00007c  2f00              CMP      r7,#0                 ;924
00007e  d001              BEQ      |L17.132|
000080  2e00              CMP      r6,#0                 ;924
000082  d0c8              BEQ      |L17.22|
                  |L17.132|
;;;973        }
;;;974    
;;;975        return u32rxLen;                                                /* Return bytes length that have been received */
000084  4620              MOV      r0,r4
;;;976    }
000086  bdf0              POP      {r4-r7,pc}
;;;977    
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesOneReg PROC
;;;1074     */
;;;1075   uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1076   {
;;;1077       uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2601              MOVS     r6,#1
000004  2500              MOVS     r5,#0
;;;1078       uint32_t u32rxLen = 0U;
;;;1079   
;;;1080       I2C_START(i2c);                                          /* Send START */
000006  6803              LDR      r3,[r0,#0]
000008  462a              MOV      r2,r5                 ;1077
00000a  462c              MOV      r4,r5                 ;1078
00000c  2728              MOVS     r7,#0x28
00000e  433b              ORRS     r3,r3,r7
000010  6003              STR      r3,[r0,#0]
;;;1081   
;;;1082       while (u8Xfering && (u8Err == 0U))
;;;1083       {
;;;1084           I2C_WAIT_READY(i2c) {}
;;;1085   
;;;1086           switch (I2C_GET_STATUS(i2c))
;;;1087           {
;;;1088           case 0x08:
;;;1089               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
000012  004f              LSLS     r7,r1,#1
                  |L18.20|
000014  6801              LDR      r1,[r0,#0]            ;1084
000016  0709              LSLS     r1,r1,#28             ;1084
000018  d5fc              BPL      |L18.20|
00001a  68c1              LDR      r1,[r0,#0xc]          ;1086
00001c  074b              LSLS     r3,r1,#29             ;1086
00001e  0f5b              LSRS     r3,r3,#29             ;1086
000020  d136              BNE      |L18.144|
000022  10c9              ASRS     r1,r1,#3              ;1086
000024  000b              MOVS     r3,r1                 ;1086
000026  f7fffffe          BL       __ARM_common_switch8
00002a  0c33              DCB      0x0c,0x33
00002c  0711090c          DCB      0x07,0x11,0x09,0x0c
000030  0f0c331d          DCB      0x0f,0x0c,0x33,0x1d
000034  0c152133          DCB      0x0c,0x15,0x21,0x33
000038  b2f9              UXTB     r1,r7
;;;1090               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1091               break;
00003a  e009              B        |L18.80|
;;;1092   
;;;1093           case 0x18:                                           /* Slave Address ACK */
;;;1094               I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
00003c  9902              LDR      r1,[sp,#8]
00003e  6081              STR      r1,[r0,#8]
;;;1095               break;
000040  e01a              B        |L18.120|
;;;1096   
;;;1097           case 0x20:                                           /* Slave Address NACK */
;;;1098           case 0x30:                                           /* Master transmit data NACK */
;;;1099               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
000042  2218              MOVS     r2,#0x18
                  |L18.68|
;;;1100               u8Err = 1U;
000044  2501              MOVS     r5,#1
000046  e017              B        |L18.120|
;;;1101               break;
;;;1102   
;;;1103           case 0x28:
;;;1104               u8Ctrl = I2C_CTL_STA_SI;                         /* Send repeat START */
000048  2228              MOVS     r2,#0x28
;;;1105               break;
00004a  e015              B        |L18.120|
;;;1106   
;;;1107           case 0x10:
;;;1108               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));  /* Write SLA+R to Register I2CDAT */
00004c  1c79              ADDS     r1,r7,#1
00004e  b2c9              UXTB     r1,r1
                  |L18.80|
000050  6081              STR      r1,[r0,#8]
000052  e009              B        |L18.104|
;;;1109               u8Ctrl = I2C_CTL_SI;                             /* Clear SI */
;;;1110               break;
;;;1111   
;;;1112           case 0x40:                                           /* Slave Address ACK */
;;;1113               u8Ctrl = I2C_CTL_SI_AA;                          /* Clear SI and set ACK */
;;;1114               break;
;;;1115   
;;;1116           case 0x48:                                           /* Slave Address NACK */
;;;1117               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1118               u8Err = 1U;
;;;1119               break;
;;;1120   
;;;1121           case 0x50:
;;;1122               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
000054  6881              LDR      r1,[r0,#8]
000056  9a03              LDR      r2,[sp,#0xc]
000058  5511              STRB     r1,[r2,r4]
;;;1123   
;;;1124               if (u32rxLen < (u32rLen - 1U))
00005a  9909              LDR      r1,[sp,#0x24]
00005c  1c64              ADDS     r4,r4,#1
00005e  1e49              SUBS     r1,r1,#1
000060  428c              CMP      r4,r1
000062  d201              BCS      |L18.104|
;;;1125                   u8Ctrl = I2C_CTL_SI_AA;                      /* Clear SI and set ACK */
000064  220c              MOVS     r2,#0xc
000066  e007              B        |L18.120|
                  |L18.104|
;;;1126               else
;;;1127                   u8Ctrl = I2C_CTL_SI;                         /* Clear SI */
000068  2208              MOVS     r2,#8
00006a  e005              B        |L18.120|
;;;1128   
;;;1129               break;
;;;1130   
;;;1131           case 0x58:
;;;1132               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c); /* Receive Data */
00006c  6881              LDR      r1,[r0,#8]
00006e  9a03              LDR      r2,[sp,#0xc]
;;;1133               u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;1134               u8Xfering = 0U;
000070  2600              MOVS     r6,#0
000072  5511              STRB     r1,[r2,r4]            ;1132
000074  2218              MOVS     r2,#0x18              ;1133
000076  1c64              ADDS     r4,r4,#1
                  |L18.120|
;;;1135               break;
;;;1136   
;;;1137           case 0x38:                                           /* Arbitration Lost */
;;;1138           default:                                             /* Unknow status */
;;;1139               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
;;;1140               u8Ctrl = I2C_CTL_SI;
;;;1141               u8Err = 1U;
;;;1142               break;
;;;1143           }
;;;1144   
;;;1145           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000078  6801              LDR      r1,[r0,#0]
00007a  233c              MOVS     r3,#0x3c
00007c  4399              BICS     r1,r1,r3
00007e  4311              ORRS     r1,r1,r2
000080  6001              STR      r1,[r0,#0]
000082  2e00              CMP      r6,#0                 ;1082
000084  d001              BEQ      |L18.138|
000086  2d00              CMP      r5,#0                 ;1082
000088  d0c4              BEQ      |L18.20|
                  |L18.138|
;;;1146       }
;;;1147   
;;;1148       return u32rxLen;                                         /* Return bytes length that have been received */
00008a  4620              MOV      r0,r4
;;;1149   }
00008c  b004              ADD      sp,sp,#0x10
00008e  bdf0              POP      {r4-r7,pc}
                  |L18.144|
000090  6801              LDR      r1,[r0,#0]            ;1139
000092  223c              MOVS     r2,#0x3c              ;1139
000094  4391              BICS     r1,r1,r2              ;1139
000096  3118              ADDS     r1,r1,#0x18           ;1139
000098  6001              STR      r1,[r0,#0]            ;1139
00009a  2208              MOVS     r2,#8                 ;1140
00009c  e7d2              B        |L18.68|
;;;1150   
                          ENDP


                          AREA ||i.I2C_ReadMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_ReadMultiBytesTwoRegs PROC
;;;1253     */
;;;1254   uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;1255   {
;;;1256       uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2201              MOVS     r2,#1
000004  b081              SUB      sp,sp,#4              ;1255
000006  2500              MOVS     r5,#0
000008  9200              STR      r2,[sp,#0]
00000a  4616              MOV      r6,r2
;;;1257       uint32_t u32rxLen = 0U;
;;;1258   
;;;1259       I2C_START(i2c);                                                   /* Send START */
00000c  6803              LDR      r3,[r0,#0]
00000e  462a              MOV      r2,r5                 ;1256
000010  462c              MOV      r4,r5                 ;1257
000012  2728              MOVS     r7,#0x28
000014  433b              ORRS     r3,r3,r7
000016  6003              STR      r3,[r0,#0]
;;;1260   
;;;1261       while (u8Xfering && (u8Err == 0U))
;;;1262       {
;;;1263           I2C_WAIT_READY(i2c) {}
;;;1264   
;;;1265           switch (I2C_GET_STATUS(i2c))
;;;1266           {
;;;1267           case 0x08:
;;;1268               I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));             /* Write SLA+W to Register I2CDAT */
000018  004f              LSLS     r7,r1,#1
                  |L19.26|
00001a  6801              LDR      r1,[r0,#0]            ;1263
00001c  0709              LSLS     r1,r1,#28             ;1263
00001e  d5fc              BPL      |L19.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;1265
000022  074b              LSLS     r3,r1,#29             ;1265
000024  0f5b              LSRS     r3,r3,#29             ;1265
000026  d140              BNE      |L19.170|
000028  10c9              ASRS     r1,r1,#3              ;1265
00002a  000b              MOVS     r3,r1                 ;1265
00002c  f7fffffe          BL       __ARM_common_switch8
000030  0c3d0719          DCB      0x0c,0x3d,0x07,0x19
000034  090d100d          DCB      0x09,0x0d,0x10,0x0d
000038  3d250d1d          DCB      0x3d,0x25,0x0d,0x1d
00003c  293d              DCB      0x29,0x3d
00003e  b2f9              UXTB     r1,r7
;;;1269               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1270               break;
000040  e011              B        |L19.102|
;;;1271   
;;;1272           case 0x18:                                                    /* Slave Address ACK */
;;;1273               I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));/* Write Hi byte address of register */
000042  9903              LDR      r1,[sp,#0xc]
000044  0a09              LSRS     r1,r1,#8
000046  6081              STR      r1,[r0,#8]
;;;1274               break;
000048  e022              B        |L19.144|
;;;1275   
;;;1276           case 0x20:                                                    /* Slave Address NACK */
;;;1277           case 0x30:                                                    /* Master transmit data NACK */
;;;1278               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
00004a  2218              MOVS     r2,#0x18
                  |L19.76|
;;;1279               u8Err = 1U;
00004c  2501              MOVS     r5,#1
00004e  e01f              B        |L19.144|
;;;1280               break;
;;;1281   
;;;1282           case 0x28:
;;;1283               if (u8Addr)
000050  2e00              CMP      r6,#0
000052  d004              BEQ      |L19.94|
;;;1284               {
;;;1285                   I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));     /* Write Lo byte address of register */
000054  9903              LDR      r1,[sp,#0xc]
000056  b2c9              UXTB     r1,r1
000058  6081              STR      r1,[r0,#8]
;;;1286                   u8Addr = 0U;
00005a  2600              MOVS     r6,#0
00005c  e018              B        |L19.144|
                  |L19.94|
;;;1287               }
;;;1288               else
;;;1289                   u8Ctrl = I2C_CTL_STA_SI;                              /* Clear SI and send repeat START */
00005e  2228              MOVS     r2,#0x28
000060  e016              B        |L19.144|
;;;1290   
;;;1291               break;
;;;1292   
;;;1293           case 0x10:
;;;1294               I2C_SET_DATA(i2c, (uint8_t)((u8SlaveAddr << 1U) | 0x01U));           /* Write SLA+R to Register I2CDAT */
000062  1c79              ADDS     r1,r7,#1
000064  b2c9              UXTB     r1,r1
                  |L19.102|
000066  6081              STR      r1,[r0,#8]
000068  e009              B        |L19.126|
;;;1295               u8Ctrl = I2C_CTL_SI;                                      /* Clear SI */
;;;1296               break;
;;;1297   
;;;1298           case 0x40:                                                    /* Slave Address ACK */
;;;1299               u8Ctrl = I2C_CTL_SI_AA;                                   /* Clear SI and set ACK */
;;;1300               break;
;;;1301   
;;;1302           case 0x48:                                                    /* Slave Address NACK */
;;;1303               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1304               u8Err = 1U;
;;;1305               break;
;;;1306   
;;;1307           case 0x50:
;;;1308               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
00006a  6881              LDR      r1,[r0,#8]
00006c  9a04              LDR      r2,[sp,#0x10]
00006e  5511              STRB     r1,[r2,r4]
;;;1309   
;;;1310               if (u32rxLen < (u32rLen - 1U))
000070  990a              LDR      r1,[sp,#0x28]
000072  1c64              ADDS     r4,r4,#1
000074  1e49              SUBS     r1,r1,#1
000076  428c              CMP      r4,r1
000078  d201              BCS      |L19.126|
;;;1311               {
;;;1312                   u8Ctrl = I2C_CTL_SI_AA;                               /* Clear SI and set ACK */
00007a  220c              MOVS     r2,#0xc
00007c  e008              B        |L19.144|
                  |L19.126|
;;;1313               }
;;;1314               else
;;;1315               {
;;;1316                   u8Ctrl = I2C_CTL_SI;                                  /* Clear SI */
00007e  2208              MOVS     r2,#8
000080  e006              B        |L19.144|
;;;1317               }
;;;1318   
;;;1319               break;
;;;1320   
;;;1321           case 0x58:
;;;1322               rdata[u32rxLen++] = (uint8_t) I2C_GET_DATA(i2c);    /* Receive Data */
000082  6882              LDR      r2,[r0,#8]
000084  9904              LDR      r1,[sp,#0x10]
000086  550a              STRB     r2,[r1,r4]
;;;1323               u8Ctrl = I2C_CTL_STO_SI;                                  /* Clear SI and send STOP */
;;;1324               u8Xfering = 0U;
000088  2100              MOVS     r1,#0
00008a  2218              MOVS     r2,#0x18              ;1323
00008c  1c64              ADDS     r4,r4,#1
00008e  9100              STR      r1,[sp,#0]
                  |L19.144|
;;;1325               break;
;;;1326   
;;;1327           case 0x38:                                                    /* Arbitration Lost */
;;;1328           default:                                                      /* Unknow status */
;;;1329               I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                 /* Clear SI and send STOP */
;;;1330               u8Ctrl = I2C_CTL_SI;
;;;1331               u8Err = 1U;
;;;1332               break;
;;;1333           }
;;;1334   
;;;1335           I2C_SET_CONTROL_REG(i2c, u8Ctrl);                             /* Write controlbit to I2C_CTL register */
000090  6801              LDR      r1,[r0,#0]
000092  233c              MOVS     r3,#0x3c
000094  4399              BICS     r1,r1,r3
000096  4311              ORRS     r1,r1,r2
000098  6001              STR      r1,[r0,#0]
00009a  9900              LDR      r1,[sp,#0]            ;1261
00009c  2900              CMP      r1,#0                 ;1261
00009e  d001              BEQ      |L19.164|
0000a0  2d00              CMP      r5,#0                 ;1261
0000a2  d0ba              BEQ      |L19.26|
                  |L19.164|
;;;1336       }
;;;1337   
;;;1338       return u32rxLen;                                                  /* Return bytes length that have been received */
0000a4  4620              MOV      r0,r4
;;;1339   }
0000a6  b005              ADD      sp,sp,#0x14
0000a8  bdf0              POP      {r4-r7,pc}
                  |L19.170|
0000aa  6801              LDR      r1,[r0,#0]            ;1329
0000ac  223c              MOVS     r2,#0x3c              ;1329
0000ae  4391              BICS     r1,r1,r2              ;1329
0000b0  3118              ADDS     r1,r1,#0x18           ;1329
0000b2  6001              STR      r1,[r0,#0]            ;1329
0000b4  2208              MOVS     r2,#8                 ;1330
0000b6  e7c9              B        |L19.76|
;;;1340   
                          ENDP


                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;209     */
;;;210    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;211    {
000002  4605              MOV      r5,r0
;;;212        uint32_t u32Div;
;;;213        uint32_t u32Pclk;
;;;214    
;;;215        if (i2c == I2C1)
000004  480d              LDR      r0,|L20.60|
000006  460e              MOV      r6,r1                 ;211
000008  4285              CMP      r5,r0
00000a  d102              BNE      |L20.18|
;;;216        {
;;;217            u32Pclk = CLK_GetPCLK1Freq();
00000c  f7fffffe          BL       CLK_GetPCLK1Freq
000010  e001              B        |L20.22|
                  |L20.18|
;;;218        }
;;;219        else
;;;220        {
;;;221            u32Pclk = CLK_GetPCLK0Freq();
000012  f7fffffe          BL       CLK_GetPCLK0Freq
                  |L20.22|
000016  4604              MOV      r4,r0
;;;222        }
;;;223    
;;;224        u32Div = (uint32_t)(((u32Pclk * 10U) / (u32BusClock * 4U) + 5U) / 10U - 1U); /* Compute proper divider for I2C clock */
000018  220a              MOVS     r2,#0xa
00001a  00b1              LSLS     r1,r6,#2
00001c  4350              MULS     r0,r2,r0
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  210a              MOVS     r1,#0xa
000024  1d40              ADDS     r0,r0,#5
000026  f7fffffe          BL       __aeabi_uidivmod
00002a  1e40              SUBS     r0,r0,#1
;;;225        i2c->CLKDIV = u32Div;
00002c  6128              STR      r0,[r5,#0x10]
;;;226    
;;;227        return (u32Pclk / ((u32Div + 1U) << 2U));
00002e  0081              LSLS     r1,r0,#2
000030  4620              MOV      r0,r4
000032  1d09              ADDS     r1,r1,#4
000034  f7fffffe          BL       __aeabi_uidivmod
;;;228    }
000038  bd70              POP      {r4-r6,pc}
;;;229    
                          ENDP

00003a  0000              DCW      0x0000
                  |L20.60|
                          DCD      0x40081000

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;281     */
;;;282    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;283    {
;;;284        i2c->DAT = u8Data;
;;;285    }
000002  4770              BX       lr
;;;286    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;300     */
;;;301    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;302    {
;;;303        switch (u8SlaveNo)
;;;304        {
;;;305        case 1:
;;;306            i2c->ADDR1  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2901              CMP      r1,#1                 ;303
000006  d005              BEQ      |L22.20|
000008  2902              CMP      r1,#2                 ;303
00000a  d005              BEQ      |L22.24|
00000c  2903              CMP      r1,#3                 ;303
00000e  d005              BEQ      |L22.28|
;;;307            break;
;;;308    
;;;309        case 2:
;;;310            i2c->ADDR2  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;311            break;
;;;312    
;;;313        case 3:
;;;314            i2c->ADDR3  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
;;;315            break;
;;;316    
;;;317        case 0:
;;;318        default:
;;;319            i2c->ADDR0  = ((uint32_t)u8SlaveAddr << 1U) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;320            break;
;;;321        }
;;;322    }
000012  4770              BX       lr
                  |L22.20|
000014  6182              STR      r2,[r0,#0x18]         ;306
000016  4770              BX       lr
                  |L22.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;310
00001a  4770              BX       lr
                  |L22.28|
00001c  6202              STR      r2,[r0,#0x20]         ;314
00001e  4770              BX       lr
;;;323    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;335     */
;;;336    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;337    {
;;;338        switch (u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L23.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L23.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L23.26|
;;;339        {
;;;340        case 1:
;;;341            i2c->ADDRMSK1  = (uint32_t)u8SlaveAddrMask << 1U;
;;;342            break;
;;;343    
;;;344        case 2:
;;;345            i2c->ADDRMSK2  = (uint32_t)u8SlaveAddrMask << 1U;
;;;346            break;
;;;347    
;;;348        case 3:
;;;349            i2c->ADDRMSK3  = (uint32_t)u8SlaveAddrMask << 1U;
;;;350            break;
;;;351    
;;;352        case 0:
;;;353        default:
;;;354            i2c->ADDRMSK0  = (uint32_t)u8SlaveAddrMask << 1U;
00000e  6242              STR      r2,[r0,#0x24]
;;;355            break;
;;;356        }
;;;357    }
000010  4770              BX       lr
                  |L23.18|
000012  6282              STR      r2,[r0,#0x28]         ;341
000014  4770              BX       lr
                  |L23.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;345
000018  4770              BX       lr
                  |L23.26|
00001a  6302              STR      r2,[r0,#0x30]         ;349
00001c  4770              BX       lr
;;;358    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;116      */
;;;117    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;118    {
;;;119        uint32_t u32Reg = 0U;
000002  2400              MOVS     r4,#0
;;;120    
;;;121        if (u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L24.12|
;;;122        {
;;;123            u32Reg |= I2C_CTL_STA;
00000a  2420              MOVS     r4,#0x20
                  |L24.12|
;;;124        }
;;;125    
;;;126        if (u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L24.20|
;;;127        {
;;;128            u32Reg |= I2C_CTL_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L24.20|
;;;129        }
;;;130    
;;;131        if (u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L24.28|
;;;132        {
;;;133            u32Reg |= I2C_CTL_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L24.28|
;;;134        }
;;;135    
;;;136        if (u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L24.36|
;;;137        {
;;;138            u32Reg |= I2C_CTL_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L24.36|
;;;139        }
;;;140    
;;;141        i2c->CTL0 = (i2c->CTL0 & ~0x3CU) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;142    }
00002e  bd30              POP      {r4,r5,pc}
;;;143    
                          ENDP


                          AREA ||i.I2C_WriteByte||, CODE, READONLY, ALIGN=1

                  I2C_WriteByte PROC
;;;443    
;;;444    uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;445    {
;;;446        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  2400              MOVS     r4,#0
;;;447    
;;;448        I2C_START(i2c);
000006  6806              LDR      r6,[r0,#0]
000008  4623              MOV      r3,r4                 ;446
00000a  2728              MOVS     r7,#0x28
00000c  433e              ORRS     r6,r6,r7
00000e  6006              STR      r6,[r0,#0]
;;;449    
;;;450        while (u8Xfering && (u8Err == 0U))
;;;451        {
;;;452            I2C_WAIT_READY(i2c) {}
;;;453    
;;;454            switch (I2C_GET_STATUS(i2c))
;;;455            {
;;;456            case 0x08:
;;;457                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;458                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;459                break;
;;;460    
;;;461            case 0x18:                                         /* Slave Address ACK */
;;;462                I2C_SET_DATA(i2c, data);                       /* Write data to I2CDAT */
;;;463                break;
;;;464    
;;;465            case 0x20:                                         /* Slave Address NACK */
;;;466            case 0x30:                                         /* Master transmit data NACK */
;;;467                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;468                u8Err = 1U;
;;;469                break;
;;;470    
;;;471            case 0x28:
;;;472                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;473                u8Xfering = 0U;
;;;474                break;
;;;475    
;;;476            case 0x38:                                         /* Arbitration Lost */
;;;477            default:                                           /* Unknow status */
;;;478                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000010  263c              MOVS     r6,#0x3c
                  |L25.18|
000012  6807              LDR      r7,[r0,#0]            ;452
000014  073f              LSLS     r7,r7,#28             ;452
000016  d5fc              BPL      |L25.18|
000018  68c7              LDR      r7,[r0,#0xc]          ;454
00001a  2f20              CMP      r7,#0x20              ;454
00001c  d016              BEQ      |L25.76|
00001e  dc04              BGT      |L25.42|
000020  2f08              CMP      r7,#8                 ;454
000022  d00c              BEQ      |L25.62|
000024  2f18              CMP      r7,#0x18              ;454
000026  d104              BNE      |L25.50|
000028  e00e              B        |L25.72|
                  |L25.42|
00002a  2f28              CMP      r7,#0x28              ;454
00002c  d011              BEQ      |L25.82|
00002e  2f30              CMP      r7,#0x30              ;454
000030  d00c              BEQ      |L25.76|
                  |L25.50|
000032  6803              LDR      r3,[r0,#0]
000034  43b3              BICS     r3,r3,r6
000036  3318              ADDS     r3,r3,#0x18
000038  6003              STR      r3,[r0,#0]
;;;479                u8Ctrl = I2C_CTL_SI;
00003a  2308              MOVS     r3,#8
;;;480                u8Err = 1U;
;;;481                break;
00003c  e007              B        |L25.78|
                  |L25.62|
00003e  064b              LSLS     r3,r1,#25             ;457
000040  0e1b              LSRS     r3,r3,#24             ;457
000042  6083              STR      r3,[r0,#8]            ;457
000044  2308              MOVS     r3,#8                 ;458
000046  e006              B        |L25.86|
                  |L25.72|
000048  6082              STR      r2,[r0,#8]            ;462
00004a  e004              B        |L25.86|
                  |L25.76|
00004c  2318              MOVS     r3,#0x18              ;467
                  |L25.78|
00004e  2401              MOVS     r4,#1                 ;468
000050  e001              B        |L25.86|
                  |L25.82|
000052  2318              MOVS     r3,#0x18              ;472
000054  2500              MOVS     r5,#0                 ;473
                  |L25.86|
;;;482            }
;;;483    
;;;484            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000056  6807              LDR      r7,[r0,#0]
000058  43b7              BICS     r7,r7,r6
00005a  431f              ORRS     r7,r7,r3
00005c  6007              STR      r7,[r0,#0]
00005e  2d00              CMP      r5,#0                 ;450
000060  d001              BEQ      |L25.102|
000062  2c00              CMP      r4,#0                 ;450
000064  d0d5              BEQ      |L25.18|
                  |L25.102|
000066  4620              MOV      r0,r4                 ;450
;;;485        }
;;;486    
;;;487        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
000068  4328              ORRS     r0,r0,r5
;;;488    }
00006a  bdf0              POP      {r4-r7,pc}
;;;489    
                          ENDP


                          AREA ||i.I2C_WriteByteOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteOneReg PROC
;;;568    
;;;569    uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;570    {
000002  469e              MOV      lr,r3
;;;571        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2601              MOVS     r6,#1
000006  4613              MOV      r3,r2                 ;570
000008  2500              MOVS     r5,#0
;;;572        uint32_t u32txLen = 0U;
;;;573    
;;;574        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;570
00000e  462c              MOV      r4,r5                 ;571
000010  462f              MOV      r7,r5                 ;572
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;575    
;;;576        while (u8Xfering && (u8Err == 0U))
;;;577        {
;;;578            I2C_WAIT_READY(i2c) {}
;;;579    
;;;580            switch (I2C_GET_STATUS(i2c))
;;;581            {
;;;582            case 0x08:
;;;583                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Send Slave address with write bit */
;;;584                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;585                break;
;;;586    
;;;587            case 0x18:                                         /* Slave Address ACK */
;;;588                I2C_SET_DATA(i2c, u8DataAddr);                 /* Write Lo byte address of register */
;;;589                break;
;;;590    
;;;591            case 0x20:                                         /* Slave Address NACK */
;;;592            case 0x30:                                         /* Master transmit data NACK */
;;;593                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;594                u8Err = 1U;
;;;595                break;
;;;596    
;;;597            case 0x28:
;;;598                if (u32txLen < 1U)
;;;599                {
;;;600                    I2C_SET_DATA(i2c, data);
;;;601                    u32txLen++;
;;;602                }
;;;603                else
;;;604                {
;;;605                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;606                    u8Xfering = 0U;
;;;607                }
;;;608    
;;;609                break;
;;;610    
;;;611            case 0x38:                                         /* Arbitration Lost */
;;;612            default:                                           /* Unknow status */
;;;613                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L26.26|
00001a  6801              LDR      r1,[r0,#0]            ;578
00001c  0709              LSLS     r1,r1,#28             ;578
00001e  d5fc              BPL      |L26.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;580
000022  2920              CMP      r1,#0x20              ;580
000024  d017              BEQ      |L26.86|
000026  dc04              BGT      |L26.50|
000028  2908              CMP      r1,#8                 ;580
00002a  d00c              BEQ      |L26.70|
00002c  2918              CMP      r1,#0x18              ;580
00002e  d104              BNE      |L26.58|
000030  e00f              B        |L26.82|
                  |L26.50|
000032  2928              CMP      r1,#0x28              ;580
000034  d012              BEQ      |L26.92|
000036  2930              CMP      r1,#0x30              ;580
000038  d00d              BEQ      |L26.86|
                  |L26.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;614                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;615                u8Err = 1U;
;;;616                break;
000044  e008              B        |L26.88|
                  |L26.70|
000046  4661              MOV      r1,r12                ;583
000048  064c              LSLS     r4,r1,#25             ;583
00004a  0e24              LSRS     r4,r4,#24             ;583
00004c  6084              STR      r4,[r0,#8]            ;583
00004e  2408              MOVS     r4,#8                 ;584
000050  e00c              B        |L26.108|
                  |L26.82|
000052  6083              STR      r3,[r0,#8]            ;588
000054  e00a              B        |L26.108|
                  |L26.86|
000056  2418              MOVS     r4,#0x18              ;593
                  |L26.88|
000058  2501              MOVS     r5,#1                 ;594
00005a  e007              B        |L26.108|
                  |L26.92|
00005c  2f00              CMP      r7,#0                 ;598
00005e  d002              BEQ      |L26.102|
000060  2418              MOVS     r4,#0x18              ;605
000062  2600              MOVS     r6,#0                 ;606
000064  e002              B        |L26.108|
                  |L26.102|
000066  4671              MOV      r1,lr                 ;600
000068  6081              STR      r1,[r0,#8]            ;600
00006a  2701              MOVS     r7,#1                 ;601
                  |L26.108|
;;;617            }
;;;618    
;;;619            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
00006c  6801              LDR      r1,[r0,#0]
00006e  4391              BICS     r1,r1,r2
000070  4321              ORRS     r1,r1,r4
000072  6001              STR      r1,[r0,#0]
000074  2e00              CMP      r6,#0                 ;576
000076  d001              BEQ      |L26.124|
000078  2d00              CMP      r5,#0                 ;576
00007a  d0ce              BEQ      |L26.26|
                  |L26.124|
00007c  4628              MOV      r0,r5                 ;576
;;;620        }
;;;621    
;;;622        return (u8Err | u8Xfering);                            /* return (Success)/(Fail) status */
00007e  4330              ORRS     r0,r0,r6
;;;623    }
000080  bdf0              POP      {r4-r7,pc}
;;;624    
                          ENDP


                          AREA ||i.I2C_WriteByteTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteByteTwoRegs PROC
;;;708    
;;;709    uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data)
000000  b5ff              PUSH     {r0-r7,lr}
;;;710    {
;;;711        uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2501              MOVS     r5,#1
000004  468e              MOV      lr,r1                 ;710
000006  2400              MOVS     r4,#0
;;;712        uint32_t u32txLen = 0U;
;;;713    
;;;714        I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;710
00000c  462f              MOV      r7,r5                 ;711
00000e  4623              MOV      r3,r4                 ;711
000010  4626              MOV      r6,r4                 ;712
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L27.24|
;;;715    
;;;716        while (u8Xfering && (u8Err == 0U))
;;;717        {
;;;718            I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L27.24|
;;;719    
;;;720            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L27.90|
000024  dc04              BGT      |L27.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L27.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L27.56|
00002e  e010              B        |L27.82|
                  |L27.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L27.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L27.90|
                  |L27.56|
;;;721            {
;;;722            case 0x08:
;;;723                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;724                u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;725                break;
;;;726    
;;;727            case 0x18:                                                      /* Slave Address ACK */
;;;728                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;729                break;
;;;730    
;;;731            case 0x20:                                                      /* Slave Address NACK */
;;;732            case 0x30:                                                      /* Master transmit data NACK */
;;;733                u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;734                u8Err = 1;
;;;735                break;
;;;736    
;;;737            case 0x28:
;;;738                if (u8Addr)
;;;739                {
;;;740                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;741                    u8Addr = 0U;
;;;742                }
;;;743                else if ((u32txLen < 1U) && (u8Addr == 0U))
;;;744                {
;;;745                    I2C_SET_DATA(i2c, data);
;;;746                    u32txLen++;
;;;747                }
;;;748                else
;;;749                {
;;;750                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;751                    u8Xfering = 0U;
;;;752                }
;;;753    
;;;754                break;
;;;755    
;;;756            case 0x38:                                                      /* Arbitration Lost */
;;;757            default:                                                        /* Unknow status */
;;;758                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;759                u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;760                u8Err = 1U;
;;;761                break;
000044  e00a              B        |L27.92|
                  |L27.70|
000046  4671              MOV      r1,lr                 ;723
000048  0649              LSLS     r1,r1,#25             ;723
00004a  0e09              LSRS     r1,r1,#24             ;723
00004c  6081              STR      r1,[r0,#8]            ;723
00004e  2308              MOVS     r3,#8                 ;724
000050  e015              B        |L27.126|
                  |L27.82|
000052  4661              MOV      r1,r12                ;728
000054  0a0a              LSRS     r2,r1,#8              ;728
000056  6082              STR      r2,[r0,#8]            ;728
000058  e011              B        |L27.126|
                  |L27.90|
00005a  2318              MOVS     r3,#0x18              ;733
                  |L27.92|
00005c  2401              MOVS     r4,#1                 ;734
00005e  e00e              B        |L27.126|
                  |L27.96|
000060  2f00              CMP      r7,#0                 ;738
000062  d004              BEQ      |L27.110|
000064  4661              MOV      r1,r12                ;740
000066  b2c9              UXTB     r1,r1                 ;740
000068  6081              STR      r1,[r0,#8]            ;740
00006a  2700              MOVS     r7,#0                 ;741
00006c  e007              B        |L27.126|
                  |L27.110|
00006e  2e00              CMP      r6,#0                 ;743
000070  d002              BEQ      |L27.120|
000072  2318              MOVS     r3,#0x18              ;750
000074  2500              MOVS     r5,#0                 ;751
000076  e002              B        |L27.126|
                  |L27.120|
000078  9903              LDR      r1,[sp,#0xc]          ;745
00007a  6081              STR      r1,[r0,#8]            ;745
00007c  2601              MOVS     r6,#1                 ;746
                  |L27.126|
;;;762            }
;;;763    
;;;764            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
00007e  6801              LDR      r1,[r0,#0]
000080  223c              MOVS     r2,#0x3c
000082  4391              BICS     r1,r1,r2
000084  460a              MOV      r2,r1
000086  431a              ORRS     r2,r2,r3
000088  6002              STR      r2,[r0,#0]
00008a  2d00              CMP      r5,#0                 ;716
00008c  d001              BEQ      |L27.146|
00008e  2c00              CMP      r4,#0                 ;716
000090  d0c2              BEQ      |L27.24|
                  |L27.146|
000092  4620              MOV      r0,r4                 ;716
;;;765        }
;;;766    
;;;767        return (u8Err | u8Xfering);                                         /* return (Success)/(Fail) status */
000094  4328              ORRS     r0,r0,r5
;;;768    }
000096  b004              ADD      sp,sp,#0x10
000098  bdf0              POP      {r4-r7,pc}
;;;769    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytes||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytes PROC
;;;503    
;;;504    uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;505    {
000002  469e              MOV      lr,r3
;;;506        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  4613              MOV      r3,r2                 ;505
000008  2600              MOVS     r6,#0
;;;507        uint32_t u32txLen = 0U;
;;;508    
;;;509        I2C_START(i2c);                                        /* Send START */
00000a  6802              LDR      r2,[r0,#0]
00000c  468c              MOV      r12,r1                ;505
00000e  4634              MOV      r4,r6                 ;506
000010  4635              MOV      r5,r6                 ;507
000012  2128              MOVS     r1,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;510    
;;;511        while (u8Xfering && (u8Err == 0U))
;;;512        {
;;;513            I2C_WAIT_READY(i2c) {}
;;;514    
;;;515            switch (I2C_GET_STATUS(i2c))
;;;516            {
;;;517            case 0x08:
;;;518                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));  /* Write SLA+W to Register I2CDAT */
;;;519                u8Ctrl = I2C_CTL_SI;                           /* Clear SI */
;;;520                break;
;;;521    
;;;522            case 0x18:                                         /* Slave Address ACK */
;;;523            case 0x28:
;;;524                if (u32txLen < u32wLen)
;;;525                    I2C_SET_DATA(i2c, data[u32txLen++]);       /* Write Data to I2CDAT */
;;;526                else
;;;527                {
;;;528                    u8Ctrl = I2C_CTL_STO_SI;                   /* Clear SI and send STOP */
;;;529                    u8Xfering = 0U;
;;;530                }
;;;531    
;;;532                break;
;;;533    
;;;534            case 0x20:                                         /* Slave Address NACK */
;;;535            case 0x30:                                         /* Master transmit data NACK */
;;;536                u8Ctrl = I2C_CTL_STO_SI;                       /* Clear SI and send STOP */
;;;537                u8Err = 1U;
;;;538                break;
;;;539    
;;;540            case 0x38:                                         /* Arbitration Lost */
;;;541            default:                                           /* Unknow status */
;;;542                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);      /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L28.26|
00001a  6801              LDR      r1,[r0,#0]            ;513
00001c  0709              LSLS     r1,r1,#28             ;513
00001e  d5fc              BPL      |L28.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;515
000022  2920              CMP      r1,#0x20              ;515
000024  d01e              BEQ      |L28.100|
000026  dc04              BGT      |L28.50|
000028  2908              CMP      r1,#8                 ;515
00002a  d00c              BEQ      |L28.70|
00002c  2918              CMP      r1,#0x18              ;515
00002e  d104              BNE      |L28.58|
000030  e00f              B        |L28.82|
                  |L28.50|
000032  2928              CMP      r1,#0x28              ;515
000034  d00d              BEQ      |L28.82|
000036  2930              CMP      r1,#0x30              ;515
000038  d014              BEQ      |L28.100|
                  |L28.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;543                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;544                u8Err = 1U;
;;;545                break;
000044  e00f              B        |L28.102|
                  |L28.70|
000046  4661              MOV      r1,r12                ;518
000048  064c              LSLS     r4,r1,#25             ;518
00004a  0e24              LSRS     r4,r4,#24             ;518
00004c  6084              STR      r4,[r0,#8]            ;518
00004e  2408              MOVS     r4,#8                 ;519
000050  e00a              B        |L28.104|
                  |L28.82|
000052  4575              CMP      r5,lr                 ;524
000054  d203              BCS      |L28.94|
000056  5d59              LDRB     r1,[r3,r5]            ;525
000058  6081              STR      r1,[r0,#8]            ;525
00005a  1c6d              ADDS     r5,r5,#1              ;525
00005c  e004              B        |L28.104|
                  |L28.94|
00005e  2418              MOVS     r4,#0x18              ;528
000060  2700              MOVS     r7,#0                 ;529
000062  e001              B        |L28.104|
                  |L28.100|
000064  2418              MOVS     r4,#0x18              ;536
                  |L28.102|
000066  2601              MOVS     r6,#1                 ;537
                  |L28.104|
;;;546            }
;;;547    
;;;548            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                  /* Write controlbit to I2C_CTL register */
000068  6801              LDR      r1,[r0,#0]
00006a  4391              BICS     r1,r1,r2
00006c  4321              ORRS     r1,r1,r4
00006e  6001              STR      r1,[r0,#0]
000070  2f00              CMP      r7,#0                 ;511
000072  d001              BEQ      |L28.120|
000074  2e00              CMP      r6,#0                 ;511
000076  d0d0              BEQ      |L28.26|
                  |L28.120|
;;;549        }
;;;550    
;;;551        return u32txLen;                                       /* Return bytes length that have been transmitted */
000078  4628              MOV      r0,r5
;;;552    }
00007a  bdf0              POP      {r4-r7,pc}
;;;553    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesOneReg||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesOneReg PROC
;;;640    
;;;641    uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5f0              PUSH     {r4-r7,lr}
;;;642    {
000002  469e              MOV      lr,r3
;;;643        uint8_t u8Xfering = 1U, u8Err = 0U, u8Ctrl = 0U;
000004  2701              MOVS     r7,#1
000006  460b              MOV      r3,r1                 ;642
000008  2600              MOVS     r6,#0
;;;644        uint32_t u32txLen = 0U;
;;;645    
;;;646        I2C_START(i2c);                                           /* Send START */
00000a  6801              LDR      r1,[r0,#0]
00000c  4694              MOV      r12,r2                ;642
00000e  4634              MOV      r4,r6                 ;643
000010  4635              MOV      r5,r6                 ;644
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
;;;647    
;;;648        while (u8Xfering && (u8Err == 0U))
;;;649        {
;;;650            I2C_WAIT_READY(i2c) {}
;;;651    
;;;652            switch (I2C_GET_STATUS(i2c))
;;;653            {
;;;654            case 0x08:
;;;655                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));    /* Write SLA+W to Register I2CDAT */
;;;656                u8Ctrl = I2C_CTL_SI;
;;;657                break;
;;;658    
;;;659            case 0x18:                                           /* Slave Address ACK */
;;;660                I2C_SET_DATA(i2c, u8DataAddr);                   /* Write Lo byte address of register */
;;;661                break;
;;;662    
;;;663            case 0x20:                                           /* Slave Address NACK */
;;;664            case 0x30:                                           /* Master transmit data NACK */
;;;665                u8Ctrl = I2C_CTL_STO_SI;                         /* Clear SI and send STOP */
;;;666                u8Err = 1U;
;;;667                break;
;;;668    
;;;669            case 0x28:
;;;670                if (u32txLen < u32wLen)
;;;671                    I2C_SET_DATA(i2c, data[u32txLen++]);
;;;672                else
;;;673                {
;;;674                    u8Ctrl = I2C_CTL_STO_SI;                     /* Clear SI and send STOP */
;;;675                    u8Xfering = 0U;
;;;676                }
;;;677    
;;;678                break;
;;;679    
;;;680            case 0x38:                                           /* Arbitration Lost */
;;;681            default:                                             /* Unknow status */
;;;682                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);        /* Clear SI and send STOP */
000018  223c              MOVS     r2,#0x3c
                  |L29.26|
00001a  6801              LDR      r1,[r0,#0]            ;650
00001c  0709              LSLS     r1,r1,#28             ;650
00001e  d5fc              BPL      |L29.26|
000020  68c1              LDR      r1,[r0,#0xc]          ;652
000022  2920              CMP      r1,#0x20              ;652
000024  d017              BEQ      |L29.86|
000026  dc04              BGT      |L29.50|
000028  2908              CMP      r1,#8                 ;652
00002a  d00c              BEQ      |L29.70|
00002c  2918              CMP      r1,#0x18              ;652
00002e  d104              BNE      |L29.58|
000030  e00e              B        |L29.80|
                  |L29.50|
000032  2928              CMP      r1,#0x28              ;652
000034  d012              BEQ      |L29.92|
000036  2930              CMP      r1,#0x30              ;652
000038  d00d              BEQ      |L29.86|
                  |L29.58|
00003a  6804              LDR      r4,[r0,#0]
00003c  4394              BICS     r4,r4,r2
00003e  3418              ADDS     r4,r4,#0x18
000040  6004              STR      r4,[r0,#0]
;;;683                u8Ctrl = I2C_CTL_SI;
000042  2408              MOVS     r4,#8
;;;684                u8Err = 1U;
;;;685                break;
000044  e008              B        |L29.88|
                  |L29.70|
000046  065c              LSLS     r4,r3,#25             ;655
000048  0e24              LSRS     r4,r4,#24             ;655
00004a  6084              STR      r4,[r0,#8]            ;655
00004c  2408              MOVS     r4,#8                 ;656
00004e  e00f              B        |L29.112|
                  |L29.80|
000050  4661              MOV      r1,r12                ;660
000052  6081              STR      r1,[r0,#8]            ;660
000054  e00c              B        |L29.112|
                  |L29.86|
000056  2418              MOVS     r4,#0x18              ;665
                  |L29.88|
000058  2601              MOVS     r6,#1                 ;666
00005a  e009              B        |L29.112|
                  |L29.92|
00005c  9905              LDR      r1,[sp,#0x14]         ;670
00005e  428d              CMP      r5,r1                 ;670
000060  d204              BCS      |L29.108|
000062  4671              MOV      r1,lr                 ;671
000064  5d49              LDRB     r1,[r1,r5]            ;671
000066  6081              STR      r1,[r0,#8]            ;671
000068  1c6d              ADDS     r5,r5,#1              ;671
00006a  e001              B        |L29.112|
                  |L29.108|
00006c  2418              MOVS     r4,#0x18              ;674
00006e  2700              MOVS     r7,#0                 ;675
                  |L29.112|
;;;686            }
;;;687    
;;;688            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                    /* Write controlbit to I2C_CTL register */
000070  6801              LDR      r1,[r0,#0]
000072  4391              BICS     r1,r1,r2
000074  4321              ORRS     r1,r1,r4
000076  6001              STR      r1,[r0,#0]
000078  2f00              CMP      r7,#0                 ;648
00007a  d001              BEQ      |L29.128|
00007c  2e00              CMP      r6,#0                 ;648
00007e  d0cc              BEQ      |L29.26|
                  |L29.128|
;;;689        }
;;;690    
;;;691        return u32txLen;                                         /* Return bytes length that have been transmitted */
000080  4628              MOV      r0,r5
;;;692    }
000082  bdf0              POP      {r4-r7,pc}
;;;693    
                          ENDP


                          AREA ||i.I2C_WriteMultiBytesTwoRegs||, CODE, READONLY, ALIGN=1

                  I2C_WriteMultiBytesTwoRegs PROC
;;;785    
;;;786    uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen)
000000  b5ff              PUSH     {r0-r7,lr}
;;;787    {
;;;788        uint8_t u8Xfering = 1U, u8Err = 0U, u8Addr = 1U, u8Ctrl = 0U;
000002  2701              MOVS     r7,#1
000004  468e              MOV      lr,r1                 ;787
000006  2500              MOVS     r5,#0
;;;789        uint32_t u32txLen = 0U;
;;;790    
;;;791        I2C_START(i2c);                                                     /* Send START */
000008  6801              LDR      r1,[r0,#0]
00000a  4694              MOV      r12,r2                ;787
00000c  463e              MOV      r6,r7                 ;788
00000e  462b              MOV      r3,r5                 ;788
000010  462c              MOV      r4,r5                 ;789
000012  2228              MOVS     r2,#0x28
000014  430a              ORRS     r2,r2,r1
000016  6002              STR      r2,[r0,#0]
                  |L30.24|
;;;792    
;;;793        while (u8Xfering && (u8Err == 0U))
;;;794        {
;;;795            I2C_WAIT_READY(i2c) {}
000018  6802              LDR      r2,[r0,#0]
00001a  0712              LSLS     r2,r2,#28
00001c  d5fc              BPL      |L30.24|
;;;796    
;;;797            switch (I2C_GET_STATUS(i2c))
00001e  68c2              LDR      r2,[r0,#0xc]
000020  2a20              CMP      r2,#0x20
000022  d01a              BEQ      |L30.90|
000024  dc04              BGT      |L30.48|
000026  2a08              CMP      r2,#8
000028  d00d              BEQ      |L30.70|
00002a  2a18              CMP      r2,#0x18
00002c  d104              BNE      |L30.56|
00002e  e010              B        |L30.82|
                  |L30.48|
000030  2a28              CMP      r2,#0x28
000032  d015              BEQ      |L30.96|
000034  2a30              CMP      r2,#0x30
000036  d010              BEQ      |L30.90|
                  |L30.56|
;;;798            {
;;;799            case 0x08:
;;;800                I2C_SET_DATA(i2c, (uint8_t)(u8SlaveAddr << 1U | 0x00U));               /* Write SLA+W to Register I2CDAT */
;;;801                u8Ctrl = I2C_CTL_SI;                                        /* Clear SI */
;;;802                break;
;;;803    
;;;804            case 0x18:                                                      /* Slave Address ACK */
;;;805                I2C_SET_DATA(i2c, (uint8_t)((u16DataAddr & 0xFF00U) >> 8U));  /* Write Hi byte address of register */
;;;806                break;
;;;807    
;;;808            case 0x20:                                                      /* Slave Address NACK */
;;;809            case 0x30:                                                      /* Master transmit data NACK */
;;;810                u8Ctrl = I2C_CTL_STO_SI;                                    /* Clear SI and send STOP */
;;;811                u8Err = 1U;
;;;812                break;
;;;813    
;;;814            case 0x28:
;;;815                if (u8Addr)
;;;816                {
;;;817                    I2C_SET_DATA(i2c, (uint8_t)(u16DataAddr & 0xFFU));       /* Write Lo byte address of register */
;;;818                    u8Addr = 0U;
;;;819                }
;;;820                else if ((u32txLen < u32wLen) && (u8Addr == 0U))
;;;821                    I2C_SET_DATA(i2c, data[u32txLen++]);                    /* Write data to Register I2CDAT*/
;;;822                else
;;;823                {
;;;824                    u8Ctrl = I2C_CTL_STO_SI;                                /* Clear SI and send STOP */
;;;825                    u8Xfering = 0U;
;;;826                }
;;;827    
;;;828                break;
;;;829    
;;;830            case 0x38:                                                      /* Arbitration Lost */
;;;831            default:                                                        /* Unknow status */
;;;832                I2C_SET_CONTROL_REG(i2c, I2C_CTL_STO_SI);                   /* Clear SI and send STOP */
000038  6801              LDR      r1,[r0,#0]
00003a  223c              MOVS     r2,#0x3c
00003c  4391              BICS     r1,r1,r2
00003e  3118              ADDS     r1,r1,#0x18
000040  6001              STR      r1,[r0,#0]
;;;833                u8Ctrl = I2C_CTL_SI;
000042  2308              MOVS     r3,#8
;;;834                u8Err = 1U;
;;;835                break;
000044  e00a              B        |L30.92|
                  |L30.70|
000046  4671              MOV      r1,lr                 ;800
000048  0649              LSLS     r1,r1,#25             ;800
00004a  0e09              LSRS     r1,r1,#24             ;800
00004c  6081              STR      r1,[r0,#8]            ;800
00004e  2308              MOVS     r3,#8                 ;801
000050  e017              B        |L30.130|
                  |L30.82|
000052  4661              MOV      r1,r12                ;805
000054  0a0a              LSRS     r2,r1,#8              ;805
000056  6082              STR      r2,[r0,#8]            ;805
000058  e013              B        |L30.130|
                  |L30.90|
00005a  2318              MOVS     r3,#0x18              ;810
                  |L30.92|
00005c  2501              MOVS     r5,#1                 ;811
00005e  e010              B        |L30.130|
                  |L30.96|
000060  2e00              CMP      r6,#0                 ;815
000062  d004              BEQ      |L30.110|
000064  4661              MOV      r1,r12                ;817
000066  b2c9              UXTB     r1,r1                 ;817
000068  6081              STR      r1,[r0,#8]            ;817
00006a  2600              MOVS     r6,#0                 ;818
00006c  e009              B        |L30.130|
                  |L30.110|
00006e  9a09              LDR      r2,[sp,#0x24]         ;820
000070  4294              CMP      r4,r2                 ;820
000072  d204              BCS      |L30.126|
000074  9a03              LDR      r2,[sp,#0xc]          ;821
000076  5d12              LDRB     r2,[r2,r4]            ;821
000078  6082              STR      r2,[r0,#8]            ;821
00007a  1c64              ADDS     r4,r4,#1              ;821
00007c  e001              B        |L30.130|
                  |L30.126|
00007e  2318              MOVS     r3,#0x18              ;824
000080  2700              MOVS     r7,#0                 ;825
                  |L30.130|
;;;836            }
;;;837    
;;;838            I2C_SET_CONTROL_REG(i2c, u8Ctrl);                               /* Write controlbit to I2C_CTL register */
000082  6801              LDR      r1,[r0,#0]
000084  223c              MOVS     r2,#0x3c
000086  4391              BICS     r1,r1,r2
000088  460a              MOV      r2,r1
00008a  431a              ORRS     r2,r2,r3
00008c  6002              STR      r2,[r0,#0]
00008e  2f00              CMP      r7,#0                 ;793
000090  d001              BEQ      |L30.150|
000092  2d00              CMP      r5,#0                 ;793
000094  d0c0              BEQ      |L30.24|
                  |L30.150|
;;;839        }
;;;840    
;;;841        return u32txLen;                                                    /* Return bytes length that have been transmitted */
000096  4620              MOV      r0,r4
;;;842    }
000098  b004              ADD      sp,sp,#0x10
00009a  bdf0              POP      {r4-r7,pc}
;;;843    
                          ENDP


                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L187.16|
00000e  461d              MOV      r5,r3
                  |L187.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 402
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
