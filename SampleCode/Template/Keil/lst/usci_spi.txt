; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_spi.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\usci_spi.crf ..\..\..\Library\StdDriver\src\usci_spi.c]
                          THUMB

                          AREA ||i.USPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  USPI_ClearIntFlag PROC
;;;462      */
;;;463    void USPI_ClearIntFlag(USPI_T *uspi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;464    {
000002  d002              BEQ      |L1.10|
;;;465        /* Clear slave selection signal inactive interrupt flag */
;;;466        if(u32Mask & USPI_SSINACT_INT_MASK)
;;;467        {
;;;468            uspi->PROTSTS = USPI_PROTSTS_SSINAIF_Msk;
000004  22ff              MOVS     r2,#0xff
000006  3201              ADDS     r2,#1
000008  6642              STR      r2,[r0,#0x64]
                  |L1.10|
;;;469        }
;;;470    
;;;471        /* Clear slave selection signal active interrupt flag */
;;;472        if(u32Mask & USPI_SSACT_INT_MASK)
00000a  078a              LSLS     r2,r1,#30
00000c  d502              BPL      |L1.20|
;;;473        {
;;;474            uspi->PROTSTS = USPI_PROTSTS_SSACTIF_Msk;
00000e  2201              MOVS     r2,#1
000010  0252              LSLS     r2,r2,#9
000012  6642              STR      r2,[r0,#0x64]
                  |L1.20|
;;;475        }
;;;476    
;;;477        /* Clear slave time-out interrupt flag */
;;;478        if(u32Mask & USPI_SLVTO_INT_MASK)
000014  074a              LSLS     r2,r1,#29
000016  d501              BPL      |L1.28|
;;;479        {
;;;480            uspi->PROTSTS = USPI_PROTSTS_SLVTOIF_Msk;
000018  2220              MOVS     r2,#0x20
00001a  6642              STR      r2,[r0,#0x64]
                  |L1.28|
;;;481        }
;;;482    
;;;483        /* Clear slave bit count error interrupt flag */
;;;484        if(u32Mask & USPI_SLVBE_INT_MASK)
00001c  070a              LSLS     r2,r1,#28
00001e  d501              BPL      |L1.36|
;;;485        {
;;;486            uspi->PROTSTS = USPI_PROTSTS_SLVBEIF_Msk;
000020  2240              MOVS     r2,#0x40
000022  6642              STR      r2,[r0,#0x64]
                  |L1.36|
;;;487        }
;;;488    
;;;489        /* Clear TX under run interrupt flag */
;;;490        if(u32Mask & USPI_TXUDR_INT_MASK)
000024  06ca              LSLS     r2,r1,#27
000026  d502              BPL      |L1.46|
;;;491        {
;;;492            uspi->BUFSTS = USPI_BUFSTS_TXUDRIF_Msk;
000028  2201              MOVS     r2,#1
00002a  02d2              LSLS     r2,r2,#11
00002c  63c2              STR      r2,[r0,#0x3c]
                  |L1.46|
;;;493        }
;;;494    
;;;495        /* Clear RX overrun interrupt flag */
;;;496        if(u32Mask & USPI_RXOV_INT_MASK)
00002e  068b              LSLS     r3,r1,#26
;;;497        {
;;;498            uspi->BUFSTS = USPI_BUFSTS_RXOVIF_Msk;
000030  2208              MOVS     r2,#8
000032  2b00              CMP      r3,#0                 ;496
000034  da00              BGE      |L1.56|
000036  63c2              STR      r2,[r0,#0x3c]
                  |L1.56|
;;;499        }
;;;500    
;;;501        /* Clear TX start interrupt flag */
;;;502        if(u32Mask & USPI_TXST_INT_MASK)
000038  064b              LSLS     r3,r1,#25
00003a  d501              BPL      |L1.64|
;;;503        {
;;;504            uspi->PROTSTS = USPI_PROTSTS_TXSTIF_Msk;
00003c  2302              MOVS     r3,#2
00003e  6643              STR      r3,[r0,#0x64]
                  |L1.64|
;;;505        }
;;;506    
;;;507        /* Clear TX end interrupt flag */
;;;508        if(u32Mask & USPI_TXEND_INT_MASK)
000040  060b              LSLS     r3,r1,#24
000042  d501              BPL      |L1.72|
;;;509        {
;;;510            uspi->PROTSTS = USPI_PROTSTS_TXENDIF_Msk;
000044  2304              MOVS     r3,#4
000046  6643              STR      r3,[r0,#0x64]
                  |L1.72|
;;;511        }
;;;512    
;;;513        /* Clear RX start interrupt flag */
;;;514        if(u32Mask & USPI_RXST_INT_MASK)
000048  05cb              LSLS     r3,r1,#23
00004a  d500              BPL      |L1.78|
;;;515        {
;;;516            uspi->PROTSTS = USPI_PROTSTS_RXSTIF_Msk;
00004c  6642              STR      r2,[r0,#0x64]
                  |L1.78|
;;;517        }
;;;518    
;;;519        /* Clear RX end interrupt flag */
;;;520        if(u32Mask & USPI_RXEND_INT_MASK)
00004e  0589              LSLS     r1,r1,#22
000050  d501              BPL      |L1.86|
;;;521        {
;;;522            uspi->PROTSTS = USPI_PROTSTS_RXENDIF_Msk;
000052  2110              MOVS     r1,#0x10
000054  6641              STR      r1,[r0,#0x64]
                  |L1.86|
;;;523        }
;;;524    }
000056  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.USPI_ClearRxBuf||, CODE, READONLY, ALIGN=1

                  USPI_ClearRxBuf PROC
;;;115      */
;;;116    void USPI_ClearRxBuf(USPI_T *uspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;117    {
;;;118        uspi->BUFCTL |= USPI_BUFCTL_RXCLR_Msk;
000002  2201              MOVS     r2,#1
000004  03d2              LSLS     r2,r2,#15
000006  4311              ORRS     r1,r1,r2
000008  6381              STR      r1,[r0,#0x38]
;;;119    }
00000a  4770              BX       lr
;;;120    
                          ENDP


                          AREA ||i.USPI_ClearTxBuf||, CODE, READONLY, ALIGN=1

                  USPI_ClearTxBuf PROC
;;;125      */
;;;126    void USPI_ClearTxBuf(USPI_T *uspi)
000000  6b81              LDR      r1,[r0,#0x38]
;;;127    {
;;;128        uspi->BUFCTL |= USPI_BUFCTL_TXCLR_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6381              STR      r1,[r0,#0x38]
;;;129    }
000008  4770              BX       lr
;;;130    
                          ENDP


                          AREA ||i.USPI_Close||, CODE, READONLY, ALIGN=1

                  USPI_Close PROC
;;;105      */
;;;106    void USPI_Close(USPI_T *uspi)
000000  6801              LDR      r1,[r0,#0]
;;;107    {
;;;108        uspi->CTL &= ~USPI_CTL_FUNMODE_Msk;
000002  08c9              LSRS     r1,r1,#3
000004  00c9              LSLS     r1,r1,#3
000006  6001              STR      r1,[r0,#0]
;;;109    }
000008  4770              BX       lr
;;;110    
                          ENDP


                          AREA ||i.USPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  USPI_DisableAutoSS PROC
;;;135      */
;;;136    void USPI_DisableAutoSS(USPI_T *uspi)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;137    {
;;;138        uspi->PROTCTL &= ~(USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SS_Msk);
000002  220c              MOVS     r2,#0xc
000004  4391              BICS     r1,r1,r2
000006  65c1              STR      r1,[r0,#0x5c]
;;;139    }
000008  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.USPI_DisableInt||, CODE, READONLY, ALIGN=1

                  USPI_DisableInt PROC
;;;292      */
;;;293    void USPI_DisableInt(USPI_T *uspi, uint32_t u32Mask)
000000  b570              PUSH     {r4-r6,lr}
;;;294    {
;;;295        /* Disable slave selection signal inactive interrupt flag */
;;;296        if((u32Mask & USPI_SSINACT_INT_MASK) == USPI_SSINACT_INT_MASK)
000002  07ca              LSLS     r2,r1,#31
000004  d003              BEQ      |L6.14|
;;;297        {
;;;298            uspi->PROTIEN &= ~USPI_PROTIEN_SSINAIEN_Msk;
000006  6e02              LDR      r2,[r0,#0x60]
000008  0852              LSRS     r2,r2,#1
00000a  0052              LSLS     r2,r2,#1
00000c  6602              STR      r2,[r0,#0x60]
                  |L6.14|
;;;299        }
;;;300    
;;;301        /* Disable slave selection signal active interrupt flag */
;;;302        if((u32Mask & USPI_SSACT_INT_MASK) == USPI_SSACT_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
;;;303        {
;;;304            uspi->PROTIEN &= ~USPI_PROTIEN_SSACTIEN_Msk;
000010  2502              MOVS     r5,#2
000012  2a00              CMP      r2,#0                 ;302
000014  da02              BGE      |L6.28|
000016  6e02              LDR      r2,[r0,#0x60]
000018  43aa              BICS     r2,r2,r5
00001a  6602              STR      r2,[r0,#0x60]
                  |L6.28|
;;;305        }
;;;306    
;;;307        /* Disable slave time-out interrupt flag */
;;;308        if((u32Mask & USPI_SLVTO_INT_MASK) == USPI_SLVTO_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
;;;309        {
;;;310            uspi->PROTIEN &= ~USPI_PROTIEN_SLVTOIEN_Msk;
00001e  2304              MOVS     r3,#4
000020  2a00              CMP      r2,#0                 ;308
000022  da02              BGE      |L6.42|
000024  6e02              LDR      r2,[r0,#0x60]
000026  439a              BICS     r2,r2,r3
000028  6602              STR      r2,[r0,#0x60]
                  |L6.42|
;;;311        }
;;;312    
;;;313        /* Disable slave bit count error interrupt flag */
;;;314        if((u32Mask & USPI_SLVBE_INT_MASK) == USPI_SLVBE_INT_MASK)
00002a  070c              LSLS     r4,r1,#28
;;;315        {
;;;316            uspi->PROTIEN &= ~USPI_PROTIEN_SLVBEIEN_Msk;
00002c  2208              MOVS     r2,#8
00002e  2c00              CMP      r4,#0                 ;314
000030  da02              BGE      |L6.56|
000032  6e04              LDR      r4,[r0,#0x60]
000034  4394              BICS     r4,r4,r2
000036  6604              STR      r4,[r0,#0x60]
                  |L6.56|
;;;317        }
;;;318    
;;;319        /* Disable TX under run interrupt flag */
;;;320        if((u32Mask & USPI_TXUDR_INT_MASK) == USPI_TXUDR_INT_MASK)
000038  06cc              LSLS     r4,r1,#27
00003a  d503              BPL      |L6.68|
;;;321        {
;;;322            uspi->BUFCTL &= ~USPI_BUFCTL_TXUDRIEN_Msk;
00003c  6b84              LDR      r4,[r0,#0x38]
00003e  2640              MOVS     r6,#0x40
000040  43b4              BICS     r4,r4,r6
000042  6384              STR      r4,[r0,#0x38]
                  |L6.68|
;;;323        }
;;;324    
;;;325        /* Disable RX overrun interrupt flag */
;;;326        if((u32Mask & USPI_RXOV_INT_MASK) == USPI_RXOV_INT_MASK)
000044  068c              LSLS     r4,r1,#26
000046  d504              BPL      |L6.82|
;;;327        {
;;;328            uspi->BUFCTL &= ~USPI_BUFCTL_RXOVIEN_Msk;
000048  6b84              LDR      r4,[r0,#0x38]
00004a  2601              MOVS     r6,#1
00004c  03b6              LSLS     r6,r6,#14
00004e  43b4              BICS     r4,r4,r6
000050  6384              STR      r4,[r0,#0x38]
                  |L6.82|
;;;329        }
;;;330    
;;;331        /* Disable TX start interrupt flag */
;;;332        if((u32Mask & USPI_TXST_INT_MASK) == USPI_TXST_INT_MASK)
000052  064c              LSLS     r4,r1,#25
000054  d502              BPL      |L6.92|
;;;333        {
;;;334            uspi->INTEN &= ~USPI_INTEN_TXSTIEN_Msk;
000056  6844              LDR      r4,[r0,#4]
000058  43ac              BICS     r4,r4,r5
00005a  6044              STR      r4,[r0,#4]
                  |L6.92|
;;;335        }
;;;336    
;;;337        /* Disable TX end interrupt flag */
;;;338        if((u32Mask & USPI_TXEND_INT_MASK) == USPI_TXEND_INT_MASK)
00005c  060c              LSLS     r4,r1,#24
00005e  d502              BPL      |L6.102|
;;;339        {
;;;340            uspi->INTEN &= ~USPI_INTEN_TXENDIEN_Msk;
000060  6844              LDR      r4,[r0,#4]
000062  439c              BICS     r4,r4,r3
000064  6044              STR      r4,[r0,#4]
                  |L6.102|
;;;341        }
;;;342    
;;;343        /* Disable RX start interrupt flag */
;;;344        if((u32Mask & USPI_RXST_INT_MASK) == USPI_RXST_INT_MASK)
000066  05cb              LSLS     r3,r1,#23
000068  d502              BPL      |L6.112|
;;;345        {
;;;346            uspi->INTEN &= ~USPI_INTEN_RXSTIEN_Msk;
00006a  6843              LDR      r3,[r0,#4]
00006c  4393              BICS     r3,r3,r2
00006e  6043              STR      r3,[r0,#4]
                  |L6.112|
;;;347        }
;;;348    
;;;349        /* Disable RX end interrupt flag */
;;;350        if((u32Mask & USPI_RXEND_INT_MASK) == USPI_RXEND_INT_MASK)
000070  0589              LSLS     r1,r1,#22
000072  d503              BPL      |L6.124|
;;;351        {
;;;352            uspi->INTEN &= ~USPI_INTEN_RXENDIEN_Msk;
000074  6841              LDR      r1,[r0,#4]
000076  2210              MOVS     r2,#0x10
000078  4391              BICS     r1,r1,r2
00007a  6041              STR      r1,[r0,#4]
                  |L6.124|
;;;353        }
;;;354    }
00007c  bd70              POP      {r4-r6,pc}
;;;355    
                          ENDP


                          AREA ||i.USPI_DisableWakeup||, CODE, READONLY, ALIGN=1

                  USPI_DisableWakeup PROC
;;;601      */
;;;602    void USPI_DisableWakeup(USPI_T *uspi)
000000  6d41              LDR      r1,[r0,#0x54]
;;;603    {
;;;604        uspi->WKCTL &= ~USPI_WKCTL_WKEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  6541              STR      r1,[r0,#0x54]
;;;605    }
000008  4770              BX       lr
;;;606    
                          ENDP


                          AREA ||i.USPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  USPI_EnableAutoSS PROC
;;;149      */
;;;150    void USPI_EnableAutoSS(USPI_T *uspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;151    {
;;;152        uspi->LINECTL = (uspi->LINECTL & ~USPI_LINECTL_CTLOINV_Msk) | u32ActiveLevel;
000002  2380              MOVS     r3,#0x80
000004  4399              BICS     r1,r1,r3
000006  4311              ORRS     r1,r1,r2
000008  62c1              STR      r1,[r0,#0x2c]
;;;153        uspi->PROTCTL |= USPI_PROTCTL_AUTOSS_Msk;
00000a  6dc1              LDR      r1,[r0,#0x5c]
00000c  2208              MOVS     r2,#8
00000e  4311              ORRS     r1,r1,r2
000010  65c1              STR      r1,[r0,#0x5c]
;;;154    }
000012  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.USPI_EnableInt||, CODE, READONLY, ALIGN=1

                  USPI_EnableInt PROC
;;;211      */
;;;212    void USPI_EnableInt(USPI_T *uspi, uint32_t u32Mask)
000000  b570              PUSH     {r4-r6,lr}
;;;213    {
;;;214        /* Enable slave selection signal inactive interrupt flag */
;;;215        if((u32Mask & USPI_SSINACT_INT_MASK) == USPI_SSINACT_INT_MASK)
000002  07ca              LSLS     r2,r1,#31
000004  d003              BEQ      |L9.14|
;;;216        {
;;;217            uspi->PROTIEN |= USPI_PROTIEN_SSINAIEN_Msk;
000006  6e02              LDR      r2,[r0,#0x60]
000008  2301              MOVS     r3,#1
00000a  431a              ORRS     r2,r2,r3
00000c  6602              STR      r2,[r0,#0x60]
                  |L9.14|
;;;218        }
;;;219    
;;;220        /* Enable slave selection signal active interrupt flag */
;;;221        if((u32Mask & USPI_SSACT_INT_MASK) == USPI_SSACT_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
;;;222        {
;;;223            uspi->PROTIEN |= USPI_PROTIEN_SSACTIEN_Msk;
000010  2402              MOVS     r4,#2
000012  2a00              CMP      r2,#0                 ;221
000014  da02              BGE      |L9.28|
000016  6e02              LDR      r2,[r0,#0x60]
000018  4322              ORRS     r2,r2,r4
00001a  6602              STR      r2,[r0,#0x60]
                  |L9.28|
;;;224        }
;;;225    
;;;226        /* Enable slave time-out interrupt flag */
;;;227        if((u32Mask & USPI_SLVTO_INT_MASK) == USPI_SLVTO_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
;;;228        {
;;;229            uspi->PROTIEN |= USPI_PROTIEN_SLVTOIEN_Msk;
00001e  2504              MOVS     r5,#4
000020  2a00              CMP      r2,#0                 ;227
000022  da02              BGE      |L9.42|
000024  6e02              LDR      r2,[r0,#0x60]
000026  432a              ORRS     r2,r2,r5
000028  6602              STR      r2,[r0,#0x60]
                  |L9.42|
;;;230        }
;;;231    
;;;232        /* Enable slave bit count error interrupt flag */
;;;233        if((u32Mask & USPI_SLVBE_INT_MASK) == USPI_SLVBE_INT_MASK)
00002a  070a              LSLS     r2,r1,#28
;;;234        {
;;;235            uspi->PROTIEN |= USPI_PROTIEN_SLVBEIEN_Msk;
00002c  2308              MOVS     r3,#8
00002e  2a00              CMP      r2,#0                 ;233
000030  da02              BGE      |L9.56|
000032  6e02              LDR      r2,[r0,#0x60]
000034  431a              ORRS     r2,r2,r3
000036  6602              STR      r2,[r0,#0x60]
                  |L9.56|
;;;236        }
;;;237    
;;;238        /* Enable TX under run interrupt flag */
;;;239        if((u32Mask & USPI_TXUDR_INT_MASK) == USPI_TXUDR_INT_MASK)
000038  06ca              LSLS     r2,r1,#27
00003a  d503              BPL      |L9.68|
;;;240        {
;;;241            uspi->BUFCTL |= USPI_BUFCTL_TXUDRIEN_Msk;
00003c  6b82              LDR      r2,[r0,#0x38]
00003e  2640              MOVS     r6,#0x40
000040  4332              ORRS     r2,r2,r6
000042  6382              STR      r2,[r0,#0x38]
                  |L9.68|
;;;242        }
;;;243    
;;;244        /* Enable RX overrun interrupt flag */
;;;245        if((u32Mask & USPI_RXOV_INT_MASK) == USPI_RXOV_INT_MASK)
000044  068a              LSLS     r2,r1,#26
000046  d504              BPL      |L9.82|
;;;246        {
;;;247            uspi->BUFCTL |= USPI_BUFCTL_RXOVIEN_Msk;
000048  6b82              LDR      r2,[r0,#0x38]
00004a  2601              MOVS     r6,#1
00004c  03b6              LSLS     r6,r6,#14
00004e  4332              ORRS     r2,r2,r6
000050  6382              STR      r2,[r0,#0x38]
                  |L9.82|
;;;248        }
;;;249    
;;;250        /* Enable TX start interrupt flag */
;;;251        if((u32Mask & USPI_TXST_INT_MASK) == USPI_TXST_INT_MASK)
000052  064a              LSLS     r2,r1,#25
000054  d502              BPL      |L9.92|
;;;252        {
;;;253            uspi->INTEN |= USPI_INTEN_TXSTIEN_Msk;
000056  6842              LDR      r2,[r0,#4]
000058  4322              ORRS     r2,r2,r4
00005a  6042              STR      r2,[r0,#4]
                  |L9.92|
;;;254        }
;;;255    
;;;256        /* Enable TX end interrupt flag */
;;;257        if((u32Mask & USPI_TXEND_INT_MASK) == USPI_TXEND_INT_MASK)
00005c  060a              LSLS     r2,r1,#24
00005e  d502              BPL      |L9.102|
;;;258        {
;;;259            uspi->INTEN |= USPI_INTEN_TXENDIEN_Msk;
000060  6842              LDR      r2,[r0,#4]
000062  432a              ORRS     r2,r2,r5
000064  6042              STR      r2,[r0,#4]
                  |L9.102|
;;;260        }
;;;261    
;;;262        /* Enable RX start interrupt flag */
;;;263        if((u32Mask & USPI_RXST_INT_MASK) == USPI_RXST_INT_MASK)
000066  05ca              LSLS     r2,r1,#23
000068  d502              BPL      |L9.112|
;;;264        {
;;;265            uspi->INTEN |= USPI_INTEN_RXSTIEN_Msk;
00006a  6842              LDR      r2,[r0,#4]
00006c  431a              ORRS     r2,r2,r3
00006e  6042              STR      r2,[r0,#4]
                  |L9.112|
;;;266        }
;;;267    
;;;268        /* Enable RX end interrupt flag */
;;;269        if((u32Mask & USPI_RXEND_INT_MASK) == USPI_RXEND_INT_MASK)
000070  0589              LSLS     r1,r1,#22
000072  d503              BPL      |L9.124|
;;;270        {
;;;271            uspi->INTEN |= USPI_INTEN_RXENDIEN_Msk;
000074  6841              LDR      r1,[r0,#4]
000076  2210              MOVS     r2,#0x10
000078  4311              ORRS     r1,r1,r2
00007a  6041              STR      r1,[r0,#4]
                  |L9.124|
;;;272        }
;;;273    }
00007c  bd70              POP      {r4-r6,pc}
;;;274    
                          ENDP


                          AREA ||i.USPI_EnableWakeup||, CODE, READONLY, ALIGN=1

                  USPI_EnableWakeup PROC
;;;591      */
;;;592    void USPI_EnableWakeup(USPI_T *uspi)
000000  6d41              LDR      r1,[r0,#0x54]
;;;593    {
;;;594        uspi->WKCTL |= USPI_WKCTL_WKEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6541              STR      r1,[r0,#0x54]
;;;595    }
000008  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.USPI_GetBusClock||, CODE, READONLY, ALIGN=1

                  USPI_GetBusClock PROC
;;;182      */
;;;183    uint32_t USPI_GetBusClock(USPI_T *uspi)
000000  b510              PUSH     {r4,lr}
;;;184    {
;;;185        uint32_t u32ClkDiv, u32BusClk;
;;;186    
;;;187        u32ClkDiv = (uspi->BRGEN & USPI_BRGEN_CLKDIV_Msk) >> USPI_BRGEN_CLKDIV_Pos;
000002  6880              LDR      r0,[r0,#8]
;;;188    
;;;189        u32BusClk = (CLK_GetPCLK0Freq() / ((u32ClkDiv + 1UL) << 1UL));
;;;190    
;;;191        return u32BusClk;
;;;192    }
000004  0180              LSLS     r0,r0,#6
000006  0d84              LSRS     r4,r0,#22
000008  f7fffffe          BL       CLK_GetPCLK0Freq
00000c  0061              LSLS     r1,r4,#1              ;189
00000e  1c89              ADDS     r1,r1,#2              ;189
000010  f7fffffe          BL       __aeabi_uidivmod
000014  bd10              POP      {r4,pc}
;;;193    
                          ENDP


                          AREA ||i.USPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  USPI_GetIntFlag PROC
;;;373      */
;;;374    uint32_t USPI_GetIntFlag(USPI_T *uspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;375    {
000002  4603              MOV      r3,r0
;;;376        uint32_t u32ProtStatus, u32BufStatus;
;;;377        uint32_t u32IntFlag = 0UL;
;;;378    
;;;379        u32ProtStatus = uspi->PROTSTS;
000004  6e5a              LDR      r2,[r3,#0x64]
000006  2000              MOVS     r0,#0                 ;377
;;;380        u32BufStatus = uspi->BUFSTS;
000008  6bdb              LDR      r3,[r3,#0x3c]
;;;381    
;;;382        /* Check slave selection signal inactive interrupt flag */
;;;383        if((u32Mask & USPI_SSINACT_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_SSINAIF_Msk))
00000a  07cc              LSLS     r4,r1,#31
00000c  d002              BEQ      |L12.20|
00000e  05d4              LSLS     r4,r2,#23
000010  d500              BPL      |L12.20|
;;;384        {
;;;385            u32IntFlag |= USPI_SSINACT_INT_MASK;
000012  2001              MOVS     r0,#1
                  |L12.20|
;;;386        }
;;;387    
;;;388        /* Check slave selection signal active interrupt flag */
;;;389        if((u32Mask & USPI_SSACT_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_SSACTIF_Msk))
000014  078c              LSLS     r4,r1,#30
000016  d503              BPL      |L12.32|
000018  0594              LSLS     r4,r2,#22
00001a  d501              BPL      |L12.32|
;;;390        {
;;;391            u32IntFlag |= USPI_SSACT_INT_MASK;
00001c  2402              MOVS     r4,#2
00001e  4320              ORRS     r0,r0,r4
                  |L12.32|
;;;392        }
;;;393    
;;;394        /* Check slave time-out interrupt flag */
;;;395        if((u32Mask & USPI_SLVTO_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_SLVTOIF_Msk))
000020  074c              LSLS     r4,r1,#29
000022  d503              BPL      |L12.44|
000024  0694              LSLS     r4,r2,#26
000026  d501              BPL      |L12.44|
;;;396        {
;;;397            u32IntFlag |= USPI_SLVTO_INT_MASK;
000028  2404              MOVS     r4,#4
00002a  4320              ORRS     r0,r0,r4
                  |L12.44|
;;;398        }
;;;399    
;;;400        /* Check slave bit count error interrupt flag */
;;;401        if((u32Mask & USPI_SLVBE_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_SLVBEIF_Msk))
00002c  070c              LSLS     r4,r1,#28
00002e  d503              BPL      |L12.56|
000030  0654              LSLS     r4,r2,#25
000032  d501              BPL      |L12.56|
;;;402        {
;;;403            u32IntFlag |= USPI_SLVBE_INT_MASK;
000034  2408              MOVS     r4,#8
000036  4320              ORRS     r0,r0,r4
                  |L12.56|
;;;404        }
;;;405    
;;;406        /* Check TX under run interrupt flag */
;;;407        if((u32Mask & USPI_TXUDR_INT_MASK) && (u32BufStatus & USPI_BUFSTS_TXUDRIF_Msk))
000038  06cc              LSLS     r4,r1,#27
00003a  d503              BPL      |L12.68|
00003c  051c              LSLS     r4,r3,#20
00003e  d501              BPL      |L12.68|
;;;408        {
;;;409            u32IntFlag |= USPI_TXUDR_INT_MASK;
000040  2410              MOVS     r4,#0x10
000042  4320              ORRS     r0,r0,r4
                  |L12.68|
;;;410        }
;;;411    
;;;412        /* Check RX overrun interrupt flag */
;;;413        if((u32Mask & USPI_RXOV_INT_MASK) && (u32BufStatus & USPI_BUFSTS_RXOVIF_Msk))
000044  068c              LSLS     r4,r1,#26
000046  d503              BPL      |L12.80|
000048  071b              LSLS     r3,r3,#28
00004a  d501              BPL      |L12.80|
;;;414        {
;;;415            u32IntFlag |= USPI_RXOV_INT_MASK;
00004c  2320              MOVS     r3,#0x20
00004e  4318              ORRS     r0,r0,r3
                  |L12.80|
;;;416        }
;;;417    
;;;418        /* Check TX start interrupt flag */
;;;419        if((u32Mask & USPI_TXST_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_TXSTIF_Msk))
000050  064b              LSLS     r3,r1,#25
000052  d503              BPL      |L12.92|
000054  0793              LSLS     r3,r2,#30
000056  d501              BPL      |L12.92|
;;;420        {
;;;421            u32IntFlag |= USPI_TXST_INT_MASK;
000058  2340              MOVS     r3,#0x40
00005a  4318              ORRS     r0,r0,r3
                  |L12.92|
;;;422        }
;;;423    
;;;424        /* Check TX end interrupt flag */
;;;425        if((u32Mask & USPI_TXEND_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_TXENDIF_Msk))
00005c  060b              LSLS     r3,r1,#24
00005e  d503              BPL      |L12.104|
000060  0753              LSLS     r3,r2,#29
000062  d501              BPL      |L12.104|
;;;426        {
;;;427            u32IntFlag |= USPI_TXEND_INT_MASK;
000064  2380              MOVS     r3,#0x80
000066  4318              ORRS     r0,r0,r3
                  |L12.104|
;;;428        }
;;;429    
;;;430        /* Check RX start interrupt flag */
;;;431        if((u32Mask & USPI_RXST_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_RXSTIF_Msk))
000068  05cb              LSLS     r3,r1,#23
00006a  d504              BPL      |L12.118|
00006c  0713              LSLS     r3,r2,#28
00006e  d502              BPL      |L12.118|
;;;432        {
;;;433            u32IntFlag |= USPI_RXST_INT_MASK;
000070  23ff              MOVS     r3,#0xff
000072  3301              ADDS     r3,#1
000074  4318              ORRS     r0,r0,r3
                  |L12.118|
;;;434        }
;;;435    
;;;436        /* Check RX end interrupt flag */
;;;437        if((u32Mask & USPI_RXEND_INT_MASK) && (u32ProtStatus & USPI_PROTSTS_RXENDIF_Msk))
000076  0589              LSLS     r1,r1,#22
000078  d504              BPL      |L12.132|
00007a  06d1              LSLS     r1,r2,#27
00007c  d502              BPL      |L12.132|
;;;438        {
;;;439            u32IntFlag |= USPI_RXEND_INT_MASK;
00007e  2101              MOVS     r1,#1
000080  0249              LSLS     r1,r1,#9
000082  4308              ORRS     r0,r0,r1
                  |L12.132|
;;;440        }
;;;441    
;;;442        return u32IntFlag;
;;;443    }
000084  bd10              POP      {r4,pc}
;;;444    
                          ENDP


                          AREA ||i.USPI_GetStatus||, CODE, READONLY, ALIGN=1

                  USPI_GetStatus PROC
;;;539      */
;;;540    uint32_t USPI_GetStatus(USPI_T *uspi, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;541    {
000002  4602              MOV      r2,r0
;;;542        uint32_t u32ProtStatus, u32BufStatus;
;;;543        uint32_t u32Flag = 0UL;
;;;544    
;;;545        u32ProtStatus = uspi->PROTSTS;
000004  6e53              LDR      r3,[r2,#0x64]
000006  2000              MOVS     r0,#0                 ;543
;;;546        u32BufStatus = uspi->BUFSTS;
000008  6bd2              LDR      r2,[r2,#0x3c]
;;;547    
;;;548        /* Check busy status */
;;;549        if((u32Mask & USPI_BUSY_MASK) && (u32ProtStatus & USPI_PROTSTS_BUSY_Msk))
00000a  07cc              LSLS     r4,r1,#31
00000c  d002              BEQ      |L13.20|
00000e  039c              LSLS     r4,r3,#14
000010  d500              BPL      |L13.20|
;;;550        {
;;;551            u32Flag |= USPI_BUSY_MASK;
000012  2001              MOVS     r0,#1
                  |L13.20|
;;;552        }
;;;553    
;;;554        /* Check RX empty flag */
;;;555        if((u32Mask & USPI_RX_EMPTY_MASK) && (u32BufStatus & USPI_BUFSTS_RXEMPTY_Msk))
000014  078c              LSLS     r4,r1,#30
000016  d503              BPL      |L13.32|
000018  07d4              LSLS     r4,r2,#31
00001a  d001              BEQ      |L13.32|
;;;556        {
;;;557            u32Flag |= USPI_RX_EMPTY_MASK;
00001c  2402              MOVS     r4,#2
00001e  4320              ORRS     r0,r0,r4
                  |L13.32|
;;;558        }
;;;559    
;;;560        /* Check RX full flag */
;;;561        if((u32Mask & USPI_RX_FULL_MASK) && (u32BufStatus & USPI_BUFSTS_RXFULL_Msk))
000020  074c              LSLS     r4,r1,#29
000022  d503              BPL      |L13.44|
000024  0794              LSLS     r4,r2,#30
000026  d501              BPL      |L13.44|
;;;562        {
;;;563            u32Flag |= USPI_RX_FULL_MASK;
000028  2404              MOVS     r4,#4
00002a  4320              ORRS     r0,r0,r4
                  |L13.44|
;;;564        }
;;;565    
;;;566        /* Check TX empty flag */
;;;567        if((u32Mask & USPI_TX_EMPTY_MASK) && (u32BufStatus & USPI_BUFSTS_TXEMPTY_Msk))
00002c  070c              LSLS     r4,r1,#28
00002e  d503              BPL      |L13.56|
000030  05d4              LSLS     r4,r2,#23
000032  d501              BPL      |L13.56|
;;;568        {
;;;569            u32Flag |= USPI_TX_EMPTY_MASK;
000034  2408              MOVS     r4,#8
000036  4320              ORRS     r0,r0,r4
                  |L13.56|
;;;570        }
;;;571    
;;;572        /* Check TX full flag */
;;;573        if((u32Mask & USPI_TX_FULL_MASK) && (u32BufStatus & USPI_BUFSTS_TXFULL_Msk))
000038  06cc              LSLS     r4,r1,#27
00003a  d503              BPL      |L13.68|
00003c  0592              LSLS     r2,r2,#22
00003e  d501              BPL      |L13.68|
;;;574        {
;;;575            u32Flag |= USPI_TX_FULL_MASK;
000040  2210              MOVS     r2,#0x10
000042  4310              ORRS     r0,r0,r2
                  |L13.68|
;;;576        }
;;;577    
;;;578        /* Check USCI_SPI_SS line status */
;;;579        if((u32Mask & USPI_SSLINE_STS_MASK) && (u32ProtStatus & USPI_PROTSTS_SSLINE_Msk))
000044  0689              LSLS     r1,r1,#26
000046  d503              BPL      |L13.80|
000048  03d9              LSLS     r1,r3,#15
00004a  d501              BPL      |L13.80|
;;;580        {
;;;581            u32Flag |= USPI_SSLINE_STS_MASK;
00004c  2120              MOVS     r1,#0x20
00004e  4308              ORRS     r0,r0,r1
                  |L13.80|
;;;582        }
;;;583    
;;;584        return u32Flag;
;;;585    }
000050  bd10              POP      {r4,pc}
;;;586    
                          ENDP


                          AREA ||i.USPI_Open||, CODE, READONLY, ALIGN=2

                  USPI_Open PROC
;;;41       */
;;;42     uint32_t USPI_Open(USPI_T *uspi, uint32_t u32MasterSlave, uint32_t u32SPIMode,  uint32_t u32DataWidth, uint32_t u32BusClock)
000000  b5ff              PUSH     {r0-r7,lr}
;;;43     {
000002  b083              SUB      sp,sp,#0xc
;;;44         uint32_t u32ClkDiv = 0UL;
000004  2500              MOVS     r5,#0
000006  461e              MOV      r6,r3                 ;43
000008  460f              MOV      r7,r1                 ;43
00000a  4604              MOV      r4,r0                 ;43
;;;45         uint32_t u32Pclk;
;;;46         uint32_t u32RetValue = 0UL;
;;;47     
;;;48         u32Pclk = CLK_GetPCLK0Freq();
00000c  9500              STR      r5,[sp,#0]
00000e  f7fffffe          BL       CLK_GetPCLK0Freq
;;;49     
;;;50         if(u32BusClock != 0UL)
000012  9001              STR      r0,[sp,#4]
000014  980c              LDR      r0,[sp,#0x30]
000016  2800              CMP      r0,#0
000018  d00b              BEQ      |L14.50|
;;;51         {
;;;52             u32ClkDiv = (uint32_t)((((((u32Pclk / 2UL) * 10UL) / (u32BusClock)) + 5UL) / 10UL) - 1UL); /* Compute proper divider for USCI_SPI clock */
00001a  9801              LDR      r0,[sp,#4]
00001c  210a              MOVS     r1,#0xa
00001e  0840              LSRS     r0,r0,#1
000020  4348              MULS     r0,r1,r0
000022  990c              LDR      r1,[sp,#0x30]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  210a              MOVS     r1,#0xa
00002a  1d40              ADDS     r0,r0,#5
00002c  f7fffffe          BL       __aeabi_uidivmod
000030  1e45              SUBS     r5,r0,#1
                  |L14.50|
;;;53         }
;;;54     
;;;55         /* Enable USCI_SPI protocol */
;;;56         uspi->CTL &= ~USPI_CTL_FUNMODE_Msk;
000032  6820              LDR      r0,[r4,#0]
000034  08c0              LSRS     r0,r0,#3
000036  00c0              LSLS     r0,r0,#3
000038  6020              STR      r0,[r4,#0]
;;;57         uspi->CTL = 1UL << USPI_CTL_FUNMODE_Pos;
00003a  2001              MOVS     r0,#1
00003c  6020              STR      r0,[r4,#0]
;;;58     
;;;59         /* Data format configuration */
;;;60         if(u32DataWidth == 16UL)
00003e  2e10              CMP      r6,#0x10
000040  d100              BNE      |L14.68|
;;;61         {
;;;62             u32DataWidth = 0UL;
000042  2600              MOVS     r6,#0
                  |L14.68|
;;;63         }
;;;64         uspi->LINECTL &= ~USPI_LINECTL_DWIDTH_Msk;
000044  6ae0              LDR      r0,[r4,#0x2c]
000046  210f              MOVS     r1,#0xf
000048  0209              LSLS     r1,r1,#8
00004a  4388              BICS     r0,r0,r1
00004c  62e0              STR      r0,[r4,#0x2c]
;;;65         uspi->LINECTL |= (u32DataWidth << USPI_LINECTL_DWIDTH_Pos);
00004e  6ae0              LDR      r0,[r4,#0x2c]
000050  0231              LSLS     r1,r6,#8
000052  4308              ORRS     r0,r0,r1
000054  62e0              STR      r0,[r4,#0x2c]
;;;66     
;;;67         /* MSB data format */
;;;68         uspi->LINECTL &= ~USPI_LINECTL_LSB_Msk;
000056  6ae0              LDR      r0,[r4,#0x2c]
000058  0840              LSRS     r0,r0,#1
00005a  0040              LSLS     r0,r0,#1
00005c  62e0              STR      r0,[r4,#0x2c]
;;;69     
;;;70         /* Set slave selection signal active low */
;;;71         if(u32MasterSlave == USPI_MASTER)
00005e  2f00              CMP      r7,#0
000060  d024              BEQ      |L14.172|
;;;72         {
;;;73             uspi->LINECTL |= USPI_LINECTL_CTLOINV_Msk;
;;;74         }
;;;75         else
;;;76         {
;;;77             uspi->CTLIN0 |= USPI_CTLIN0_ININV_Msk;
000062  6a20              LDR      r0,[r4,#0x20]
000064  2104              MOVS     r1,#4
000066  4308              ORRS     r0,r0,r1
000068  6220              STR      r0,[r4,#0x20]
                  |L14.106|
;;;78         }
;;;79     
;;;80         /* Set operating mode and transfer timing */
;;;81         uspi->PROTCTL &= ~(USPI_PROTCTL_SCLKMODE_Msk | USPI_PROTCTL_AUTOSS_Msk | USPI_PROTCTL_SLAVE_Msk);
00006a  6de0              LDR      r0,[r4,#0x5c]
00006c  21c9              MOVS     r1,#0xc9
00006e  4388              BICS     r0,r0,r1
000070  65e0              STR      r0,[r4,#0x5c]
;;;82         uspi->PROTCTL |= (u32MasterSlave | u32SPIMode);
000072  6de0              LDR      r0,[r4,#0x5c]
000074  9905              LDR      r1,[sp,#0x14]
000076  430f              ORRS     r7,r7,r1
000078  4338              ORRS     r0,r0,r7
00007a  65e0              STR      r0,[r4,#0x5c]
;;;83     
;;;84         /* Set USCI_SPI bus clock */
;;;85         uspi->BRGEN &= ~USPI_BRGEN_CLKDIV_Msk;
00007c  68a0              LDR      r0,[r4,#8]
00007e  490f              LDR      r1,|L14.188|
000080  4008              ANDS     r0,r0,r1
000082  60a0              STR      r0,[r4,#8]
;;;86         uspi->BRGEN |= (u32ClkDiv << USPI_BRGEN_CLKDIV_Pos);
000084  68a0              LDR      r0,[r4,#8]
000086  0429              LSLS     r1,r5,#16
000088  4308              ORRS     r0,r0,r1
00008a  60a0              STR      r0,[r4,#8]
;;;87         uspi->PROTCTL |=  USPI_PROTCTL_PROTEN_Msk;
00008c  6de0              LDR      r0,[r4,#0x5c]
00008e  2101              MOVS     r1,#1
000090  07c9              LSLS     r1,r1,#31
000092  4308              ORRS     r0,r0,r1
000094  65e0              STR      r0,[r4,#0x5c]
;;;88     
;;;89         if(u32BusClock != 0UL)
000096  980c              LDR      r0,[sp,#0x30]
000098  2800              CMP      r0,#0
00009a  d00c              BEQ      |L14.182|
;;;90         {
;;;91             u32RetValue = (u32Pclk / ((u32ClkDiv + 1UL) << 1UL));
00009c  0069              LSLS     r1,r5,#1
00009e  1c89              ADDS     r1,r1,#2
0000a0  9801              LDR      r0,[sp,#4]
0000a2  f7fffffe          BL       __aeabi_uidivmod
0000a6  9000              STR      r0,[sp,#0]
                  |L14.168|
;;;92         }
;;;93         else
;;;94         {
;;;95             u32RetValue = 0UL;
;;;96         }
;;;97     
;;;98         return u32RetValue;
;;;99     }
0000a8  b007              ADD      sp,sp,#0x1c
0000aa  bdf0              POP      {r4-r7,pc}
                  |L14.172|
0000ac  6ae0              LDR      r0,[r4,#0x2c]         ;73
0000ae  2180              MOVS     r1,#0x80              ;73
0000b0  4308              ORRS     r0,r0,r1              ;73
0000b2  62e0              STR      r0,[r4,#0x2c]         ;73
0000b4  e7d9              B        |L14.106|
                  |L14.182|
0000b6  9800              LDR      r0,[sp,#0]            ;98
0000b8  e7f6              B        |L14.168|
;;;100    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L14.188|
                          DCD      0xfc00ffff

                          AREA ||i.USPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  USPI_SetBusClock PROC
;;;161      */
;;;162    uint32_t USPI_SetBusClock(USPI_T *uspi, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;163    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;164        uint32_t u32ClkDiv;
;;;165        uint32_t u32Pclk;
;;;166    
;;;167        u32Pclk = CLK_GetPCLK0Freq();
000006  f7fffffe          BL       CLK_GetPCLK0Freq
00000a  4605              MOV      r5,r0
;;;168    
;;;169        u32ClkDiv = (uint32_t)((((((u32Pclk / 2UL) * 10UL) / (u32BusClock)) + 5UL) / 10UL) - 1UL); /* Compute proper divider for USCI_SPI clock */
00000c  0840              LSRS     r0,r0,#1
00000e  210a              MOVS     r1,#0xa
000010  4348              MULS     r0,r1,r0
000012  4631              MOV      r1,r6
000014  f7fffffe          BL       __aeabi_uidivmod
000018  210a              MOVS     r1,#0xa
00001a  1d40              ADDS     r0,r0,#5
00001c  f7fffffe          BL       __aeabi_uidivmod
;;;170    
;;;171        /* Set USCI_SPI bus clock */
;;;172        uspi->BRGEN &= ~USPI_BRGEN_CLKDIV_Msk;
000020  68a1              LDR      r1,[r4,#8]
000022  4a07              LDR      r2,|L15.64|
000024  4011              ANDS     r1,r1,r2
000026  60a1              STR      r1,[r4,#8]
;;;173        uspi->BRGEN |= (u32ClkDiv << USPI_BRGEN_CLKDIV_Pos);
000028  68a1              LDR      r1,[r4,#8]
00002a  1e40              SUBS     r0,r0,#1
00002c  0402              LSLS     r2,r0,#16
00002e  4311              ORRS     r1,r1,r2
000030  60a1              STR      r1,[r4,#8]
;;;174    
;;;175        return (u32Pclk / ((u32ClkDiv + 1UL) << 1UL));
000032  0041              LSLS     r1,r0,#1
000034  4628              MOV      r0,r5
000036  1c89              ADDS     r1,r1,#2
000038  f7fffffe          BL       __aeabi_uidivmod
;;;176    }
00003c  bd70              POP      {r4-r6,pc}
;;;177    
                          ENDP

00003e  0000              DCW      0x0000
                  |L15.64|
                          DCD      0xfc00ffff

;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\usci_spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_spi_c_91a2fd3d____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___10_usci_spi_c_91a2fd3d____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usci_spi_c_91a2fd3d____REVSH|
#line 402
|__asm___10_usci_spi_c_91a2fd3d____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
