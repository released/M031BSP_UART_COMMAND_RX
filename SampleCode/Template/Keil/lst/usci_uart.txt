; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\usci_uart.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\usci_uart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\usci_uart.crf ..\..\..\Library\StdDriver\src\usci_uart.c]
                          THUMB

                          AREA ||i.UUART_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_ClearIntFlag PROC
;;;43     
;;;44     void UUART_ClearIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  078a              LSLS     r2,r1,#30
;;;45     {
000002  d502              BPL      |L1.10|
;;;46     
;;;47         if(u32Mask & UUART_ABR_INT_MASK)   /* Clear Auto-baud Rate Interrupt */
;;;48         {
;;;49             uuart->PROTSTS = UUART_PROTSTS_ABRDETIF_Msk;
000004  2201              MOVS     r2,#1
000006  0252              LSLS     r2,r2,#9
000008  6642              STR      r2,[r0,#0x64]
                  |L1.10|
;;;50         }
;;;51     
;;;52         if(u32Mask & UUART_RLS_INT_MASK)   /* Clear Receive Line Status Interrupt */
00000a  074a              LSLS     r2,r1,#29
00000c  d501              BPL      |L1.18|
;;;53         {
;;;54             uuart->PROTSTS = (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk);
00000e  22e0              MOVS     r2,#0xe0
000010  6642              STR      r2,[r0,#0x64]
                  |L1.18|
;;;55         }
;;;56     
;;;57         if(u32Mask & UUART_BUF_RXOV_INT_MASK)   /* Clear Receive Buffer Over-run Error Interrupt */
000012  070b              LSLS     r3,r1,#28
;;;58         {
;;;59             uuart->BUFSTS = UUART_BUFSTS_RXOVIF_Msk;
000014  2208              MOVS     r2,#8
000016  2b00              CMP      r3,#0                 ;57
000018  da00              BGE      |L1.28|
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L1.28|
;;;60         }
;;;61     
;;;62         if(u32Mask & UUART_TXST_INT_MASK)   /* Clear Transmit Start Interrupt */
00001c  06cb              LSLS     r3,r1,#27
00001e  d501              BPL      |L1.36|
;;;63         {
;;;64             uuart->PROTSTS = UUART_PROTSTS_TXSTIF_Msk;
000020  2302              MOVS     r3,#2
000022  6643              STR      r3,[r0,#0x64]
                  |L1.36|
;;;65         }
;;;66     
;;;67         if(u32Mask & UUART_TXEND_INT_MASK)   /* Clear Transmit End Interrupt */
000024  068b              LSLS     r3,r1,#26
000026  d501              BPL      |L1.44|
;;;68         {
;;;69             uuart->PROTSTS = UUART_PROTSTS_TXENDIF_Msk;
000028  2304              MOVS     r3,#4
00002a  6643              STR      r3,[r0,#0x64]
                  |L1.44|
;;;70         }
;;;71     
;;;72         if(u32Mask & UUART_RXST_INT_MASK)   /* Clear Receive Start Interrupt */
00002c  064b              LSLS     r3,r1,#25
00002e  d500              BPL      |L1.50|
;;;73         {
;;;74             uuart->PROTSTS = UUART_PROTSTS_RXSTIF_Msk;
000030  6642              STR      r2,[r0,#0x64]
                  |L1.50|
;;;75         }
;;;76     
;;;77         if(u32Mask & UUART_RXEND_INT_MASK)   /* Clear Receive End Interrupt */
000032  0609              LSLS     r1,r1,#24
000034  d501              BPL      |L1.58|
;;;78         {
;;;79             uuart->PROTSTS = UUART_PROTSTS_RXENDIF_Msk;
000036  2110              MOVS     r1,#0x10
000038  6641              STR      r1,[r0,#0x64]
                  |L1.58|
;;;80         }
;;;81     
;;;82     }
00003a  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.UUART_Close||, CODE, READONLY, ALIGN=1

                  UUART_Close PROC
;;;178     */
;;;179    void UUART_Close(UUART_T* uuart)
000000  2100              MOVS     r1,#0
;;;180    {
;;;181        uuart->CTL = 0UL;
000002  6001              STR      r1,[r0,#0]
;;;182    }
000004  4770              BX       lr
;;;183    
                          ENDP


                          AREA ||i.UUART_DisableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_DisableFlowCtrl PROC
;;;700     */
;;;701    void UUART_DisableFlowCtrl(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;702    {
;;;703        /* Disable CTS and RTS auto flow control function */
;;;704        uuart->PROTCTL &= ~(UUART_PROTCTL_RTSAUTOEN_Msk | UUART_PROTCTL_CTSAUTOEN_Msk);
000002  2218              MOVS     r2,#0x18
000004  4391              BICS     r1,r1,r2
000006  65c1              STR      r1,[r0,#0x5c]
;;;705    }
000008  4770              BX       lr
;;;706    
                          ENDP


                          AREA ||i.UUART_DisableInt||, CODE, READONLY, ALIGN=1

                  UUART_DisableInt PROC
;;;203     */
;;;204    void UUART_DisableInt(UUART_T* uuart, uint32_t u32Mask)
000000  b530              PUSH     {r4,r5,lr}
;;;205    {
;;;206    
;;;207        /* Disable Auto-baud rate interrupt flag */
;;;208        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
000002  078a              LSLS     r2,r1,#30
;;;209        {
;;;210            uuart->PROTIEN &= ~UUART_PROTIEN_ABRIEN_Msk;
000004  2302              MOVS     r3,#2
000006  2a00              CMP      r2,#0                 ;208
000008  da02              BGE      |L4.16|
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  439a              BICS     r2,r2,r3
00000e  6602              STR      r2,[r0,#0x60]
                  |L4.16|
;;;211        }
;;;212    
;;;213        /* Disable receive line status interrupt flag */
;;;214        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
000010  074a              LSLS     r2,r1,#29
;;;215        {
;;;216            uuart->PROTIEN &= ~UUART_PROTIEN_RLSIEN_Msk;
000012  2404              MOVS     r4,#4
000014  2a00              CMP      r2,#0                 ;214
000016  da02              BGE      |L4.30|
000018  6e02              LDR      r2,[r0,#0x60]
00001a  43a2              BICS     r2,r2,r4
00001c  6602              STR      r2,[r0,#0x60]
                  |L4.30|
;;;217        }
;;;218    
;;;219        /* Disable RX overrun interrupt flag */
;;;220        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
00001e  070a              LSLS     r2,r1,#28
000020  d504              BPL      |L4.44|
;;;221        {
;;;222            uuart->BUFCTL &= ~UUART_BUFCTL_RXOVIEN_Msk;
000022  6b82              LDR      r2,[r0,#0x38]
000024  2501              MOVS     r5,#1
000026  03ad              LSLS     r5,r5,#14
000028  43aa              BICS     r2,r2,r5
00002a  6382              STR      r2,[r0,#0x38]
                  |L4.44|
;;;223        }
;;;224    
;;;225        /* Disable TX start interrupt flag */
;;;226        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
00002c  06ca              LSLS     r2,r1,#27
00002e  d502              BPL      |L4.54|
;;;227        {
;;;228            uuart->INTEN &= ~UUART_INTEN_TXSTIEN_Msk;
000030  6842              LDR      r2,[r0,#4]
000032  439a              BICS     r2,r2,r3
000034  6042              STR      r2,[r0,#4]
                  |L4.54|
;;;229        }
;;;230    
;;;231        /* Disable TX end interrupt flag */
;;;232        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000036  068a              LSLS     r2,r1,#26
000038  d502              BPL      |L4.64|
;;;233        {
;;;234            uuart->INTEN &= ~UUART_INTEN_TXENDIEN_Msk;
00003a  6842              LDR      r2,[r0,#4]
00003c  43a2              BICS     r2,r2,r4
00003e  6042              STR      r2,[r0,#4]
                  |L4.64|
;;;235        }
;;;236    
;;;237        /* Disable RX start interrupt flag */
;;;238        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
000040  064a              LSLS     r2,r1,#25
000042  d503              BPL      |L4.76|
;;;239        {
;;;240            uuart->INTEN &= ~UUART_INTEN_RXSTIEN_Msk;
000044  6842              LDR      r2,[r0,#4]
000046  2308              MOVS     r3,#8
000048  439a              BICS     r2,r2,r3
00004a  6042              STR      r2,[r0,#4]
                  |L4.76|
;;;241        }
;;;242    
;;;243        /* Disable RX end interrupt flag */
;;;244        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
00004c  0609              LSLS     r1,r1,#24
00004e  d503              BPL      |L4.88|
;;;245        {
;;;246            uuart->INTEN &= ~UUART_INTEN_RXENDIEN_Msk;
000050  6841              LDR      r1,[r0,#4]
000052  2210              MOVS     r2,#0x10
000054  4391              BICS     r1,r1,r2
000056  6041              STR      r1,[r0,#4]
                  |L4.88|
;;;247        }
;;;248    }
000058  bd30              POP      {r4,r5,pc}
;;;249    
                          ENDP


                          AREA ||i.UUART_DisableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_DisableWakeup PROC
;;;664     */
;;;665    void UUART_DisableWakeup(UUART_T* uuart)
000000  6dc1              LDR      r1,[r0,#0x5c]
;;;666    {
;;;667        uuart->PROTCTL &= ~(UUART_PROTCTL_DATWKEN_Msk | UUART_PROTCTL_CTSWKEN_Msk);
000002  2203              MOVS     r2,#3
000004  0252              LSLS     r2,r2,#9
000006  4391              BICS     r1,r1,r2
000008  65c1              STR      r1,[r0,#0x5c]
;;;668        uuart->WKCTL &= ~UUART_WKCTL_WKEN_Msk;
00000a  6d41              LDR      r1,[r0,#0x54]
00000c  0849              LSRS     r1,r1,#1
00000e  0049              LSLS     r1,r1,#1
000010  6541              STR      r1,[r0,#0x54]
;;;669    }
000012  4770              BX       lr
;;;670    
                          ENDP


                          AREA ||i.UUART_EnableFlowCtrl||, CODE, READONLY, ALIGN=1

                  UUART_EnableFlowCtrl PROC
;;;679     */
;;;680    void UUART_EnableFlowCtrl(UUART_T* uuart)
000000  6ac1              LDR      r1,[r0,#0x2c]
;;;681    {
;;;682        /* Set RTS signal is low level active */
;;;683        uuart->LINECTL &= ~UUART_LINECTL_CTLOINV_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  62c1              STR      r1,[r0,#0x2c]
;;;684    
;;;685        /* Set CTS signal is low level active */
;;;686        uuart->CTLIN0 &= ~UUART_CTLIN0_ININV_Msk;
000008  6a01              LDR      r1,[r0,#0x20]
00000a  2204              MOVS     r2,#4
00000c  4391              BICS     r1,r1,r2
00000e  6201              STR      r1,[r0,#0x20]
;;;687    
;;;688        /* Enable CTS and RTS auto flow control function */
;;;689        uuart->PROTCTL |= UUART_PROTCTL_RTSAUTOEN_Msk | UUART_PROTCTL_CTSAUTOEN_Msk;
000010  6dc1              LDR      r1,[r0,#0x5c]
000012  2218              MOVS     r2,#0x18
000014  4311              ORRS     r1,r1,r2
000016  65c1              STR      r1,[r0,#0x5c]
;;;690    }
000018  4770              BX       lr
;;;691    
                          ENDP


                          AREA ||i.UUART_EnableInt||, CODE, READONLY, ALIGN=1

                  UUART_EnableInt PROC
;;;269     */
;;;270    void UUART_EnableInt(UUART_T*  uuart, uint32_t u32Mask)
000000  b530              PUSH     {r4,r5,lr}
;;;271    {
;;;272        /* Enable Auto-baud rate interrupt flag */
;;;273        if((u32Mask & UUART_ABR_INT_MASK) == UUART_ABR_INT_MASK)
000002  078a              LSLS     r2,r1,#30
;;;274        {
;;;275            uuart->PROTIEN |= UUART_PROTIEN_ABRIEN_Msk;
000004  2402              MOVS     r4,#2
000006  2a00              CMP      r2,#0                 ;273
000008  da02              BGE      |L7.16|
00000a  6e02              LDR      r2,[r0,#0x60]
00000c  4322              ORRS     r2,r2,r4
00000e  6602              STR      r2,[r0,#0x60]
                  |L7.16|
;;;276        }
;;;277    
;;;278        /* Enable receive line status interrupt flag */
;;;279        if((u32Mask & UUART_RLS_INT_MASK) == UUART_RLS_INT_MASK)
000010  074a              LSLS     r2,r1,#29
;;;280        {
;;;281            uuart->PROTIEN |= UUART_PROTIEN_RLSIEN_Msk;
000012  2304              MOVS     r3,#4
000014  2a00              CMP      r2,#0                 ;279
000016  da02              BGE      |L7.30|
000018  6e02              LDR      r2,[r0,#0x60]
00001a  431a              ORRS     r2,r2,r3
00001c  6602              STR      r2,[r0,#0x60]
                  |L7.30|
;;;282        }
;;;283    
;;;284        /* Enable RX overrun interrupt flag */
;;;285        if((u32Mask & UUART_BUF_RXOV_INT_MASK) == UUART_BUF_RXOV_INT_MASK)
00001e  070a              LSLS     r2,r1,#28
000020  d504              BPL      |L7.44|
;;;286        {
;;;287            uuart->BUFCTL |= UUART_BUFCTL_RXOVIEN_Msk;
000022  6b82              LDR      r2,[r0,#0x38]
000024  2501              MOVS     r5,#1
000026  03ad              LSLS     r5,r5,#14
000028  432a              ORRS     r2,r2,r5
00002a  6382              STR      r2,[r0,#0x38]
                  |L7.44|
;;;288        }
;;;289    
;;;290        /* Enable TX start interrupt flag */
;;;291        if((u32Mask & UUART_TXST_INT_MASK) == UUART_TXST_INT_MASK)
00002c  06ca              LSLS     r2,r1,#27
00002e  d502              BPL      |L7.54|
;;;292        {
;;;293            uuart->INTEN |= UUART_INTEN_TXSTIEN_Msk;
000030  6842              LDR      r2,[r0,#4]
000032  4322              ORRS     r2,r2,r4
000034  6042              STR      r2,[r0,#4]
                  |L7.54|
;;;294        }
;;;295    
;;;296        /* Enable TX end interrupt flag */
;;;297        if((u32Mask & UUART_TXEND_INT_MASK) == UUART_TXEND_INT_MASK)
000036  068a              LSLS     r2,r1,#26
000038  d502              BPL      |L7.64|
;;;298        {
;;;299            uuart->INTEN |= UUART_INTEN_TXENDIEN_Msk;
00003a  6842              LDR      r2,[r0,#4]
00003c  431a              ORRS     r2,r2,r3
00003e  6042              STR      r2,[r0,#4]
                  |L7.64|
;;;300        }
;;;301    
;;;302        /* Enable RX start interrupt flag */
;;;303        if((u32Mask & UUART_RXST_INT_MASK) == UUART_RXST_INT_MASK)
000040  064a              LSLS     r2,r1,#25
000042  d503              BPL      |L7.76|
;;;304        {
;;;305            uuart->INTEN |= UUART_INTEN_RXSTIEN_Msk;
000044  6842              LDR      r2,[r0,#4]
000046  2308              MOVS     r3,#8
000048  431a              ORRS     r2,r2,r3
00004a  6042              STR      r2,[r0,#4]
                  |L7.76|
;;;306        }
;;;307    
;;;308        /* Enable RX end interrupt flag */
;;;309        if((u32Mask & UUART_RXEND_INT_MASK) == UUART_RXEND_INT_MASK)
00004c  0609              LSLS     r1,r1,#24
00004e  d503              BPL      |L7.88|
;;;310        {
;;;311            uuart->INTEN |= UUART_INTEN_RXENDIEN_Msk;
000050  6841              LDR      r1,[r0,#4]
000052  2210              MOVS     r2,#0x10
000054  4311              ORRS     r1,r1,r2
000056  6041              STR      r1,[r0,#4]
                  |L7.88|
;;;312        }
;;;313    }
000058  bd30              POP      {r4,r5,pc}
;;;314    
                          ENDP


                          AREA ||i.UUART_EnableWakeup||, CODE, READONLY, ALIGN=1

                  UUART_EnableWakeup PROC
;;;648     */
;;;649    void UUART_EnableWakeup(UUART_T* uuart, uint32_t u32WakeupMode)
000000  6dc2              LDR      r2,[r0,#0x5c]
;;;650    {
;;;651        uuart->PROTCTL |= u32WakeupMode;
000002  430a              ORRS     r2,r2,r1
000004  65c2              STR      r2,[r0,#0x5c]
;;;652        uuart->WKCTL |= UUART_WKCTL_WKEN_Msk;
000006  6d41              LDR      r1,[r0,#0x54]
000008  2201              MOVS     r2,#1
00000a  4311              ORRS     r1,r1,r2
00000c  6541              STR      r1,[r0,#0x54]
;;;653    }
00000e  4770              BX       lr
;;;654    
                          ENDP


                          AREA ||i.UUART_GetIntFlag||, CODE, READONLY, ALIGN=1

                  UUART_GetIntFlag PROC
;;;104    
;;;105    uint32_t UUART_GetIntFlag(UUART_T* uuart, uint32_t u32Mask)
000000  b5f0              PUSH     {r4-r7,lr}
;;;106    {
000002  4602              MOV      r2,r0
;;;107        uint32_t u32IntFlag = 0ul;
000004  2000              MOVS     r0,#0
;;;108        uint32_t u32Tmp1, u32Tmp2;
;;;109    
;;;110        /* Check Auto-baud Rate Interrupt Flag */
;;;111        u32Tmp1 = (u32Mask & UUART_ABR_INT_MASK);
000006  2702              MOVS     r7,#2
000008  460b              MOV      r3,r1
;;;112        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_ABRDETIF_Msk);
00000a  6e54              LDR      r4,[r2,#0x64]
00000c  403b              ANDS     r3,r3,r7              ;111
00000e  023d              LSLS     r5,r7,#8
000010  402c              ANDS     r4,r4,r5
;;;113        if(u32Tmp1 && u32Tmp2)
000012  2b00              CMP      r3,#0
000014  d002              BEQ      |L9.28|
000016  2c00              CMP      r4,#0
000018  d000              BEQ      |L9.28|
;;;114        {
;;;115            u32IntFlag |= UUART_ABR_INT_MASK;
00001a  2002              MOVS     r0,#2
                  |L9.28|
;;;116        }
;;;117    
;;;118        /* Check Receive Line Status Interrupt Flag */
;;;119        u32Tmp1 = (u32Mask & UUART_RLS_INT_MASK);
00001c  2404              MOVS     r4,#4
00001e  460b              MOV      r3,r1
;;;120        u32Tmp2 = (uuart->PROTSTS & (UUART_PROTSTS_BREAK_Msk | UUART_PROTSTS_FRMERR_Msk | UUART_PROTSTS_PARITYERR_Msk));
000020  6e55              LDR      r5,[r2,#0x64]
000022  4023              ANDS     r3,r3,r4              ;119
000024  26e0              MOVS     r6,#0xe0
000026  4035              ANDS     r5,r5,r6
;;;121        if(u32Tmp1 && u32Tmp2)
000028  2b00              CMP      r3,#0
00002a  d002              BEQ      |L9.50|
00002c  2d00              CMP      r5,#0
00002e  d000              BEQ      |L9.50|
;;;122        {
;;;123            u32IntFlag |= UUART_RLS_INT_MASK;
000030  4320              ORRS     r0,r0,r4
                  |L9.50|
;;;124        }
;;;125    
;;;126        /* Check Receive Buffer Over-run Error Interrupt Flag */
;;;127        u32Tmp1 = (u32Mask & UUART_BUF_RXOV_INT_MASK);
000032  2308              MOVS     r3,#8
000034  460d              MOV      r5,r1
;;;128        u32Tmp2 = (uuart->BUFSTS & UUART_BUFSTS_RXOVIF_Msk);
000036  6bd6              LDR      r6,[r2,#0x3c]
000038  401d              ANDS     r5,r5,r3              ;127
00003a  401e              ANDS     r6,r6,r3
;;;129        if(u32Tmp1 && u32Tmp2)
00003c  2d00              CMP      r5,#0
00003e  d002              BEQ      |L9.70|
000040  2e00              CMP      r6,#0
000042  d000              BEQ      |L9.70|
;;;130        {
;;;131            u32IntFlag |= UUART_BUF_RXOV_INT_MASK;
000044  4318              ORRS     r0,r0,r3
                  |L9.70|
;;;132        }
;;;133    
;;;134        /* Check Transmit Start Interrupt Flag */
;;;135        u32Tmp1 = (u32Mask & UUART_TXST_INT_MASK);
000046  2510              MOVS     r5,#0x10
000048  460e              MOV      r6,r1
00004a  402e              ANDS     r6,r6,r5
00004c  46b4              MOV      r12,r6
;;;136        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_TXSTIF_Msk);
00004e  6e56              LDR      r6,[r2,#0x64]
000050  403e              ANDS     r6,r6,r7
;;;137        if(u32Tmp1 && u32Tmp2)
000052  4667              MOV      r7,r12
000054  2f00              CMP      r7,#0
000056  d002              BEQ      |L9.94|
000058  2e00              CMP      r6,#0
00005a  d000              BEQ      |L9.94|
;;;138        {
;;;139            u32IntFlag |= UUART_TXST_INT_MASK;
00005c  4328              ORRS     r0,r0,r5
                  |L9.94|
;;;140        }
;;;141    
;;;142        /* Check Transmit End Interrupt Flag */
;;;143        u32Tmp1 = (u32Mask & UUART_TXEND_INT_MASK);
00005e  2620              MOVS     r6,#0x20
;;;144        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_TXENDIF_Msk);
000060  6e57              LDR      r7,[r2,#0x64]
000062  400e              ANDS     r6,r6,r1              ;143
000064  4027              ANDS     r7,r7,r4
;;;145        if(u32Tmp1 && u32Tmp2)
000066  2e00              CMP      r6,#0
000068  d003              BEQ      |L9.114|
00006a  2f00              CMP      r7,#0
00006c  d001              BEQ      |L9.114|
;;;146        {
;;;147            u32IntFlag |= UUART_TXEND_INT_MASK;
00006e  2420              MOVS     r4,#0x20
000070  4320              ORRS     r0,r0,r4
                  |L9.114|
;;;148        }
;;;149    
;;;150        /* Check Receive Start Interrupt Flag */
;;;151        u32Tmp1 = (u32Mask & UUART_RXST_INT_MASK);
000072  2740              MOVS     r7,#0x40
000074  460c              MOV      r4,r1
;;;152        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_RXSTIF_Msk);
000076  6e56              LDR      r6,[r2,#0x64]
000078  403c              ANDS     r4,r4,r7              ;151
00007a  401e              ANDS     r6,r6,r3
;;;153        if(u32Tmp1 && u32Tmp2)
00007c  2c00              CMP      r4,#0
00007e  d002              BEQ      |L9.134|
000080  2e00              CMP      r6,#0
000082  d000              BEQ      |L9.134|
;;;154        {
;;;155            u32IntFlag |= UUART_RXST_INT_MASK;
000084  4338              ORRS     r0,r0,r7
                  |L9.134|
;;;156        }
;;;157    
;;;158        /* Check Receive End Interrupt Flag */
;;;159        u32Tmp1 = (u32Mask & UUART_RXEND_INT_MASK);
000086  2380              MOVS     r3,#0x80
;;;160        u32Tmp2 = (uuart->PROTSTS & UUART_PROTSTS_RXENDIF_Msk);
000088  6e52              LDR      r2,[r2,#0x64]
00008a  4019              ANDS     r1,r1,r3              ;159
00008c  402a              ANDS     r2,r2,r5
;;;161        if(u32Tmp1 && u32Tmp2)
00008e  2900              CMP      r1,#0
000090  d002              BEQ      |L9.152|
000092  2a00              CMP      r2,#0
000094  d000              BEQ      |L9.152|
;;;162        {
;;;163            u32IntFlag |= UUART_RXEND_INT_MASK;
000096  4318              ORRS     r0,r0,r3
                  |L9.152|
;;;164        }
;;;165    
;;;166        return u32IntFlag;
;;;167    }
000098  bdf0              POP      {r4-r7,pc}
;;;168    
                          ENDP


                          AREA ||i.UUART_Open||, CODE, READONLY, ALIGN=2

                  UUART_Open PROC
;;;325     */
;;;326    uint32_t UUART_Open(UUART_T* uuart, uint32_t u32baudrate)
000000  b5f0              PUSH     {r4-r7,lr}
;;;327    {
000002  b085              SUB      sp,sp,#0x14
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;328        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;329        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;330        uint32_t u32Div;
;;;331    
;;;332        /* Get PCLK frequency */
;;;333        u32PCLKFreq = CLK_GetPCLK0Freq();
000008  f7fffffe          BL       CLK_GetPCLK0Freq
;;;334    
;;;335        /* Calculate baud rate divider */
;;;336        u32Div = u32PCLKFreq / u32baudrate;
00000c  4629              MOV      r1,r5
00000e  9003              STR      r0,[sp,#0xc]
000010  f7fffffe          BL       __aeabi_uidivmod
000014  4604              MOV      r4,r0
;;;337        u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
000016  4601              MOV      r1,r0
000018  9803              LDR      r0,[sp,#0xc]
00001a  f7fffffe          BL       __aeabi_uidivmod
00001e  1b47              SUBS     r7,r0,r5
;;;338        u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div + 1ul));
000020  1c61              ADDS     r1,r4,#1
000022  9803              LDR      r0,[sp,#0xc]
000024  f7fffffe          BL       __aeabi_uidivmod
000028  1a28              SUBS     r0,r5,r0
;;;339    
;;;340        if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
00002a  4287              CMP      r7,r0
00002c  d300              BCC      |L10.48|
00002e  1c64              ADDS     r4,r4,#1
                  |L10.48|
;;;341    
;;;342        if(u32Div >= 65536ul)
000030  2001              MOVS     r0,#1
000032  0400              LSLS     r0,r0,#16
000034  4284              CMP      r4,r0
000036  d305              BCC      |L10.68|
;;;343        {
;;;344    
;;;345            /* Set the smallest baud rate that USCI_UART can generate */
;;;346            u32PDSCnt = 0x4ul;
;;;347            u32MinDSCnt = 0x10ul;
000038  2010              MOVS     r0,#0x10
00003a  2504              MOVS     r5,#4                 ;346
;;;348            u32MinClkDiv = 0x400ul;
00003c  9000              STR      r0,[sp,#0]
00003e  0180              LSLS     r0,r0,#6
000040  9001              STR      r0,[sp,#4]
000042  e03c              B        |L10.190|
                  |L10.68|
;;;349    
;;;350        }
;;;351        else
;;;352        {
;;;353    
;;;354            u32Tmp = 0x400ul * 0x10ul;
000044  2101              MOVS     r1,#1
000046  0389              LSLS     r1,r1,#14
;;;355            for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
000048  2501              MOVS     r5,#1
                  |L10.74|
;;;356            {
;;;357                if(u32Div <= (u32Tmp * u32PDSCnt)) break;
00004a  4608              MOV      r0,r1
00004c  4368              MULS     r0,r5,r0
00004e  42a0              CMP      r0,r4
000050  d203              BCS      |L10.90|
000052  1c6d              ADDS     r5,r5,#1
000054  2d04              CMP      r5,#4                 ;355
000056  d9f8              BLS      |L10.74|
000058  e001              B        |L10.94|
                  |L10.90|
;;;358            }
;;;359    
;;;360            if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
00005a  2d04              CMP      r5,#4
00005c  d900              BLS      |L10.96|
                  |L10.94|
00005e  2504              MOVS     r5,#4
                  |L10.96|
;;;361    
;;;362            u32Div = u32Div / u32PDSCnt;
000060  4629              MOV      r1,r5
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       __aeabi_uidivmod
;;;363    
;;;364            /* Find best solution */
;;;365            u32Min = (uint32_t) - 1;
;;;366            u32MinDSCnt = 0ul;
000068  9002              STR      r0,[sp,#8]
00006a  2000              MOVS     r0,#0
00006c  2700              MOVS     r7,#0                 ;365
00006e  43ff              MVNS     r7,r7                 ;365
;;;367            u32MinClkDiv = 0ul;
000070  9000              STR      r0,[sp,#0]
;;;368            u32Tmp = 0ul;
;;;369    
;;;370            for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
000072  2406              MOVS     r4,#6
000074  9001              STR      r0,[sp,#4]
                  |L10.118|
;;;371            {
;;;372    
;;;373                u32ClkDiv = u32Div / u32DSCnt;
000076  4621              MOV      r1,r4
000078  9802              LDR      r0,[sp,#8]
00007a  f7fffffe          BL       __aeabi_uidivmod
;;;374    
;;;375                if(u32ClkDiv > 0x400ul)
00007e  2101              MOVS     r1,#1
000080  0289              LSLS     r1,r1,#10
000082  4288              CMP      r0,r1
000084  d905              BLS      |L10.146|
;;;376                {
;;;377                    u32ClkDiv = 0x400ul;
000086  4608              MOV      r0,r1
;;;378                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
000088  9902              LDR      r1,[sp,#8]
00008a  02a2              LSLS     r2,r4,#10
00008c  1a8a              SUBS     r2,r1,r2
;;;379                    u32Tmp2 = u32Tmp + 1ul;
00008e  1c51              ADDS     r1,r2,#1
000090  e007              B        |L10.162|
                  |L10.146|
000092  4601              MOV      r1,r0
;;;380                }
;;;381                else
;;;382                {
;;;383                    u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
000094  9a02              LDR      r2,[sp,#8]
000096  4361              MULS     r1,r4,r1
000098  1a52              SUBS     r2,r2,r1
;;;384                    u32Tmp2 = ((u32ClkDiv + 1ul) * u32DSCnt) - u32Div;
00009a  1c41              ADDS     r1,r0,#1
00009c  9b02              LDR      r3,[sp,#8]
00009e  4361              MULS     r1,r4,r1
0000a0  1ac9              SUBS     r1,r1,r3
                  |L10.162|
;;;385                }
;;;386    
;;;387                if(u32Tmp >= u32Tmp2)
0000a2  428a              CMP      r2,r1
0000a4  d301              BCC      |L10.170|
0000a6  1c40              ADDS     r0,r0,#1
;;;388                {
;;;389                    u32ClkDiv = u32ClkDiv + 1ul;
0000a8  e000              B        |L10.172|
                  |L10.170|
;;;390                }
;;;391                else u32Tmp2 = u32Tmp;
0000aa  4611              MOV      r1,r2
                  |L10.172|
;;;392    
;;;393                if(u32Tmp2 < u32Min)
0000ac  42b9              CMP      r1,r7
0000ae  d203              BCS      |L10.184|
;;;394                {
;;;395                    u32Min = u32Tmp2;
0000b0  000f              MOVS     r7,r1
;;;396                    u32MinDSCnt = u32DSCnt;
;;;397                    u32MinClkDiv = u32ClkDiv;
;;;398    
;;;399                    /* Break when get good results */
;;;400                    if(u32Min == 0ul)
0000b2  9400              STR      r4,[sp,#0]
0000b4  9001              STR      r0,[sp,#4]
0000b6  d002              BEQ      |L10.190|
                  |L10.184|
0000b8  1c64              ADDS     r4,r4,#1
0000ba  2c10              CMP      r4,#0x10              ;370
0000bc  d9db              BLS      |L10.118|
                  |L10.190|
;;;401                    {
;;;402                        break;
;;;403                    }
;;;404                }
;;;405            }
;;;406    
;;;407        }
;;;408    
;;;409        /* Enable USCI_UART protocol */
;;;410        uuart->CTL &= ~UUART_CTL_FUNMODE_Msk;
0000be  6830              LDR      r0,[r6,#0]
0000c0  08c0              LSRS     r0,r0,#3
0000c2  00c0              LSLS     r0,r0,#3
0000c4  6030              STR      r0,[r6,#0]
;;;411        uuart->CTL = 2ul << UUART_CTL_FUNMODE_Pos;
0000c6  2002              MOVS     r0,#2
0000c8  6030              STR      r0,[r6,#0]
;;;412    
;;;413        /* Set USCI_UART line configuration */
;;;414        uuart->LINECTL = UUART_WORD_LEN_8 | UUART_LINECTL_LSB_Msk;
0000ca  4811              LDR      r0,|L10.272|
0000cc  62f0              STR      r0,[r6,#0x2c]
;;;415        uuart->DATIN0 = (2ul << UUART_DATIN0_EDGEDET_Pos);  /* Set falling edge detection */
0000ce  2010              MOVS     r0,#0x10
0000d0  6130              STR      r0,[r6,#0x10]
;;;416    
;;;417        /* Set USCI_UART baud rate */
;;;418        uuart->BRGEN = ((u32MinClkDiv - 1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000d2  9900              LDR      r1,[sp,#0]
0000d4  9801              LDR      r0,[sp,#4]
0000d6  028a              LSLS     r2,r1,#10
0000d8  2101              MOVS     r1,#1
0000da  1e40              SUBS     r0,r0,#1
0000dc  0289              LSLS     r1,r1,#10
0000de  0400              LSLS     r0,r0,#16
0000e0  1a51              SUBS     r1,r2,r1
0000e2  4308              ORRS     r0,r0,r1
0000e4  0229              LSLS     r1,r5,#8
0000e6  39ff              SUBS     r1,r1,#0xff
0000e8  3901              SUBS     r1,#1
0000ea  4308              ORRS     r0,r0,r1
0000ec  60b0              STR      r0,[r6,#8]
;;;419                       ((u32MinDSCnt - 1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;420                       ((u32PDSCnt - 1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;421    
;;;422        uuart->PROTCTL |= UUART_PROTCTL_PROTEN_Msk;
0000ee  6df0              LDR      r0,[r6,#0x5c]
0000f0  2101              MOVS     r1,#1
0000f2  07c9              LSLS     r1,r1,#31
0000f4  4308              ORRS     r0,r0,r1
0000f6  65f0              STR      r0,[r6,#0x5c]
;;;423    
;;;424        return (u32PCLKFreq / u32PDSCnt / u32MinDSCnt / u32MinClkDiv);
0000f8  4629              MOV      r1,r5
0000fa  9803              LDR      r0,[sp,#0xc]
0000fc  f7fffffe          BL       __aeabi_uidivmod
000100  9900              LDR      r1,[sp,#0]
000102  f7fffffe          BL       __aeabi_uidivmod
000106  9901              LDR      r1,[sp,#4]
000108  f7fffffe          BL       __aeabi_uidivmod
;;;425    }
00010c  b005              ADD      sp,sp,#0x14
00010e  bdf0              POP      {r4-r7,pc}
;;;426    
                          ENDP

                  |L10.272|
                          DCD      0x00000801

                          AREA ||i.UUART_Read||, CODE, READONLY, ALIGN=1

                  UUART_Read PROC
;;;438     */
;;;439    uint32_t UUART_Read(UUART_T* uuart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;440    {
000002  4604              MOV      r4,r0
;;;441        uint32_t  u32Count, u32delayno;
;;;442    
;;;443        for(u32Count = 0ul; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;444        {
;;;445            u32delayno = 0ul;
;;;446    
;;;447            while(uuart->BUFSTS & UUART_BUFSTS_RXEMPTY_Msk)   /* Check RX empty => failed */
;;;448            {
;;;449                u32delayno++;
;;;450                if(u32delayno >= 0x40000000ul)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L11.38|
                  |L11.12|
00000c  2300              MOVS     r3,#0                 ;445
00000e  e002              B        |L11.22|
                  |L11.16|
000010  1c5b              ADDS     r3,r3,#1              ;447
000012  42ab              CMP      r3,r5
000014  d202              BCS      |L11.28|
                  |L11.22|
000016  6be6              LDR      r6,[r4,#0x3c]         ;447
000018  07f6              LSLS     r6,r6,#31             ;447
00001a  d1f9              BNE      |L11.16|
                  |L11.28|
;;;451                {
;;;452                    break;
;;;453                }
;;;454            }
;;;455    
;;;456            if(u32delayno >= 0x40000000ul)
00001c  42ab              CMP      r3,r5
00001e  d204              BCS      |L11.42|
;;;457            {
;;;458                break;
;;;459            }
;;;460    
;;;461            pu8RxBuf[u32Count] = (uint8_t)uuart->RXDAT;    /* Get Data from USCI RX  */
000020  6b63              LDR      r3,[r4,#0x34]
000022  540b              STRB     r3,[r1,r0]
000024  1c40              ADDS     r0,r0,#1
                  |L11.38|
000026  4290              CMP      r0,r2                 ;443
000028  d3f0              BCC      |L11.12|
                  |L11.42|
;;;462        }
;;;463    
;;;464        return u32Count;
;;;465    
;;;466    }
00002a  bd70              POP      {r4-r6,pc}
;;;467    
                          ENDP


                          AREA ||i.UUART_SetLine_Config||, CODE, READONLY, ALIGN=2

                  UUART_SetLine_Config PROC
;;;491     */
;;;492    uint32_t UUART_SetLine_Config(UUART_T* uuart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t u32stop_bits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;493    {
000002  b085              SUB      sp,sp,#0x14
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;494        uint32_t u32PCLKFreq, u32PDSCnt, u32DSCnt, u32ClkDiv;
;;;495        uint32_t u32Tmp, u32Tmp2, u32Min, u32MinClkDiv, u32MinDSCnt;
;;;496        uint32_t u32Div;
;;;497    
;;;498        /* Get PCLK frequency */
;;;499        u32PCLKFreq = CLK_GetPCLK0Freq();
000008  f7fffffe          BL       CLK_GetPCLK0Freq
;;;500    
;;;501        if(u32baudrate != 0ul)
00000c  9003              STR      r0,[sp,#0xc]
00000e  2d00              CMP      r5,#0
000010  d066              BEQ      |L12.224|
;;;502        {
;;;503    
;;;504            /* Calculate baud rate divider */
;;;505            u32Div = u32PCLKFreq / u32baudrate;
000012  4629              MOV      r1,r5
000014  f7fffffe          BL       __aeabi_uidivmod
000018  4604              MOV      r4,r0
;;;506            u32Tmp = (u32PCLKFreq / u32Div) - u32baudrate;
00001a  4601              MOV      r1,r0
00001c  9803              LDR      r0,[sp,#0xc]
00001e  f7fffffe          BL       __aeabi_uidivmod
000022  1b47              SUBS     r7,r0,r5
;;;507            u32Tmp2 = u32baudrate - (u32PCLKFreq / (u32Div + 1ul));
000024  1c61              ADDS     r1,r4,#1
000026  9803              LDR      r0,[sp,#0xc]
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  1a28              SUBS     r0,r5,r0
;;;508    
;;;509            if(u32Tmp >= u32Tmp2) u32Div = u32Div + 1ul;
00002e  4287              CMP      r7,r0
000030  d300              BCC      |L12.52|
000032  1c64              ADDS     r4,r4,#1
                  |L12.52|
;;;510    
;;;511            if(u32Div >= 65536ul)
000034  2001              MOVS     r0,#1
000036  0400              LSLS     r0,r0,#16
000038  4284              CMP      r4,r0
00003a  d305              BCC      |L12.72|
;;;512            {
;;;513    
;;;514                /* Set the smallest baud rate that USCI_UART can generate */
;;;515                u32PDSCnt = 0x4ul;
;;;516                u32MinDSCnt = 0x10ul;
00003c  2010              MOVS     r0,#0x10
00003e  2504              MOVS     r5,#4                 ;515
;;;517                u32MinClkDiv = 0x400ul;
000040  9000              STR      r0,[sp,#0]
000042  0180              LSLS     r0,r0,#6
000044  9001              STR      r0,[sp,#4]
000046  e03c              B        |L12.194|
                  |L12.72|
;;;518    
;;;519            }
;;;520            else
;;;521            {
;;;522    
;;;523                u32Tmp = 0x400ul * 0x10ul;
000048  2101              MOVS     r1,#1
00004a  0389              LSLS     r1,r1,#14
;;;524                for(u32PDSCnt = 1ul; u32PDSCnt <= 0x04ul; u32PDSCnt++)
00004c  2501              MOVS     r5,#1
                  |L12.78|
;;;525                {
;;;526                    if(u32Div <= (u32Tmp * u32PDSCnt)) break;
00004e  4608              MOV      r0,r1
000050  4368              MULS     r0,r5,r0
000052  42a0              CMP      r0,r4
000054  d203              BCS      |L12.94|
000056  1c6d              ADDS     r5,r5,#1
000058  2d04              CMP      r5,#4                 ;524
00005a  d9f8              BLS      |L12.78|
00005c  e001              B        |L12.98|
                  |L12.94|
;;;527                }
;;;528    
;;;529                if(u32PDSCnt > 0x4ul) u32PDSCnt = 0x4ul;
00005e  2d04              CMP      r5,#4
000060  d900              BLS      |L12.100|
                  |L12.98|
000062  2504              MOVS     r5,#4
                  |L12.100|
;;;530    
;;;531                u32Div = u32Div / u32PDSCnt;
000064  4629              MOV      r1,r5
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       __aeabi_uidivmod
;;;532    
;;;533                /* Find best solution */
;;;534                u32Min = (uint32_t) - 1;
;;;535                u32MinDSCnt = 0ul;
00006c  9002              STR      r0,[sp,#8]
00006e  2000              MOVS     r0,#0
000070  2700              MOVS     r7,#0                 ;534
000072  43ff              MVNS     r7,r7                 ;534
;;;536                u32MinClkDiv = 0ul;
000074  9000              STR      r0,[sp,#0]
;;;537    
;;;538                for(u32DSCnt = 6ul; u32DSCnt <= 0x10ul; u32DSCnt++)   /* DSCNT could be 0x5~0xF */
000076  2406              MOVS     r4,#6
000078  9001              STR      r0,[sp,#4]
                  |L12.122|
;;;539                {
;;;540                    u32ClkDiv = u32Div / u32DSCnt;
00007a  4621              MOV      r1,r4
00007c  9802              LDR      r0,[sp,#8]
00007e  f7fffffe          BL       __aeabi_uidivmod
;;;541    
;;;542                    if(u32ClkDiv > 0x400ul)
000082  2101              MOVS     r1,#1
000084  0289              LSLS     r1,r1,#10
000086  4288              CMP      r0,r1
000088  d905              BLS      |L12.150|
;;;543                    {
;;;544                        u32ClkDiv = 0x400ul;
00008a  4608              MOV      r0,r1
;;;545                        u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
00008c  9902              LDR      r1,[sp,#8]
00008e  02a2              LSLS     r2,r4,#10
000090  1a8a              SUBS     r2,r1,r2
;;;546                        u32Tmp2 = u32Tmp + 1ul;
000092  1c51              ADDS     r1,r2,#1
000094  e007              B        |L12.166|
                  |L12.150|
000096  4601              MOV      r1,r0
;;;547                    }
;;;548                    else
;;;549                    {
;;;550                        u32Tmp = u32Div - (u32ClkDiv * u32DSCnt);
000098  9a02              LDR      r2,[sp,#8]
00009a  4361              MULS     r1,r4,r1
00009c  1a52              SUBS     r2,r2,r1
;;;551                        u32Tmp2 = ((u32ClkDiv + 1ul) * u32DSCnt) - u32Div;
00009e  1c41              ADDS     r1,r0,#1
0000a0  9b02              LDR      r3,[sp,#8]
0000a2  4361              MULS     r1,r4,r1
0000a4  1ac9              SUBS     r1,r1,r3
                  |L12.166|
;;;552                    }
;;;553    
;;;554                    if(u32Tmp >= u32Tmp2)
0000a6  428a              CMP      r2,r1
0000a8  d301              BCC      |L12.174|
0000aa  1c40              ADDS     r0,r0,#1
;;;555                    {
;;;556                        u32ClkDiv = u32ClkDiv + 1ul;
0000ac  e000              B        |L12.176|
                  |L12.174|
;;;557                    }
;;;558                    else u32Tmp2 = u32Tmp;
0000ae  4611              MOV      r1,r2
                  |L12.176|
;;;559    
;;;560                    if(u32Tmp2 < u32Min)
0000b0  42b9              CMP      r1,r7
0000b2  d203              BCS      |L12.188|
;;;561                    {
;;;562                        u32Min = u32Tmp2;
0000b4  000f              MOVS     r7,r1
;;;563                        u32MinDSCnt = u32DSCnt;
;;;564                        u32MinClkDiv = u32ClkDiv;
;;;565    
;;;566                        /* Break when get good results */
;;;567                        if(u32Min == 0ul)
0000b6  9400              STR      r4,[sp,#0]
0000b8  9001              STR      r0,[sp,#4]
0000ba  d002              BEQ      |L12.194|
                  |L12.188|
0000bc  1c64              ADDS     r4,r4,#1
0000be  2c10              CMP      r4,#0x10              ;538
0000c0  d9db              BLS      |L12.122|
                  |L12.194|
;;;568                        {
;;;569                            break;
;;;570                        }
;;;571                    }
;;;572                }
;;;573    
;;;574            }
;;;575    
;;;576            /* Set USCI_UART baud rate */
;;;577            uuart->BRGEN = ((u32MinClkDiv - 1ul) << UUART_BRGEN_CLKDIV_Pos) |
0000c2  9900              LDR      r1,[sp,#0]
0000c4  9801              LDR      r0,[sp,#4]
0000c6  028a              LSLS     r2,r1,#10
0000c8  2101              MOVS     r1,#1
0000ca  1e40              SUBS     r0,r0,#1
0000cc  0289              LSLS     r1,r1,#10
0000ce  0400              LSLS     r0,r0,#16
0000d0  1a51              SUBS     r1,r2,r1
0000d2  4308              ORRS     r0,r0,r1
0000d4  0229              LSLS     r1,r5,#8
0000d6  39ff              SUBS     r1,r1,#0xff
0000d8  3901              SUBS     r1,#1
0000da  4308              ORRS     r0,r0,r1
0000dc  60b0              STR      r0,[r6,#8]
0000de  e00d              B        |L12.252|
                  |L12.224|
;;;578                           ((u32MinDSCnt - 1ul) << UUART_BRGEN_DSCNT_Pos) |
;;;579                           ((u32PDSCnt - 1ul) << UUART_BRGEN_PDSCNT_Pos);
;;;580        }
;;;581        else
;;;582        {
;;;583            u32PDSCnt = ((uuart->BRGEN & UUART_BRGEN_PDSCNT_Msk) >> UUART_BRGEN_PDSCNT_Pos) + 1ul;
0000e0  68b0              LDR      r0,[r6,#8]
;;;584            u32MinDSCnt = ((uuart->BRGEN & UUART_BRGEN_DSCNT_Msk) >> UUART_BRGEN_DSCNT_Pos) + 1ul;
;;;585            u32MinClkDiv = ((uuart->BRGEN & UUART_BRGEN_CLKDIV_Msk) >> UUART_BRGEN_CLKDIV_Pos) + 1ul;
;;;586        }
;;;587    
;;;588        /* Set USCI_UART line configuration */
;;;589        uuart->LINECTL = (uuart->LINECTL & ~UUART_LINECTL_DWIDTH_Msk) | u32data_width;
;;;590        uuart->PROTCTL = (uuart->PROTCTL & ~(UUART_PROTCTL_STICKEN_Msk | UUART_PROTCTL_EVENPARITY_Msk |
;;;591                                             UUART_PROTCTL_PARITYEN_Msk)) | u32parity;
;;;592        uuart->PROTCTL = (uuart->PROTCTL & ~UUART_PROTCTL_STOPB_Msk) | u32stop_bits;
;;;593    
;;;594        return (u32PCLKFreq / u32PDSCnt / u32MinDSCnt / u32MinClkDiv);
;;;595    }
0000e2  0580              LSLS     r0,r0,#22
0000e4  0f85              LSRS     r5,r0,#30
0000e6  68b0              LDR      r0,[r6,#8]            ;584
0000e8  0440              LSLS     r0,r0,#17
0000ea  0ec0              LSRS     r0,r0,#27
0000ec  1c40              ADDS     r0,r0,#1
0000ee  9000              STR      r0,[sp,#0]            ;585
0000f0  68b0              LDR      r0,[r6,#8]            ;585
0000f2  0180              LSLS     r0,r0,#6
0000f4  0d80              LSRS     r0,r0,#22
0000f6  1c40              ADDS     r0,r0,#1
0000f8  1c6d              ADDS     r5,r5,#1              ;585
0000fa  9001              STR      r0,[sp,#4]            ;585
                  |L12.252|
0000fc  6af0              LDR      r0,[r6,#0x2c]         ;589
0000fe  210f              MOVS     r1,#0xf               ;589
000100  0209              LSLS     r1,r1,#8              ;589
000102  4388              BICS     r0,r0,r1              ;589
000104  9907              LDR      r1,[sp,#0x1c]         ;589
000106  4308              ORRS     r0,r0,r1              ;589
000108  62f0              STR      r0,[r6,#0x2c]         ;589
00010a  6df0              LDR      r0,[r6,#0x5c]         ;590
00010c  490b              LDR      r1,|L12.316|
00010e  4008              ANDS     r0,r0,r1              ;590
000110  9908              LDR      r1,[sp,#0x20]         ;590
000112  4308              ORRS     r0,r0,r1              ;590
000114  65f0              STR      r0,[r6,#0x5c]         ;590
000116  6df0              LDR      r0,[r6,#0x5c]         ;592
000118  990e              LDR      r1,[sp,#0x38]         ;592
00011a  0840              LSRS     r0,r0,#1              ;592
00011c  0040              LSLS     r0,r0,#1              ;592
00011e  4308              ORRS     r0,r0,r1              ;592
000120  65f0              STR      r0,[r6,#0x5c]         ;592
000122  4629              MOV      r1,r5                 ;594
000124  9803              LDR      r0,[sp,#0xc]          ;594
000126  f7fffffe          BL       __aeabi_uidivmod
00012a  9900              LDR      r1,[sp,#0]            ;594
00012c  f7fffffe          BL       __aeabi_uidivmod
000130  9901              LDR      r1,[sp,#4]            ;594
000132  f7fffffe          BL       __aeabi_uidivmod
000136  b009              ADD      sp,sp,#0x24
000138  bdf0              POP      {r4-r7,pc}
;;;596    
                          ENDP

00013a  0000              DCW      0x0000
                  |L12.316|
                          DCD      0xfbfffff9

                          AREA ||i.UUART_Write||, CODE, READONLY, ALIGN=1

                  UUART_Write PROC
;;;608     */
;;;609    uint32_t UUART_Write(UUART_T* uuart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes)
000000  b570              PUSH     {r4-r6,lr}
;;;610    {
000002  4604              MOV      r4,r0
;;;611        uint32_t  u32Count, u32delayno;
;;;612    
;;;613        for(u32Count = 0ul; u32Count != u32WriteBytes; u32Count++)
000004  2000              MOVS     r0,#0
;;;614        {
;;;615            u32delayno = 0ul;
;;;616            while((uuart->BUFSTS & UUART_BUFSTS_TXEMPTY_Msk) == 0ul)   /* Wait Tx empty */
;;;617            {
;;;618                u32delayno++;
;;;619                if(u32delayno >= 0x40000000ul)
000006  2501              MOVS     r5,#1
000008  07ad              LSLS     r5,r5,#30
00000a  e00c              B        |L13.38|
                  |L13.12|
00000c  2300              MOVS     r3,#0                 ;615
00000e  e002              B        |L13.22|
                  |L13.16|
000010  1c5b              ADDS     r3,r3,#1              ;616
000012  42ab              CMP      r3,r5
000014  d202              BCS      |L13.28|
                  |L13.22|
000016  6be6              LDR      r6,[r4,#0x3c]         ;616
000018  05f6              LSLS     r6,r6,#23             ;616
00001a  d5f9              BPL      |L13.16|
                  |L13.28|
;;;620                {
;;;621                    break;
;;;622                }
;;;623            }
;;;624    
;;;625            if(u32delayno >= 0x40000000ul)
00001c  42ab              CMP      r3,r5
00001e  d204              BCS      |L13.42|
;;;626            {
;;;627                break;
;;;628            }
;;;629    
;;;630            uuart->TXDAT = (uint8_t)pu8TxBuf[u32Count];    /* Send USCI_UART Data to buffer */
000020  5c0b              LDRB     r3,[r1,r0]
000022  6323              STR      r3,[r4,#0x30]
000024  1c40              ADDS     r0,r0,#1
                  |L13.38|
000026  4290              CMP      r0,r2                 ;613
000028  d1f0              BNE      |L13.12|
                  |L13.42|
;;;631        }
;;;632    
;;;633        return u32Count;
;;;634    }
00002a  bd70              POP      {r4-r6,pc}
;;;635    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\..\\Library\\StdDriver\\src\\usci_uart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___11_usci_uart_c_2f0f282b____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_usci_uart_c_2f0f282b____REVSH|
#line 402
|__asm___11_usci_uart_c_2f0f282b____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
